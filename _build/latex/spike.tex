% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,openany,oneside]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}


\title{SPIKE Documentation}
\date{December 03, 2014}
\release{1.0}
\author{}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\renewcommand\PYGZsq{\textquotesingle}

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}


Contents:


\chapter{Introduction}
\label{rst/introduction:introduction}\label{rst/introduction::doc}\label{rst/introduction:welcome-to-spike-documentation}
This is the beta version of the SPIKE program.


\section{What is SPIKE ?}
\label{rst/introduction:what-is-spike}
SPIKE is a program coming from a first-development oriented one named NPK-V2 that allows the processing, the display and the analysis of data-sets obtained from various Fourier-Transform spectroscopies. It stands for Spectrometry Processing Innovative KErnel.

For the moment, il handles the following data-sets
\begin{itemize}
\item {} 
NMR - 1D and 2D are fully supported

\item {} 
FT-ICR - 1D and 2D are fully supported

\item {} 
Orbitrap - 1D only

\item {} 
other spectroscopies are being considered

\end{itemize}

Files can be imported from
\begin{itemize}
\item {} 
NMR : Bruker topspin

\item {} 
FT-ICR : Bruker Apex

\item {} 
Orbitrap : Thermofisher raw data

\end{itemize}

It allows to process datasets interactively from an ipython prompt or interactively using the processing.py batch program (aimed towad FT-ICR for the moment)
The batch mode supports multiprocessing, both with MPI and natively on multi-core machines (still in-progress).Data-sets are handled in the HDF5 standard file-format, which allows virtually unlimited file size.

Version : this is 0.5 beta version


\section{How do I get set up?}
\label{rst/introduction:how-do-i-get-set-up}
The program is in python 2.7.
Look at the examples files ({\color{red}\bfseries{}eg\_}.py) and at configuration files (.mscf) they contain valuable examples and some documentation.
SPIKE requires the following libraries :
\begin{itemize}
\item {} 
numpy

\item {} 
scipy

\item {} 
matplotlib

\item {} 
Qt / PySide

\item {} 
Pytables

\item {} 
mpi4py * ...

\end{itemize}

It has been successfully tested in the Enthought and anaconda link distributions.


\section{Organisation of the Code}
\label{rst/introduction:organisation-of-the-code}
The main program is NPKData.py, which defines NPKData object on which everything is built.
Spectroscopies are defined in the FTICR.py and Orbitrap.py code, which sub class NPKData It is prototyped as an NMR data-set, but this will change.
Many programs contain routines tests (in an object unittest) that also serve as an example of use.


\section{Main programs :}
\label{rst/introduction:main-programs}
A small description of the files: - NPKData.py the main library, allows all processing for NMR experiments (1D, 2D and 3D) to be used as a library, in a stand-alone program or in ipython interactive session - FTICR.py an extension of NPKData for processing FT-ICR datasets (1D and 2D) - Orbitrap.py an extension of NPKData for processing Orbitrap datasets (1D)
\begin{quote}

processing.py a stand alone program, written on the top of FTICR.py, allowing the efficient processing of FT-ICR 2D datasets, with no limit on the size of the final file Produces multi-resolution files syntax : python processing.py param\_file.mscf
visu2D.py an interactive tool for visualizing 2D FT-ICR multi-resolution files python visu2D.py param\_file.mscf
\end{quote}


\section{Directories}
\label{rst/introduction:directories}
Three main directories
\begin{itemize}
\item {} 
Algo contains algorithms to process data-sets (MaxEnt, Laplace, etc...) not everything active !

\item {} 
File Importers for various file format for spectrometry, as well as the HDF5 SPIKE native format.

\item {} 
Visu utilities for the Visu2D program

\end{itemize}

Some usage examples
\begin{itemize}
\item {} 
SPIKE\_usage\_eg example python programs using the various library available

\end{itemize}

Various codes
\begin{itemize}
\item {} 
Miscellaneous ``en vrac''

\item {} 
Display a small utility to choose either for regular matplotlib display of fake no-effect display (for tests)

\item {} 
util set of low-level tools used all over in the code

\item {} 
v1 a library implementing a compatibility with the NPKV\_V1 program

\end{itemize}

example of configuration files
\begin{itemize}
\item {} 
process\_eg.mscf

\item {} 
test.mscf

\end{itemize}

and various utilities
\begin{itemize}
\item {} 
NPKConfigParser.py reads .mscf files

\item {} 
NPKError.py generates error msg

\item {} 
QC.py Quality Check

\item {} 
Tests.py runs all tests

\item {} 
dev\_setup.py rolls a new version

\item {} 
version.py defines version number

\item {} 
init.py defines library

\item {} 
rcpylint

\item {} 
To\_Do\_list.txt

\item {} 
QC.txt

\item {} 
Release.txt

\end{itemize}


\section{Authors and Licence}
\label{rst/introduction:authors-and-licence}
Authors for this code are :

Marc-André Delsuc - CNRS

Lionel Chiron - CNRS then NMRTEC then Casc4de

Marie-Aude Coutouly - NMRTEC

Covered code is provided under this license on an ``as is'' basis, without warranty of any kind, either expressed or implied, including, without limitation, warranties that the covered code is free of defects. The entire risk as to the quality and performance of the covered code is with you. Should any covered code prove defective in any respect, you (not the initial developer or any other contributor) assume the cost of any necessary servicing, repair or correction.

Downloading code and datasets from this page signifies acceptance of the hereunder License Agreement. The code distributed here is covered under the CeCILL licence.


\chapter{Tutorial}
\label{rst/tutorial::doc}\label{rst/tutorial:tutorial}
Few examples of how to use SPIKE.
We begin first with simple import for both FTICR datasets and Orbitrap datasets then we show how to make more elaborated commands involving data treatment algorithms such as RECITAL and urQRd.

First, open in SPIKE directory a terminal and launch a IPython Notebook document writing:
\begin{quote}

ipython notebook
\end{quote}

We assume that the data are in a directory next to SPIKE directory named DATA\_test.


\section{FTICR}
\label{rst/tutorial:fticr}\begin{itemize}
\item {} 
simple import of native dataset

\item {} 
Show the FID

\item {} 
Show the half truncated FID and full FID

\item {} 
Doing FFT with zerofilling

\end{itemize}


\subsection{simple import of native dataset}
\label{rst/tutorial:simple-import-of-native-dataset}
from File.Apex import Import\_1D

import numpy as np

import matplotlib.pyplot as plt

from FTICR import FTICRData

Import from Apex

f = Import\_1D(''../DATA\_test/angio\_ms\_000005.d'')


\subsection{Show the FID}
\label{rst/tutorial:show-the-fid}
f = Import\_1D(''../DATA\_test/angio\_ms\_000005.d'')

f.display(label = ``FID'')


\subsection{Show the half truncated FID and full FID}
\label{rst/tutorial:show-the-half-truncated-fid-and-full-fid}
f = Import\_1D(''../DATA\_test/angio\_ms\_000005.d'')

f.chsize(len(f.buffer)/2)

ff = f.copy()

ff.buffer = ff.buffer{[}:len(f.buffer)/2{]}/2

f.display(label = ``FID'')

f.display(label = ``FID cut'', new\_fig = False)


\subsection{Doing FFT with zerofilling}
\label{rst/tutorial:doing-fft-with-zerofilling}
Classical FFT with apodisation and zerofilling.

FFT with zerofilling, processing cutting the pipes.

Here instead of writing a single long command with pipelines, the command is cut in many chunks.
This can be used for performing intermediate operations not present in SPIKE.


\section{Orbitrap}
\label{rst/tutorial:orbitrap}
Some examples on how to use NPKv2.
\begin{itemize}
\item {} 
simple import of native dataset.

\item {} 
simple FID handling, processing and display

\item {} 
FFT with zerofilling

\end{itemize}

We begin first with simple import then we show how to make more elaborated commands involving data treatment algorithms such as RECITAL and urQRd.


\subsection{simple import of native dataset}
\label{rst/tutorial:id1}
o = Import\_1D(``C:/Users/Egor/NPK\_V2/DATA\_test/ubiquitin\_5\_scan\_res\_30000\_1.dat'')


\subsection{Show FID}
\label{rst/tutorial:show-fid}
o.display(label = ``FID'')


\subsection{FFT with zerofilling}
\label{rst/tutorial:fft-with-zerofilling}
print o

o.apod\_sin(maxi = 0.5).chsize(o.buffer.size*2).rfft().modulus()

o.units = `m/z'

o.display(label = ``zerofill x2'')


\subsection{FFT with zerofilling, processing cutting the pipes.}
\label{rst/tutorial:fft-with-zerofilling-processing-cutting-the-pipes}
o = Import\_1D(filename)

o.units = `m/z'

o.apod\_sin(maxi = 0.5)

o.chsize(o.buffer.size*4)

o.rfft()

o.modulus().display(label = ``zerofill x4'')


\section{urQRd}
\label{rst/tutorial:urqrd}
is a preprocessing technique used for reducing the noise.
The parameter \$k\$ given to urQRd is related to the number of expected lines in the spectrum.
It should be chosen 2 to 3 times larger than this expected number.
Be carefull than the processing time \textbf{and} the memory footprint are both proportionnal to this value.

data.units = `m/z'

data.urqrd(k = 300).rfft().modulus().display(label = ``urQRd, rank = 300'')


\subsection{Additional tricks}
\label{rst/tutorial:additional-tricks}
IPython shortcuts.

there are \emph{many} shortcuts and tricks in IPython, read the doc !

a couple of them are really helpfull for MS processing
\begin{itemize}
\item {} 
you can execute a cell by hitting \emph{shift-return}

\item {} 
you can get the documentation of any function by adding a ? at the end of its name, eg \emph{o.rfft?}

\item {} 
you can get all possible values by hitting the \emph{\textless{}TAB\textgreater{}} key. Try for instance typing \emph{o. \textless{}TAB\textgreater{}}

\end{itemize}


\subsection{SPIKE arcanes}
\label{rst/tutorial:spike-arcanes}
If needed, you can directly manipulate the numeric data held into the SPIKE dataset:
\begin{itemize}
\item {} 
the \emph{.get\_buffer()} method returns the underlying \emph{numpy} array.

\item {} 
The \emph{.set\_buffer()} method sets it, data can be real or complex.

\item {} 
Do \emph{.adapt\_size()} afterwards if you changed the number of points.

\end{itemize}

It is also possible to use this sheet as a simple calculator, can be handy some time, for instance for checking charge state.


\chapter{Code}
\label{rst/code:code}\label{rst/code::doc}

\section{NPKData}
\label{rst/code:npkdata}\label{rst/code:module-NPKData}\index{NPKData (module)}
NPKData.py

Implement the basic mechanisms for NMR data-sets

Created by Marc-André and Marie-Aude on 2010-03-17.
Copyright (c) 2010 IGBMC and NMRTEC. All rights reserved.
\index{Axis (class in NPKData)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.Axis}\pysiglinewithargsret{\strong{class }\code{NPKData.}\bfcode{Axis}}{\emph{size=64}, \emph{itype=0}, \emph{units='point'}}{}
hold information for one spectral axis
used internally
\index{check\_zoom() (NPKData.Axis method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.Axis.check_zoom}\pysiglinewithargsret{\bfcode{check\_zoom}}{\emph{zoom}}{}
check whether a zoom window, given as (low,high) is valid
- check low\textless{}high and within axis size
- check that it starts on a real index in itype is complex
return a boolean

\end{fulllineitems}

\index{get\_sampling() (NPKData.Axis method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.Axis.get_sampling}\pysiglinewithargsret{\bfcode{get\_sampling}}{}{}
returns the sampling scheme contained in current axis

\end{fulllineitems}

\index{load\_sampling() (NPKData.Axis method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.Axis.load_sampling}\pysiglinewithargsret{\bfcode{load\_sampling}}{\emph{filename}}{}
loads the sampling scheme contained in an external file
file should contain index values, one per line, comment lines start with a \#
complex axes should be sampled by complex pairs, and indices go up to self.size1/2

sampling is loaded into self.sampling  and self.sampling\_info is a dictionnary with information

\end{fulllineitems}

\index{points\_axis() (NPKData.Axis method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.Axis.points_axis}\pysiglinewithargsret{\bfcode{points\_axis}}{}{}
return axis in points units, actually 0..size-1

\end{fulllineitems}

\index{sampled (NPKData.Axis attribute)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.Axis.sampled}\pysigline{\bfcode{sampled}}
true is sampled axis

\end{fulllineitems}

\index{set\_sampling() (NPKData.Axis method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.Axis.set_sampling}\pysiglinewithargsret{\bfcode{set\_sampling}}{\emph{sampling}}{}
sets the sampling scheme contained in current axis

\end{fulllineitems}

\index{typestr() (NPKData.Axis method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.Axis.typestr}\pysiglinewithargsret{\bfcode{typestr}}{}{}
returns its type (real or complex) as a string

\end{fulllineitems}

\index{unit\_axis() (NPKData.Axis method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.Axis.unit_axis}\pysiglinewithargsret{\bfcode{unit\_axis}}{}{}
returns an axis in the unit defined in self.units

\end{fulllineitems}


\end{fulllineitems}

\index{LaplaceAxis (class in NPKData)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.LaplaceAxis}\pysiglinewithargsret{\strong{class }\code{NPKData.}\bfcode{LaplaceAxis}}{\emph{size=64}, \emph{dmin=1.0}, \emph{dmax=10.0}, \emph{dfactor=1.0}, \emph{units='points'}}{}
hold information for one Laplace axis (DOSY)
used internally
\index{dtoi() (NPKData.LaplaceAxis method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.LaplaceAxis.dtoi}\pysiglinewithargsret{\bfcode{dtoi}}{\emph{value}}{}
returns point value (i) from damping value (d)

\end{fulllineitems}

\index{itod() (NPKData.LaplaceAxis method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.LaplaceAxis.itod}\pysiglinewithargsret{\bfcode{itod}}{\emph{value}}{}
returns damping value (d) from point value (i)

\end{fulllineitems}

\index{report() (NPKData.LaplaceAxis method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.LaplaceAxis.report}\pysiglinewithargsret{\bfcode{report}}{}{}
hight level report

\end{fulllineitems}


\end{fulllineitems}

\index{NMRAxis (class in NPKData)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NMRAxis}\pysiglinewithargsret{\strong{class }\code{NPKData.}\bfcode{NMRAxis}}{\emph{size=64}, \emph{specwidth=6283.185307179586}, \emph{offset=0.0}, \emph{frequency=400.0}, \emph{itype=0}, \emph{units='points'}}{}
hold information for one NMR axis
used internally
\index{Hz\_axis() (NPKData.NMRAxis method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NMRAxis.Hz_axis}\pysiglinewithargsret{\bfcode{Hz\_axis}}{}{}
return axis containing Hz values, can be used for display

\end{fulllineitems}

\index{extract() (NPKData.NMRAxis method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NMRAxis.extract}\pysiglinewithargsret{\bfcode{extract}}{\emph{(start}, \emph{end)}}{}
redefines the axis parameters so that the new axe is extracted for the points {[}start:end{]}

\end{fulllineitems}

\index{freq\_axis() (NPKData.NMRAxis method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NMRAxis.freq_axis}\pysiglinewithargsret{\bfcode{freq\_axis}}{}{}
return axis containing Hz values, can be used for display

\end{fulllineitems}

\index{htoi() (NPKData.NMRAxis method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NMRAxis.htoi}\pysiglinewithargsret{\bfcode{htoi}}{\emph{value}}{}
returns point value (i) from Hz value (h)

\end{fulllineitems}

\index{htop() (NPKData.NMRAxis method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NMRAxis.htop}\pysiglinewithargsret{\bfcode{htop}}{\emph{value}}{}
returns ppm value (p) from Hz value (h)

\end{fulllineitems}

\index{itoh() (NPKData.NMRAxis method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NMRAxis.itoh}\pysiglinewithargsret{\bfcode{itoh}}{\emph{value}}{}
returns Hz value (h) from point value (i)

\end{fulllineitems}

\index{itop() (NPKData.NMRAxis method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NMRAxis.itop}\pysiglinewithargsret{\bfcode{itop}}{\emph{value}}{}
returns ppm value (p) from point value (i)

\end{fulllineitems}

\index{ppm\_axis() (NPKData.NMRAxis method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NMRAxis.ppm_axis}\pysiglinewithargsret{\bfcode{ppm\_axis}}{}{}
return axis containing ppm values, can be used for display

\end{fulllineitems}

\index{ptoh() (NPKData.NMRAxis method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NMRAxis.ptoh}\pysiglinewithargsret{\bfcode{ptoh}}{\emph{value}}{}
returns Hz value (h) from ppm value (p)

\end{fulllineitems}

\index{ptoi() (NPKData.NMRAxis method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NMRAxis.ptoi}\pysiglinewithargsret{\bfcode{ptoi}}{\emph{value}}{}
returns point value (i) from ppm value (p)

\end{fulllineitems}

\index{report() (NPKData.NMRAxis method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NMRAxis.report}\pysiglinewithargsret{\bfcode{report}}{}{}
high level reporting

\end{fulllineitems}


\end{fulllineitems}

\index{NPKData (class in NPKData)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData}\pysiglinewithargsret{\strong{class }\code{NPKData.}\bfcode{NPKData}}{\emph{dim=1}, \emph{shape=None}, \emph{buffer=None}, \emph{name=None}, \emph{debug=0}}{}
a working data used by the NPK package

The data is a numpy array, found in self.buffer     can also be accessed directly d{[}i{]}, d{[}i,j{]}, ...

1D 2D and 3D are handled, 3 axes are defined : axis1 axis2 axis3
axes are defined as in NMR
in 1D, every is in axis1
in 2D, the fastest varying dimension is in axis2, the slowest in axis1
in 3D, the fastest varying dimension is in axis3, the slowest in axis1
see axis\_index
typical properties and methods are :
utilities:
\begin{quote}

.display() 
.check()
\end{quote}
\begin{description}
\item[{properties}] \leavevmode
.itype
.dim .size1, .size2, .size3 ...

\item[{moving data :}] \leavevmode
.row(i) .col(i) .set\_row(i)  .set\_col(i)
.copy()
.load() .save()

\item[{processing :}] \leavevmode
.fft() .rfft() .modulus() .apod\_xxx()  sg()  transpose() ...

\item[{arithmetics :}] \leavevmode
.fill() .mult .add()
also direct arithmetics : f = 2*d+e

\end{description}

all methods return self, so computation can be piped
etc...
\index{abs() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.abs}\pysiglinewithargsret{\bfcode{abs}}{}{}
This command takes the absolute value of the current the data set

\end{fulllineitems}

\index{adapt\_size() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.adapt_size}\pysiglinewithargsret{\bfcode{adapt\_size}}{}{}
adapt the sizes held in the axis objects to the size of the buffer
TO BE CALLED each time the buffer size is modified
otherwise strange things will happen

\end{fulllineitems}

\index{add() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.add}\pysiglinewithargsret{\bfcode{add}}{\emph{otherdata}}{}
add the provided data : otherdata to the current one
eg : data.add(otherdata) add content of otherdata to data buffer

can add NPKData and numbers

\end{fulllineitems}

\index{addbase() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.addbase}\pysiglinewithargsret{\bfcode{addbase}}{\emph{constant}}{}
add a constant to the data

\end{fulllineitems}

\index{addfreq() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.addfreq}\pysiglinewithargsret{\bfcode{addfreq}}{\emph{freq}, \emph{amp=1.0}}{}
add to the current data-set (1D, 2D, 3D) a single frequency sinusoid
characterized by its frequency (from axis.specwidth) and amplitude

\end{fulllineitems}

\index{addnoise() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.addnoise}\pysiglinewithargsret{\bfcode{addnoise}}{\emph{noise}, \emph{seed=None}}{}
add to the current data-set (1D, 2D, 3D) a white-gaussian, 
characterized by its level noise, and the random generator seed.

\end{fulllineitems}

\index{apod\_apply() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.apod_apply}\pysiglinewithargsret{\bfcode{apod\_apply}}{\emph{axis}, \emph{apod\_buf}}{}
apply an apodisation, held into the buffer apod\_buf

\end{fulllineitems}

\index{apod\_em() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.apod_em}\pysiglinewithargsret{\bfcode{apod\_em}}{\emph{axis=0}, \emph{lb=1.0}}{}
apply an exponential apodisation, lb is in Hz
WARNING : different from common definition of apodisation

\end{fulllineitems}

\index{apod\_gm() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.apod_gm}\pysiglinewithargsret{\bfcode{apod\_gm}}{\emph{axis=0}, \emph{gb=1.0}}{}
apply an gaussian apodisation, gb is in Hz
WARNING : different from common definition of apodisation

\end{fulllineitems}

\index{apod\_sin() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.apod_sin}\pysiglinewithargsret{\bfcode{apod\_sin}}{\emph{axis=0}, \emph{maxi=0}}{}
apply a sinebell apodisation
maxi ranges from 0 to 0.5

\end{fulllineitems}

\index{apod\_sq\_sin() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.apod_sq_sin}\pysiglinewithargsret{\bfcode{apod\_sq\_sin}}{\emph{axis=0}, \emph{maxi=0}}{}
apply a squared sinebell apodisation
maxi ranges from 0 to 0.5

\end{fulllineitems}

\index{apod\_tm() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.apod_tm}\pysiglinewithargsret{\bfcode{apod\_tm}}{\emph{axis=0}, \emph{tm1=0}, \emph{tm2=0}}{}
apply a trapezoide apodisation, lb is in Hz
WARNING : different from common definition of apodisation
This commands applies a trapezoid filter function to the data-
set. The function raises from 0.0 to 1.0 from the first point to 
point n1. The function then stays to 1.0 until point n2, from which 
it goes down to 0.0 at the last point.
If in 2D or 3D then Fx tells on which axis to apply the filter.

\end{fulllineitems}

\index{apply\_process() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.apply_process}\pysiglinewithargsret{\bfcode{apply\_process}}{\emph{axis\_it}, \emph{process}, \emph{axis=0}, \emph{mp=True}, \emph{N\_proc=None}}{}
scans through given data, using axis\_it which is an iterator,
applying process method (by its name)
store results into self, along to axis
if axis\_it iterates over self, then processing is in-place
\begin{quote}

however it can iterate over an other data-set, thus importing the data
\end{quote}

if self.dim is equal to axis\_it().dim, then data are

if mp,  does it in a multiprocessing fashion using multiprocessing.Pool()
if N\_proc is None, finds the optimum number itself.

\end{fulllineitems}

\index{axes() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.axes}\pysiglinewithargsret{\bfcode{axes}}{\emph{axis}}{}
returns the required axis : 1, 2 or 3

\end{fulllineitems}

\index{centroid1d() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.centroid1d}\pysiglinewithargsret{\bfcode{centroid1d}}{\emph{npoints=3}}{}
from peak lists determined with peak()
realize a centroid fit of the peak summit and width,
computes Full width at half maximum
creates lists self.centered\_peaks and self.width\_peaks
\begin{description}
\item[{Temporary  so far,}] \leavevmode
only based on regular sampling, not unit axis.
ah-hoc structure, waiting for a real PEAK object

\end{description}

\end{fulllineitems}

\index{check() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.check}\pysiglinewithargsret{\bfcode{check}}{\emph{warn=False}}{}
check basic internal validity
raises exceptions unless warn is set to True - in which case, only warnings are issued
can be used in pipes as it returns self if everything is ok

\end{fulllineitems}

\index{check1D() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.check1D}\pysiglinewithargsret{\bfcode{check1D}}{}{}
true for a 1D

\end{fulllineitems}

\index{check2D() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.check2D}\pysiglinewithargsret{\bfcode{check2D}}{}{}
true for a 2D

\end{fulllineitems}

\index{check3D() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.check3D}\pysiglinewithargsret{\bfcode{check3D}}{}{}
true for a 3D

\end{fulllineitems}

\index{check\_zoom() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.check_zoom}\pysiglinewithargsret{\bfcode{check\_zoom}}{\emph{zoom}}{}
check whether a zoom window, given as (low,high) or ((low1,high1),(low2,high2))  is valid
- check low\textless{}high and within axis size
- check that it starts on a real index in itype is complex
return a boolean

\end{fulllineitems}

\index{chsize() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.chsize}\pysiglinewithargsret{\bfcode{chsize}}{\emph{sz1=-1}, \emph{sz2=-1}, \emph{sz3=-1}}{}
Change size of data, zero-fill or truncate. 
DO NOT change the value of OFFSET and SPECW, so EXTRACT should 
always be preferred on spectra (unless you know exactly what your are doing).

\end{fulllineitems}

\index{col() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.col}\pysiglinewithargsret{\bfcode{col}}{\emph{i}}{}
returns a 1D extracted from the current 2D at position 0\textless{}=i\textless{}=size2-1

\end{fulllineitems}

\index{conjg() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.conjg}\pysiglinewithargsret{\bfcode{conjg}}{\emph{axis=0}}{}
take the inverse conjugate of the buffer

\end{fulllineitems}

\index{conv\_n\_p() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.conv_n_p}\pysiglinewithargsret{\bfcode{conv\_n\_p}}{}{}
realises the n+p to SH conversion

\end{fulllineitems}

\index{copy() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.copy}\pysiglinewithargsret{\bfcode{copy}}{}{}
return a copy of itself

\end{fulllineitems}

\index{diag() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.diag}\pysiglinewithargsret{\bfcode{diag}}{\emph{direc='F12'}}{}
In 2D, extracts the diagonal of the 2D and put into the 1D buffer.

In 3D, extracts one diagonal plane of the 3D cube, chosen with the direc parameter 
and put it into the 2D buffer
direct values are :

``F12'' is the F1=F2 diagonal
``F23'' is the F2=F3 diagonal
``F13'' is the F1=F3 diagonal

\end{fulllineitems}

\index{dim (NPKData.NPKData attribute)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.dim}\pysigline{\bfcode{dim}}
returns the dimension of data : 1 2 or 3 (for 1D 2D or 3D)

\end{fulllineitems}

\index{display() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.display}\pysiglinewithargsret{\bfcode{display}}{\emph{scale=1.0}, \emph{absmax=0.0}, \emph{show=False}, \emph{label=None}, \emph{new\_fig=True}, \emph{axis=None}, \emph{mode3D=False}, \emph{zoom=None}, \emph{xlabel='\_def\_'}, \emph{ylabel='\_def\_'}, \emph{figure=None}}{}
not so quick and dirty display using matplotlib or mlab - still a first try

scale   allows to increase the vertical scale of display
absmax  overwrite the value for the largest point, which will not be computed
\begin{quote}

display is scaled so that the largest point is first computed (and stored in absmax),
and then the value at absmax/scale is set full screen
\end{quote}
\begin{description}
\item[{show    will call plot.show() at the end, allowing every declared display to be shown on-screen}] \leavevmode
useless in ipython

\end{description}

label   add a label text to plot
xlabel, ylabel : axes label (default is self.units - use None to remove)
axis    used as axis if present, axis length should match experiment length
\begin{quote}

in 2D, should be a pair (xaxis,yaxis)
\end{quote}

new\_fig will create a new window if set to True (default) (active only is figure==None)
mode3D  use malb 3D display instead of matplotlib contour for 2D display
zoom    is a tuple defining the zoom window (left,right) or   ((F1\_limits),(F2\_limits))
figure  if not None, will be used directly to display instead of using its own

can actually be called without harm, even if no graphic is available, it will just do nothing.

\end{fulllineitems}

\index{display\_peaks() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.display_peaks}\pysiglinewithargsret{\bfcode{display\_peaks}}{\emph{axis=None}, \emph{peak\_label=False}, \emph{zoom=None}, \emph{show=False}}{}
displays peaks generated with peak()

\end{fulllineitems}

\index{extract() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.extract}\pysiglinewithargsret{\bfcode{extract}}{\optional{\optional{\emph{x1}, \emph{y1}}}}{}
extract({[}x1, y1{]}, {[}x2, y2{]}) or extract({[}x1, y1, x2, y2{]})
etc...

Permits to extract a portion of the data.
Data can then be processed as a regular data-set.
EXTRACT changes the value of OFFSET and SPECW accordingly.
\begin{itemize}
\item {} 
extract(x1,y1) for 1D datasets.

\item {} 
extract(x1, y1, x2, y2) for 2D datasets.

\end{itemize}

see also : chsize

\end{fulllineitems}

\index{f() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.f}\pysiglinewithargsret{\bfcode{f}}{\emph{x}, \emph{y}}{}
used by 3D display

\end{fulllineitems}

\index{fastclean() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.fastclean}\pysiglinewithargsret{\bfcode{fastclean}}{\emph{nsigma=2.0}, \emph{nbseg=20}, \emph{axis=0}}{}
set to zeros all points below nsigma times the noise level
This allows the corresponding data-set, once stored to file, to be considerably more compressive.
\begin{description}
\item[{nsigma: float}] \leavevmode
the ratio used, typically 1.0 to 3.0 (higher compression)

\item[{nbseg: int}] \leavevmode
the number of segment used for noise evaluation, see util.signal\_tools.findnoiselevel

\item[{axis: int}] \leavevmode
the axis on which the noise is evaluated, default is fastest varying dimension

\end{description}

\end{fulllineitems}

\index{fft() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.fft}\pysiglinewithargsret{\bfcode{fft}}{\emph{axis=0}}{}
computes the complex Fourier transform,

takes complex time domain data and returns complex frequency domain data

see test\_axis for information on axis

\end{fulllineitems}

\index{fftr() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.fftr}\pysiglinewithargsret{\bfcode{fftr}}{\emph{axis=0}}{}
computes the alternate Fourier transform,

takes complex time domain data and returns real frequency domain data

see test\_axis for information on axis

\end{fulllineitems}

\index{flip() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.flip}\pysiglinewithargsret{\bfcode{flip}}{}{}
on a 2D with axis2.itype==1 and axis1.itype==0
copies the imaginary from on axis to the other
after this, we have
\begin{quote}

axis2.itype==0 and axis1.itype==1
size1 is doubled
size2 is halved
\end{quote}

Useful for complex FT
this is the opposite of flop()

\textgreater{}\textgreater{}\textgreater{}bb=NPKData(buffer=array({[}{[}  0.,   1.,   2.,   3.{]},{[}  4.,   5.,   6.,   7.{]},{[}  8.,   9.,  10.,  11.{]},{[} 12.,  13.,  14.,  15.{]}{]}))
\textgreater{}\textgreater{}\textgreater{}print bb.buffer
array({[}{[}  0.,   1.,   2.,   3.{]},
\begin{quote}

{[}  4.,   5.,   6.,   7.{]},
{[}  8.,   9.,  10.,  11.{]},
{[} 12.,  13.,  14.,  15.{]}{]})
\end{quote}

\textgreater{}\textgreater{}\textgreater{}bb.axis2.itype=1
\textgreater{}\textgreater{}\textgreater{}bb.flip()
\textgreater{}\textgreater{}\textgreater{}print bb.buffer
array({[}{[}  0.,   2.{]},
\begin{quote}

{[}  1.,   3.{]},
{[}  4.,   6.{]},
{[}  5.,   7.{]},
{[}  8.,  10.{]},
{[}  9.,  11.{]},
{[} 12.,  14.{]},
{[} 13.,  15.{]}{]})
\end{quote}

\end{fulllineitems}

\index{flipphase() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.flipphase}\pysiglinewithargsret{\bfcode{flipphase}}{\emph{ph0}, \emph{ph1}, \emph{axis=1}}{}
equivalent to   flip(); phase();flop()   but much faster
apply a phase correction along F1 axis of a 2D.
on 2D where axis1.itype = 0   and   axis2.itype = 1
using pairs of columns as real and imaginary pair
phase corrections are in degree

\end{fulllineitems}

\index{flop() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.flop}\pysiglinewithargsret{\bfcode{flop}}{}{}
on a 2D with axis2.itype==0 and axis1.itype==1
copies the imaginary from on axis to the other
after this, we have
\begin{quote}

axis2.itype==1 and axis1.itype==0
size1 is halved
size2 is doubled
\end{quote}

Useful for complex FT
this is the opposite of flip()

\end{fulllineitems}

\index{get\_buffer() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.get_buffer}\pysiglinewithargsret{\bfcode{get\_buffer}}{\emph{copy=False}}{}
returns a view or a copy of the numpy buffer containing the NPKData values
dtype is either real or complex if axis is complex.
remarks :
\begin{itemize}
\item {} 
default is a view, if you want a copy, simply do d.get\_buffer(copy=True)

\item {} 
if you use a view, do not modify the size, nor the dtype

\item {} 
see set\_buffer()

\end{itemize}

WARNING
- In nD with n\textgreater{}1 and if NPKData is hypercomplex, only the fastest (n) axis is considered, all other imaginary parts are left as real.

\end{fulllineitems}

\index{ifft() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.ifft}\pysiglinewithargsret{\bfcode{ifft}}{\emph{axis=0}}{}
computes the inverse of fft(),
takes complex frequency domain data and returns complex time domain data

see test\_axis for information on axis

\end{fulllineitems}

\index{ifftr() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.ifftr}\pysiglinewithargsret{\bfcode{ifftr}}{\emph{axis=0}}{}
computes the inverse of fftr,
takes real frequency domain data and returns complex time domain data

see test\_axis for information on axis

\end{fulllineitems}

\index{irfft() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.irfft}\pysiglinewithargsret{\bfcode{irfft}}{\emph{axis=0}}{}
computes the inverse of rfft(),
takes complex frequency domain data and returns real time domain data

see test\_axis for information on axis

\end{fulllineitems}

\index{itype (NPKData.NPKData attribute)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.itype}\pysigline{\bfcode{itype}}
returns complex type of each axes coded as single number, using NPKv1 code

\end{fulllineitems}

\index{linear\_interpolate() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.linear_interpolate}\pysiglinewithargsret{\bfcode{linear\_interpolate}}{\emph{xpoints}, \emph{axis='F2'}}{}
``compute and applies a linear function as a baseline correction

\end{fulllineitems}

\index{load() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.load}\pysiglinewithargsret{\bfcode{load}}{\emph{name}}{}
load data from a file

\end{fulllineitems}

\index{load\_txt() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.load_txt}\pysiglinewithargsret{\bfcode{load\_txt}}{\emph{name}}{}
load 1D data in texte, single column, no unit - with attributes as pseudo comments

\end{fulllineitems}

\index{mean() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.mean}\pysiglinewithargsret{\bfcode{mean}}{\emph{zone}}{}
computes mean value  in the designed spectral zone
Consider array as real even if itype is 1

\end{fulllineitems}

\index{median() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.median}\pysiglinewithargsret{\bfcode{median}}{}{}
Executes a median filter on the data-set (1D or 2D).a window of x 
points (or y by x in 2D) is moved along the data set, the point are 
ordered, and the indexth point is taken as the new point for the 
data set.

\end{fulllineitems}

\index{minus() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.minus}\pysiglinewithargsret{\bfcode{minus}}{}{}
Sets to zero the positive part of the data set
see also :  minus, zeroing

\end{fulllineitems}

\index{modulus() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.modulus}\pysiglinewithargsret{\bfcode{modulus}}{}{}
takes the modulus of the dataset
depends on the value f axis(i).itype

\end{fulllineitems}

\index{mult() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.mult}\pysiglinewithargsret{\bfcode{mult}}{\emph{multiplier}}{}
Multiply data-set by a scalar
eg : d.mult(alpha) multiplies d buffer by alpha

\end{fulllineitems}

\index{mult\_by\_vector() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.mult_by_vector}\pysiglinewithargsret{\bfcode{mult\_by\_vector}}{\emph{axis}, \emph{vector}, \emph{mode='real'}}{}
multiply the data-set by a vector, along a given axis
if mode == ``real'', does it point by point regardles of itype
if mode == ``complex'' uses axis.itype to determine how handle complex values
\begin{quote}

in all cases vector can be real or complex
\end{quote}

\end{fulllineitems}

\index{peak() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.peak}\pysiglinewithargsret{\bfcode{peak}}{\emph{pos\_neg=1}, \emph{threshold=0.1}, \emph{offset=None}}{}
first trial for peakpicker
1D only
pos\_neg = 1 / -1 / 0   :  type of peaks positive / negative / 
threshold = minimum level, as absolute value
self.peaks : index of the peaks
self.peaks\_ordered : index of the ordered peaks from maximum to minimum.

\end{fulllineitems}

\index{peaks2d() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.peaks2d}\pysiglinewithargsret{\bfcode{peaks2d}}{\emph{threshold=0.1}, \emph{zoom=None}, \emph{value=False}}{}
Extract peaks from 2d Array dataset
if value is True, return the magnitude at position (x,y)

\end{fulllineitems}

\index{phase() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.phase}\pysiglinewithargsret{\bfcode{phase}}{\emph{ph0}, \emph{ph1}, \emph{axis=0}}{}
apply a phase correction along given axis
phase corrections are in degree

\end{fulllineitems}

\index{plane() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.plane}\pysiglinewithargsret{\bfcode{plane}}{\emph{axis}, \emph{i}}{}
returns a 2D extracted from the current 3D at position 0\textless{}=i\textless{}=size1-1

\end{fulllineitems}

\index{plus() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.plus}\pysiglinewithargsret{\bfcode{plus}}{}{}
Sets to zero the negative part of the data set
see also :  minus, zeroing

\end{fulllineitems}

\index{proj() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.proj}\pysiglinewithargsret{\bfcode{proj}}{\emph{axis=0}, \emph{projtype='s'}}{}
returns a projection of the dataset on the given axis
projtype determines the algorithm :
\begin{quote}

``s'' is for skyline projection (the highest point is retained)
``m'' is for mean,
\end{quote}

\end{fulllineitems}

\index{real() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.real}\pysiglinewithargsret{\bfcode{real}}{\emph{axis=0}}{}
This command extract the real part of the current the data set 
considered as complex.
\textless{}ul\textgreater{}
\textless{}li\textgreater{}axis is not needed in 1D, 
\textless{}li\textgreater{}can be F1, F2 or F12 in 2D,
\textless{}li\textgreater{}and can be F1, F2, F3, F12, F13, F23, or F123 in 3D.
\textless{}/ul\textgreater{}

\end{fulllineitems}

\index{recital() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.recital}\pysiglinewithargsret{\bfcode{recital}}{\emph{finalsize}, \emph{iterations=2}, \emph{miniteration=100}, \emph{noise=None}, \emph{scale\_noise=1.0}, \emph{mfista=False}, \emph{axis=0}}{}
Apply the recital resolution enhancement algorithm to the data held in buffer
final size of produced spectrum is finalsized
noise iteration (outer loop) and iterations (inner loop) can be used to force default values

time is proportionnal to iterations x miniteration
stands for Resolution EnhanCement by ITerative ALgorithm.
\begin{description}
\item[{input:}] \leavevmode
finalsize : targeted size.
iterations : maximal number of lambda modifications.
miniteration : maximal number of iterations for each lambda value.
noise : noise level measured outside the algorithm for performing the Soft Thresholding
scale\_noise : : scaling of the noise level measured in Recital itself.

\end{description}

\end{fulllineitems}

\index{report() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.report}\pysiglinewithargsret{\bfcode{report}}{}{}
reports itself

\end{fulllineitems}

\index{reverse() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.reverse}\pysiglinewithargsret{\bfcode{reverse}}{\emph{axis=0}}{}
reverse the order of the current data-set (i.e. first points are 
last, last points are first).
If dataset is complex, REVERSE will reverse the complex  vector (2  by 2).

\end{fulllineitems}

\index{revf() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.revf}\pysiglinewithargsret{\bfcode{revf}}{\emph{axis=0}}{}
Processes FID data-sets by multiplying by -1 2 points out of 4. 
Permits to preprocess Bruker FIDs in Dim 2 (Bruker trick) before 
RFT, or permits to bring back zero frequency in the center for some 
other data formats

\end{fulllineitems}

\index{rfft() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.rfft}\pysiglinewithargsret{\bfcode{rfft}}{\emph{axis=0}}{}
computes the real Fourier transform,
takes real time domain data and returns complex frequency domain data

see test\_axis for information on axis

\end{fulllineitems}

\index{row() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.row}\pysiglinewithargsret{\bfcode{row}}{\emph{i}}{}
returns a 1D extracted from the current 2D at position 0\textless{}=i\textless{}=size1-1

\end{fulllineitems}

\index{save() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.save}\pysiglinewithargsret{\bfcode{save}}{\emph{name}}{}
save data to a file

\end{fulllineitems}

\index{save\_csv() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.save_csv}\pysiglinewithargsret{\bfcode{save\_csv}}{\emph{name}}{}
save 1D data in csv,
in 2 columns : 
x, y   x values are conditions by the .units attribute
data attributes are stored as pseudo comments

data can be read back with File.csv.Import\_1D()

\end{fulllineitems}

\index{save\_txt() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.save_txt}\pysiglinewithargsret{\bfcode{save\_txt}}{\emph{name}}{}
save 1D data in texte, single column, no unit - with attributes as pseudo comments

\end{fulllineitems}

\index{set\_buffer() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.set_buffer}\pysiglinewithargsret{\bfcode{set\_buffer}}{\emph{buff}}{}
modify the internal buffer of the NPKData.
allows real or complex arrays to be used
remarks
\begin{itemize}
\item {} 
see get\_buffer()

\end{itemize}

\end{fulllineitems}

\index{set\_col() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.set_col}\pysiglinewithargsret{\bfcode{set\_col}}{\emph{i}, \emph{d1D}}{}
set into the current 2D the given 1D, as the column at position 0\textless{}=i\textless{}=size2-1

\end{fulllineitems}

\index{set\_row() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.set_row}\pysiglinewithargsret{\bfcode{set\_row}}{\emph{i}, \emph{d1D}}{}
set into the current 2D the given 1D, as the row at position 0\textless{}=i\textless{}=size1-1

\end{fulllineitems}

\index{sg() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.sg}\pysiglinewithargsret{\bfcode{sg}}{\emph{window\_size}, \emph{order}, \emph{deriv=0}, \emph{axis=0}}{}
applies saviski-golay of order filter to data
window\_size : int
\begin{quote}

the length of the window. Must be an odd integer number.
\end{quote}
\begin{description}
\item[{order}] \leavevmode{[}int{]}
the order of the polynomial used in the filtering.
Must be less than \emph{window\_size} - 1.

\item[{deriv: int}] \leavevmode
the order of the derivative to compute (default = 0 means only smoothing)

\item[{axis: int}] \leavevmode
the axis on which the filter is to be applied, default is fastest varying dimension

\end{description}

\end{fulllineitems}

\index{sg2D() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.sg2D}\pysiglinewithargsret{\bfcode{sg2D}}{\emph{window\_size}, \emph{order}, \emph{deriv=None}}{}
applies a 2D saviski-golay of order filter to data
window\_size : int
\begin{quote}

the length of the square window. Must be an odd integer number.
\end{quote}
\begin{description}
\item[{order}] \leavevmode{[}int{]}
the order of the polynomial used in the filtering.
Must be less than \emph{window\_size} - 1.

\item[{deriv: None, `col', or `row'.   `both' mode does not work.}] \leavevmode
the direction of the derivative to compute (default = None means only smoothing)

\end{description}

can be applied to a 2D only.

\end{fulllineitems}

\index{size1 (NPKData.NPKData attribute)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.size1}\pysigline{\bfcode{size1}}
returns the size of the F1 spectral axis in 1D 2D and 3D
i.e. the unique axis in 1D, the slowest axis in 2D and 3D
warning, if data along axis is complex, the size is twice the number of complex pairs

\end{fulllineitems}

\index{size2 (NPKData.NPKData attribute)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.size2}\pysigline{\bfcode{size2}}
returns the size of the F2 spectral axis in 2D and 3D
i.e. the slowest axis in 2D and the intermediate in 3D
warning, if data along axis is complex, the size is twice the number of complex pairs

\end{fulllineitems}

\index{size3 (NPKData.NPKData attribute)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.size3}\pysigline{\bfcode{size3}}
returns the size of the F3 spectral axis in 3D
i.e. the slowest axis in 3D
warning, if data along axis is complex, the size is twice the number of complex pairs

\end{fulllineitems}

\index{spline\_interpolate() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.spline_interpolate}\pysiglinewithargsret{\bfcode{spline\_interpolate}}{\emph{xpoints}, \emph{axis='F2'}, \emph{kind=3}}{}
compute and applies a spline function as a baseline correction

\end{fulllineitems}

\index{std() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.std}\pysiglinewithargsret{\bfcode{std}}{\emph{zone}}{}
computes standard deviation in the designed spectral zone
Computes value on the real part only ** CHANGED ON July 2012 **

\end{fulllineitems}

\index{swap() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.swap}\pysiglinewithargsret{\bfcode{swap}}{\emph{axis=0}}{}
swap both parth to complex
this is the opposite of swa()
\textgreater{}\textgreater{}\textgreater{}aa=NPKData(buffer=arange(8.))
\textgreater{}\textgreater{}\textgreater{}aa.axis1.itype=1
\textgreater{}\textgreater{}\textgreater{}print aa.buffer
array({[} 0.,  1.,  2.,  3.,  4.,  5.,  6.,  7.{]})
\textgreater{}\textgreater{}\textgreater{}print aa.swa().buffer
array({[} 0.,  4.,  1.,  5.,  2.,  6.,  3.,  7.{]})

\end{fulllineitems}

\index{test\_axis() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.test_axis}\pysiglinewithargsret{\bfcode{test\_axis}}{\emph{axis=0}}{}
tests on axis
\begin{quote}
\begin{description}
\item[{in 1D,  axis is not used}] \leavevmode
axis has to be 1 or ``F1''

\item[{in 2D,  axis is either 2 for horizontal / faster incremented dimension  == ``F2''}] \leavevmode
or 1 for the other dimension == ``F1''
defaut is 2

\item[{in 3D, axis is 3, 2 or 1 with 3 the faster incremented and 1 the slower == F3 F2 F1}] \leavevmode
defaut is 3

\end{description}

alternativaly, you may use the strings ``F1'', ``F2'' or ``F3''
BUT not F12 F23 as 
0 is rest to default
\end{quote}

\end{fulllineitems}

\index{transpose() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.transpose}\pysiglinewithargsret{\bfcode{transpose}}{\emph{axis=0}}{}
Transposes the 2D matrix or planes of the 3D cube. The sizes of 
the matrix must be a power of two for this command to be used. After 
transposition, the two dimensions are completely permuted

axis is used in 3D to tell which submatrices should be transposed

see also : sym chsize modifysize

\end{fulllineitems}

\index{units (NPKData.NPKData attribute)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.units}\pysigline{\bfcode{units}}
copy units to all the axes

\end{fulllineitems}

\index{unswap() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.unswap}\pysiglinewithargsret{\bfcode{unswap}}{\emph{axis=0}}{}
this is the opposite of swap()
\textgreater{}\textgreater{}\textgreater{}aa=NPKData(buffer=arange(8.))
\textgreater{}\textgreater{}\textgreater{}aa.axis1.itype=1
\textgreater{}\textgreater{}\textgreater{}print aa.buffer
array({[} 0.,  1.,  2.,  3.,  4.,  5.,  6.,  7.{]})
\textgreater{}\textgreater{}\textgreater{}print aa.unswa().buffer
array({[} 0.,  2.,  4.,  6.,  1.,  3.,  5.,  7.{]})

\end{fulllineitems}

\index{urqrd() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.urqrd}\pysiglinewithargsret{\bfcode{urqrd}}{\emph{k}, \emph{orda=None}, \emph{iterations=1}, \emph{axis=0}}{}
Apply urQRd denoising to data
k is about 2 x number\_of\_expected\_lines
Manages real and complex cases.
Handles the case of hypercomplex for denoising of 2D FTICR for example.

\end{fulllineitems}

\index{xcol() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.xcol}\pysiglinewithargsret{\bfcode{xcol}}{\emph{start=0}, \emph{stop=None}, \emph{step=1}}{}
an iterator over columns of a 2D
so 
for c in matrix.xcol():
\begin{quote}

do something with c...
\end{quote}

is equivalent to
for i in range(matrix.size2):     \# i.e. all cols
\begin{quote}

c = matrix.col(i)
do something with c...
\end{quote}

you can limit the range by giving start, stop and step arguments - using the same syntax as xrange()

on hypercomplex data
matrix.xcol( step=matrix.axis2.itype+1 )
will step only on cols associated to the real point

\end{fulllineitems}

\index{xrow() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.xrow}\pysiglinewithargsret{\bfcode{xrow}}{\emph{start=0}, \emph{stop=None}, \emph{step=1}}{}
an iterator over rows of a 2D
so 
for r in matrix.xrow():
\begin{quote}

do something with r...
\end{quote}

is equivalent to
for i in range(matrix.size1):     \# i.e. all rows
\begin{quote}

r = matrix.row(i)
do something with r...
\end{quote}

you can limit the range by giving start, stop and step arguments - using the same syntax as xrange()

on hypercomplex data
matrix.xrow( step=matrix.axis1.itype+1 )
will step only on rows associated to the real point

\end{fulllineitems}

\index{zeroing() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.zeroing}\pysiglinewithargsret{\bfcode{zeroing}}{\emph{threshold}}{}
Sets to zero points below threshold (in absolute value)
see also :  plus, minus

\end{fulllineitems}

\index{zf() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.zf}\pysiglinewithargsret{\bfcode{zf}}{\emph{zf1=None}, \emph{zf2=None}, \emph{zf3=None}}{}
Zerofill data by adding zeros.
for a dataset of length size, will add zeros up to zf*size

do nothing by default unless axis is sampled,
in which case, missing unsampled points are replaced by 0.0

\end{fulllineitems}

\index{zoom() (NPKData.NPKData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKData.zoom}\pysiglinewithargsret{\bfcode{zoom}}{\emph{dim}, \emph{*args}}{}
The basic command for defining region of interest window
\begin{itemize}
\item {} 
if n=0, zoom mode is off.

\item {} 
if n=1, zoom mode is on,

\end{itemize}

\end{fulllineitems}


\end{fulllineitems}

\index{NPKDataTests (class in NPKData)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKDataTests}\pysiglinewithargsret{\strong{class }\code{NPKData.}\bfcode{NPKDataTests}}{\emph{methodName='runTest'}}{}~\begin{itemize}
\item {} 
Testing NPKData basic behaviour -

\end{itemize}
\index{test\_NUS\_sampling() (NPKData.NPKDataTests method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKDataTests.test_NUS_sampling}\pysiglinewithargsret{\bfcode{test\_NUS\_sampling}}{}{}
NUS example
removing the sampling noise

\end{fulllineitems}

\index{test\_dampingunit() (NPKData.NPKDataTests method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKDataTests.test_dampingunit}\pysiglinewithargsret{\bfcode{test\_dampingunit}}{}{}
test itod and dtoi

\end{fulllineitems}

\index{test\_fft() (NPKData.NPKDataTests method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKDataTests.test_fft}\pysiglinewithargsret{\bfcode{test\_fft}}{}{}~\begin{itemize}
\item {} 
Testing FFT methods -

\end{itemize}

\end{fulllineitems}

\index{test\_flatten() (NPKData.NPKDataTests method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKDataTests.test_flatten}\pysiglinewithargsret{\bfcode{test\_flatten}}{}{}
test the flatten utility

\end{fulllineitems}

\index{test\_hypercomplex\_modulus() (NPKData.NPKDataTests method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKDataTests.test_hypercomplex_modulus}\pysiglinewithargsret{\bfcode{test\_hypercomplex\_modulus}}{}{}
Test of hypercomplex modulus

\end{fulllineitems}

\index{test\_load() (NPKData.NPKDataTests method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKDataTests.test_load}\pysiglinewithargsret{\bfcode{test\_load}}{}{}~\begin{itemize}
\item {} 
Testing load methods

\end{itemize}

\end{fulllineitems}

\index{test\_math() (NPKData.NPKDataTests method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKDataTests.test_math}\pysiglinewithargsret{\bfcode{test\_math}}{}{}~\begin{itemize}
\item {} 
Testing math methods -

\end{itemize}

\end{fulllineitems}

\index{test\_peaks1d() (NPKData.NPKDataTests method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKDataTests.test_peaks1d}\pysiglinewithargsret{\bfcode{test\_peaks1d}}{}{}
test 1D peak picker

\end{fulllineitems}

\index{test\_peaks2d() (NPKData.NPKDataTests method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKDataTests.test_peaks2d}\pysiglinewithargsret{\bfcode{test\_peaks2d}}{}{}
test 2D peak picker

\end{fulllineitems}

\index{test\_recital\_synthetic() (NPKData.NPKDataTests method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKDataTests.test_recital_synthetic}\pysiglinewithargsret{\bfcode{test\_recital\_synthetic}}{}{}
Test recital on synthetic dataset.

\end{fulllineitems}

\index{test\_superresolution() (NPKData.NPKDataTests method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.NPKDataTests.test_superresolution}\pysiglinewithargsret{\bfcode{test\_superresolution}}{}{}
NUS example
removing the sampling noise white\_noise.jpg

\end{fulllineitems}


\end{fulllineitems}

\index{as\_cpx() (in module NPKData)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.as_cpx}\pysiglinewithargsret{\code{NPKData.}\bfcode{as\_cpx}}{\emph{arr}}{}
interpret arr as a complex array
useful to move between complex and real arrays (see as\_float)

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{as\PYGZus{}cpx}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mf}{4.0}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{[ 0.+1.j  2.+3.j]}
\end{Verbatim}

\end{fulllineitems}

\index{as\_float() (in module NPKData)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.as_float}\pysiglinewithargsret{\code{NPKData.}\bfcode{as\_float}}{\emph{arr}}{}
interpret arr as a float array
useful to move between complex and real arrays (see as\_float)

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{as\PYGZus{}float}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{l+m+mi}{1j}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{[ 0.  0.  1.  1.  2.  2.  3.  3.]}
\end{Verbatim}

\end{fulllineitems}

\index{conj\_ip() (in module NPKData)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.conj_ip}\pysiglinewithargsret{\code{NPKData.}\bfcode{conj\_ip}}{\emph{a}}{}
computes conjugate() in-place

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{conj\PYGZus{}ip}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{l+m+mi}{1j}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{[ 0.\PYGZhy{}0.j  1.\PYGZhy{}1.j  2.\PYGZhy{}2.j  3.\PYGZhy{}3.j]}
\end{Verbatim}

\end{fulllineitems}

\index{copyaxes() (in module NPKData)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.copyaxes}\pysiglinewithargsret{\code{NPKData.}\bfcode{copyaxes}}{\emph{inp}, \emph{out}}{}
copy axes values from NPKDAta in to out.

internal use

\end{fulllineitems}

\index{flatten() (in module NPKData)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.flatten}\pysiglinewithargsret{\code{NPKData.}\bfcode{flatten}}{\emph{*arg}}{}
flatten recursively a list of lists

\textgreater{}\textgreater{}\textgreater{}print flatten( ( (1,2), 3, (4, (5,), (6,7) ) ) )
{[}1, 2, 3, 4, 5, 6, 7{]}

\end{fulllineitems}

\index{hypercomplex\_modulus() (in module NPKData)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.hypercomplex_modulus}\pysiglinewithargsret{\code{NPKData.}\bfcode{hypercomplex\_modulus}}{\emph{arr}, \emph{size1}, \emph{size2}}{}
Calculates the modulus of an array of hypercomplex numbers.
input:
\begin{quote}

arr : hypercomplex array
size1 : size counting horizontally each half quadrant.
size2 : siez counting vertically each half quadrant.
\end{quote}
\begin{description}
\item[{eg:}] \leavevmode
arr = np.array({[}{[}1, 4{]},{[}3, 7{]},{[}1, 9{]},{[}5, 7{]}{]})
is an hypercomplex with size1 = 2 and size2 = 2

\end{description}

\end{fulllineitems}

\index{warning() (in module NPKData)}

\begin{fulllineitems}
\phantomsection\label{rst/code:NPKData.warning}\pysiglinewithargsret{\code{NPKData.}\bfcode{warning}}{\emph{msg}}{}
issue a warning message to the user

\end{fulllineitems}



\section{File formats}
\label{rst/code:file-formats}

\subsection{Apex}
\label{rst/code:apex}\label{rst/code:module-File.Apex}\index{File.Apex (module)}
Utility to Handle Apex files
\index{Import\_1D() (in module File.Apex)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.Apex.Import_1D}\pysiglinewithargsret{\code{File.Apex.}\bfcode{Import\_1D}}{\emph{folder}, \emph{outfile='`}}{}
Entry point to import 1D spectra
It returns a FTICRData
It writes a HDF5 file if an outfile is mentionned

\end{fulllineitems}

\index{Import\_2D() (in module File.Apex)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.Apex.Import_2D}\pysiglinewithargsret{\code{File.Apex.}\bfcode{Import\_2D}}{\emph{folder}, \emph{outfile='`}, \emph{F1specwidth=None}}{}
Entry point to import 2D spectra
It returns a FTICRData
It writes a HDF5 file if an outfile is mentionned

\end{fulllineitems}

\index{Ser2D\_to\_H5f() (in module File.Apex)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.Apex.Ser2D_to_H5f}\pysiglinewithargsret{\code{File.Apex.}\bfcode{Ser2D\_to\_H5f}}{\emph{sizeF1}, \emph{sizeF2}, \emph{filename='ser'}, \emph{outfile='H5f.h5'}, \emph{chunks=None}}{}
Charge any ser file directly in H5f file

\end{fulllineitems}

\index{get\_param() (in module File.Apex)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.Apex.get_param}\pysiglinewithargsret{\code{File.Apex.}\bfcode{get\_param}}{\emph{param}, \emph{names}, \emph{values}}{}
From params, this function returns the  value of the given param

\end{fulllineitems}

\index{locate\_acquisition() (in module File.Apex)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.Apex.locate_acquisition}\pysiglinewithargsret{\code{File.Apex.}\bfcode{locate\_acquisition}}{\emph{folder}}{}
From the given folder this function return the absolute path to the apexAcquisition.method file
It should always be in a subfolder

\end{fulllineitems}

\index{read\_2D() (in module File.Apex)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.Apex.read_2D}\pysiglinewithargsret{\code{File.Apex.}\bfcode{read\_2D}}{\emph{sizeF1}, \emph{sizeF2}, \emph{filename='ser'}}{}
Reads in a Apex 2D fid

sizeF1 is the number of fid
sizeF2 is the number of data-points in the fid
uses array

\end{fulllineitems}

\index{read\_3D() (in module File.Apex)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.Apex.read_3D}\pysiglinewithargsret{\code{File.Apex.}\bfcode{read\_3D}}{\emph{sizeF1}, \emph{sizeF2}, \emph{sizeF3}, \emph{filename='ser'}}{}
Ebauche de fonction

Reads in a Apex 3D fid

uses array

\end{fulllineitems}

\index{read\_param() (in module File.Apex)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.Apex.read_param}\pysiglinewithargsret{\code{File.Apex.}\bfcode{read\_param}}{\emph{filename}}{}
Open the given file and retrieve all parameters written initially for apexAcquisition.method
NC is written when no value for value is found

structure : \textless{}param\textgreater{}\textless{}name\textgreater{}C\_MsmsE\textless{}/name\textgreater{}\textless{}value\textgreater{}0.0\textless{}/value\textgreater{}\textless{}/param\textgreater{}

read\_param returns  values in a dictionnary

\end{fulllineitems}

\index{read\_scan() (in module File.Apex)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.Apex.read_scan}\pysiglinewithargsret{\code{File.Apex.}\bfcode{read\_scan}}{\emph{filename}}{}
Function that returns the number of scan that have been recorded
It is used to see wether the number of recorded points correspond to the L\_20 parameter

\end{fulllineitems}

\index{write\_ser() (in module File.Apex)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.Apex.write_ser}\pysiglinewithargsret{\code{File.Apex.}\bfcode{write\_ser}}{\emph{bufferdata}, \emph{filename='ser'}}{}
Write a ser file from FTICRData

\end{fulllineitems}

\phantomsection\label{rst/code:module-File.csv}\index{File.csv (module)}
Utility to import and export data in text and csv files

all functions compress transparently if the filenales end with .gz
Marc-André adapted from some Lionel code
\index{Import\_1D() (in module File.csv)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.csv.Import_1D}\pysiglinewithargsret{\code{File.csv.}\bfcode{Import\_1D}}{\emph{filename}, \emph{column=0}, \emph{delimiter='}, \emph{`}}{}
import a 1D file stored as csv
header as comments (\#)
parameters in pseudocomments :
\begin{quote}

\#\$key value
\end{quote}

then one value per line
column and delimiter  as in load()

\end{fulllineitems}

\index{NPKDataTests (class in File.csv)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.csv.NPKDataTests}\pysiglinewithargsret{\strong{class }\code{File.csv.}\bfcode{NPKDataTests}}{\emph{methodName='runTest'}}{}~\begin{itemize}
\item {} 
Testing NPKData basic behaviour -

\end{itemize}

\end{fulllineitems}

\index{load() (in module File.csv)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.csv.load}\pysiglinewithargsret{\code{File.csv.}\bfcode{load}}{\emph{filename}, \emph{column=0}, \emph{delimiter='}, \emph{`}}{}
load 1D data from txt or csv file,
attribute are in pseuo-coments startin with \#\$
value are in columns, separated by delimiter - only the columun given in arg will be loaded
column = 0 is fine for text files
column = 1 is fine for csv files with units
returns a numpy buffer and an attribute dictionary

\end{fulllineitems}

\index{save() (in module File.csv)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.csv.save}\pysiglinewithargsret{\code{File.csv.}\bfcode{save}}{\emph{data}, \emph{filename}, \emph{delimiter='}, \emph{`}}{}
save 1D data in txt, single column, no unit - with attributes as pseudo comments

\end{fulllineitems}

\index{save\_unit() (in module File.csv)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.csv.save_unit}\pysiglinewithargsret{\code{File.csv.}\bfcode{save\_unit}}{\emph{data}, \emph{filename}, \emph{delimiter='}, \emph{`}}{}
save 1D data in csv,
in 2 columns, with attributes as pseudo comments

\end{fulllineitems}



\subsection{GifaFile}
\label{rst/code:gifafile}\label{rst/code:module-File.GifaFile}\index{File.GifaFile (module)}
GifaFile.py

Created by Marc-André on 2010-03-17.
Copyright (c) 2010 IGBMC. All rights reserved.

This module provides a simple access to NMR files in the Gifa format.
\index{GifaFile (class in File.GifaFile)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.GifaFile.GifaFile}\pysiglinewithargsret{\strong{class }\code{File.GifaFile.}\bfcode{GifaFile}}{\emph{fname}, \emph{access='r'}, \emph{debug=0}}{}
defines the interface to simply (read/write) acces Gifa v4 files
standard methods are load() and save()

standard sequence to read is
F = GifaFile(filename,''r'')
B = F.get\_data()      \# B is a NPKdata
F.close()

or
F = GifaFile(filename,''r'')
F.load()
B = F.data      \# B is a NPKdata
F.close()

and to write
F = GifaFile(filename,''w'')
F.set\_data(B)         \# where B is a NPKdata; do not use    F.data = B
F.save()
F.close()

The file consists of a header (of size headersize) and data
The header is handled as a dictionnary  self.header
data is handled as a NPKdata    self.data
\begin{quote}

so numpy ndarray are in                self.data.buffer
\end{quote}
\index{byte\_order (File.GifaFile.GifaFile attribute)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.GifaFile.GifaFile.byte_order}\pysigline{\bfcode{byte\_order}}
pour intel

\end{fulllineitems}

\index{close() (File.GifaFile.GifaFile method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.GifaFile.GifaFile.close}\pysiglinewithargsret{\bfcode{close}}{}{}
closes the associated file

\end{fulllineitems}

\index{copyaxesfromheader() (File.GifaFile.GifaFile method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.GifaFile.GifaFile.copyaxesfromheader}\pysiglinewithargsret{\bfcode{copyaxesfromheader}}{\emph{n\_axis}}{}
get values from axis ``n\_axis'' from header, and creates and returns a new (NMRAxis) axis with this values
itype is not handled (not coded per axis in header)
used internally

\end{fulllineitems}

\index{copydiffaxesfromheader() (File.GifaFile.GifaFile method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.GifaFile.GifaFile.copydiffaxesfromheader}\pysiglinewithargsret{\bfcode{copydiffaxesfromheader}}{}{}
get values from axis ``n'' from header, and creates and returns a new (LaplaceAxis) axis with this values
used internally

\end{fulllineitems}

\index{dim (File.GifaFile.GifaFile attribute)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.GifaFile.GifaFile.dim}\pysigline{\bfcode{dim}}
dimensionality of the dataset 1 2 or 3

\end{fulllineitems}

\index{get\_data() (File.GifaFile.GifaFile method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.GifaFile.GifaFile.get_data}\pysiglinewithargsret{\bfcode{get\_data}}{}{}
returns the NPKdata attached to the (read) file

\end{fulllineitems}

\index{itype (File.GifaFile.GifaFile attribute)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.GifaFile.GifaFile.itype}\pysigline{\bfcode{itype}}
Real/complex type of the dataset
in 1D :     0 : real  1: complex
in 2D :     0 : real on both;
\begin{quote}

1 : complex on F2
2 : complex on F1
3 : complex on both
\end{quote}
\begin{description}
\item[{in 3D}] \leavevmode{[}0{]}{[}real on all; {]}
1 : complex on F3
2 : complex on F2
3 : complex on F3-F2
4 : complex on F1
5 : complex on F1-F3
6 : complex on F1-F2
7 : complex on all

\end{description}

\end{fulllineitems}

\index{load() (File.GifaFile.GifaFile method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.GifaFile.GifaFile.load}\pysiglinewithargsret{\bfcode{load}}{}{}
creates a NPKdata loaded with the file content

\end{fulllineitems}

\index{load\_header() (File.GifaFile.GifaFile method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.GifaFile.GifaFile.load_header}\pysiglinewithargsret{\bfcode{load\_header}}{}{}
load the header from file and set-up every thing

\end{fulllineitems}

\index{nblock1 (File.GifaFile.GifaFile attribute)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.GifaFile.GifaFile.nblock1}\pysigline{\bfcode{nblock1}}
number of data block on disk along F1 axis

\end{fulllineitems}

\index{nblock2 (File.GifaFile.GifaFile attribute)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.GifaFile.GifaFile.nblock2}\pysigline{\bfcode{nblock2}}
number of data block on disk along F2 axis

\end{fulllineitems}

\index{nblock3 (File.GifaFile.GifaFile attribute)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.GifaFile.GifaFile.nblock3}\pysigline{\bfcode{nblock3}}
number of data block on disk along F3 axis

\end{fulllineitems}

\index{read\_header() (File.GifaFile.GifaFile method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.GifaFile.GifaFile.read_header}\pysiglinewithargsret{\bfcode{read\_header}}{}{}
return a dictionnary of the file header
internal use

\end{fulllineitems}

\index{readc() (File.GifaFile.GifaFile method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.GifaFile.GifaFile.readc}\pysiglinewithargsret{\bfcode{readc}}{}{}
read a file in Gifa format, and returns the binary buffer as a numpy array
internal use - use load()

\end{fulllineitems}

\index{report() (File.GifaFile.GifaFile method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.GifaFile.GifaFile.report}\pysiglinewithargsret{\bfcode{report}}{}{}
prints a little debugging report

\end{fulllineitems}

\index{save() (File.GifaFile.GifaFile method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.GifaFile.GifaFile.save}\pysiglinewithargsret{\bfcode{save}}{}{}
save the NPKdata to the file

\end{fulllineitems}

\index{set\_data() (File.GifaFile.GifaFile method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.GifaFile.GifaFile.set_data}\pysiglinewithargsret{\bfcode{set\_data}}{\emph{buff}}{}
sets the NPKdata attached to the (to be written) file

\end{fulllineitems}

\index{setup\_header() (File.GifaFile.GifaFile method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.GifaFile.GifaFile.setup_header}\pysiglinewithargsret{\bfcode{setup\_header}}{}{}
setup file header, from self.data

\end{fulllineitems}

\index{size1 (File.GifaFile.GifaFile attribute)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.GifaFile.GifaFile.size1}\pysigline{\bfcode{size1}}
size along the F1 axis (either 1D, or slowest varyong axis in nD)

\end{fulllineitems}

\index{size2 (File.GifaFile.GifaFile attribute)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.GifaFile.GifaFile.size2}\pysigline{\bfcode{size2}}
size along the F2 axis (fastest varying in 2D)

\end{fulllineitems}

\index{size3 (File.GifaFile.GifaFile attribute)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.GifaFile.GifaFile.size3}\pysigline{\bfcode{size3}}
size along the F3 axis (fastest varying in 3D)

\end{fulllineitems}

\index{szblock1 (File.GifaFile.GifaFile attribute)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.GifaFile.GifaFile.szblock1}\pysigline{\bfcode{szblock1}}
size of data block on disk along F1 axis

\end{fulllineitems}

\index{szblock2 (File.GifaFile.GifaFile attribute)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.GifaFile.GifaFile.szblock2}\pysigline{\bfcode{szblock2}}
size of data block on disk along F2 axis

\end{fulllineitems}

\index{szblock3 (File.GifaFile.GifaFile attribute)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.GifaFile.GifaFile.szblock3}\pysigline{\bfcode{szblock3}}
size of data block on disk along F3 axis

\end{fulllineitems}

\index{write\_header() (File.GifaFile.GifaFile method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.GifaFile.GifaFile.write_header}\pysiglinewithargsret{\bfcode{write\_header}}{}{}
write file header
setup\_header() should have been called first

\end{fulllineitems}

\index{write\_header\_line() (File.GifaFile.GifaFile method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.GifaFile.GifaFile.write_header_line}\pysiglinewithargsret{\bfcode{write\_header\_line}}{\emph{key}}{}
write into the header the entry key
returns the number of byte written
internal use

\end{fulllineitems}

\index{writec() (File.GifaFile.GifaFile method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.GifaFile.GifaFile.writec}\pysiglinewithargsret{\bfcode{writec}}{}{}
write a file in Gifa format
internal use - use save()

\end{fulllineitems}


\end{fulllineitems}

\index{GifaFileTests (class in File.GifaFile)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.GifaFile.GifaFileTests}\pysiglinewithargsret{\strong{class }\code{File.GifaFile.}\bfcode{GifaFileTests}}{\emph{methodName='runTest'}}{}~\begin{itemize}
\item {} 
Testing GifaFile on various 1D and 2D files -

\end{itemize}
\index{tempfile (File.GifaFile.GifaFileTests attribute)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.GifaFile.GifaFileTests.tempfile}\pysigline{\bfcode{tempfile}\strong{ = \textless{}module `tempfile' from `/Users/chiron/anaconda/lib/python2.7/tempfile.pyc'\textgreater{}}}
\end{fulllineitems}


\end{fulllineitems}



\subsection{HDF5File}
\label{rst/code:hdf5file}\label{rst/code:module-File.HDF5File}\index{File.HDF5File (module)}
HDF5File.py

Created by Marc-André Delsuc, Marie-Aude Coutouly on 2011-07-13.
Copyright (c) 2011 \_\_NMRTEC\_\_. All rights reserved.

API dealing with HDF5File. For now it is non surclassing tables, you have to use {\color{red}\bfseries{}*}.hf. to access all tables functionalities
\index{HDF5File (class in File.HDF5File)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.HDF5File.HDF5File}\pysiglinewithargsret{\strong{class }\code{File.HDF5File.}\bfcode{HDF5File}}{\emph{fname}, \emph{access='r'}, \emph{info=None}, \emph{nparray=None}, \emph{fticrd=None}, \emph{debug=0}}{}
defines the interface to simply (read/write) access HDF5 files
standard methods are load() and save()

standard sequence to read is
H = HDF5File(filename,''r'')
B = H.get\_data()      \# B is a FTICRdata
H.close()

or
H = HDF5File(filename,''r'')
H.load()
B = H.data      \# B is a FTICRdata
H.close()

and to write
H = HDF5File(filename,''w'')
H.set\_data(B)         \# where B is a FTICRdata; do not use    H.data = B
H.save()
H.close()
\index{axes\_update() (File.HDF5File.HDF5File method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.HDF5File.HDF5File.axes_update}\pysiglinewithargsret{\bfcode{axes\_update}}{\emph{group='resol1'}, \emph{axis=2}, \emph{infos=None}}{}
routine called when you want to modify the information on a given axis
group is the group name, default is resol1
axis is the dimension we want to adjust
infos is a dictionnary with al fields we want to adjust

\end{fulllineitems}

\index{checkversion() (File.HDF5File.HDF5File method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.HDF5File.HDF5File.checkversion}\pysiglinewithargsret{\bfcode{checkversion}}{}{}
check file version and exit if incompatible

\end{fulllineitems}

\index{close() (File.HDF5File.HDF5File method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.HDF5File.HDF5File.close}\pysiglinewithargsret{\bfcode{close}}{}{}
Closes HDF5File

\end{fulllineitems}

\index{createCArray() (File.HDF5File.HDF5File method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.HDF5File.HDF5File.createCArray}\pysiglinewithargsret{\bfcode{createCArray}}{\emph{where}, \emph{name}, \emph{data\_type}, \emph{shape}, \emph{chunk=None}}{}
Create a CArray in the given hf\_file

\end{fulllineitems}

\index{createGroup() (File.HDF5File.HDF5File method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.HDF5File.HDF5File.createGroup}\pysiglinewithargsret{\bfcode{createGroup}}{\emph{where}, \emph{name}}{}
Create a group in the given hf\_file

\end{fulllineitems}

\index{createTable() (File.HDF5File.HDF5File method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.HDF5File.HDF5File.createTable}\pysiglinewithargsret{\bfcode{createTable}}{\emph{where}, \emph{name}, \emph{description}}{}
Create a Table in the given hf\_file at the given position with the right description

\end{fulllineitems}

\index{create\_HDF5\_info() (File.HDF5File.HDF5File method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.HDF5File.HDF5File.create_HDF5_info}\pysiglinewithargsret{\bfcode{create\_HDF5\_info}}{}{}
Creates a HDF5 file, takes info as parameter

\end{fulllineitems}

\index{create\_HDF5\_nparray() (File.HDF5File.HDF5File method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.HDF5File.HDF5File.create_HDF5_nparray}\pysiglinewithargsret{\bfcode{create\_HDF5\_nparray}}{}{}
Creates a HDF5 file, takes nparray as parameters

\end{fulllineitems}

\index{create\_from\_template() (File.HDF5File.HDF5File method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.HDF5File.HDF5File.create_from_template}\pysiglinewithargsret{\bfcode{create\_from\_template}}{\emph{data}, \emph{group='resol1'}}{}
Take params from the empty FTICR data and put all the informations in the HDF5File
creates an empty data, and attach it to data.buffer
data is created in group, with default value `resol1'

\end{fulllineitems}

\index{create\_generic() (File.HDF5File.HDF5File method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.HDF5File.HDF5File.create_generic}\pysiglinewithargsret{\bfcode{create\_generic}}{\emph{owner='NMRTEC'}}{}
A table is created with all generic informations about the file : owner, method, HDF5 Release,CreationDate, Last modification

\end{fulllineitems}

\index{create\_tables() (File.HDF5File.HDF5File method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.HDF5File.HDF5File.create_tables}\pysiglinewithargsret{\bfcode{create\_tables}}{}{}
Creates the different tables needed in a HDF5File according to the info parameters given 
If you don't pass any info dictionnary, it will take parameters from the self.header

\end{fulllineitems}

\index{determine\_chunkshape() (File.HDF5File.HDF5File method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.HDF5File.HDF5File.determine_chunkshape}\pysiglinewithargsret{\bfcode{determine\_chunkshape}}{\emph{sizeF1=None}, \emph{sizeF2=None}}{}
Determine a good chunkshape according to the size of each axis

\end{fulllineitems}

\index{fill\_table() (File.HDF5File.HDF5File method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.HDF5File.HDF5File.fill_table}\pysiglinewithargsret{\bfcode{fill\_table}}{\emph{table}, \emph{infos}}{}
Fill in the given table. Axis is the dimension we are processing

\end{fulllineitems}

\index{get\_data() (File.HDF5File.HDF5File method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.HDF5File.HDF5File.get_data}\pysiglinewithargsret{\bfcode{get\_data}}{\emph{group='resol1'}, \emph{mode='onfile'}}{}
loads and returns the FTICRdata attached to the self file
same parameters as load()

\end{fulllineitems}

\index{get\_file\_infos() (File.HDF5File.HDF5File method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.HDF5File.HDF5File.get_file_infos}\pysiglinewithargsret{\bfcode{get\_file\_infos}}{}{}
Read the generic\_table and return the informations

\end{fulllineitems}

\index{get\_info() (File.HDF5File.HDF5File method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.HDF5File.HDF5File.get_info}\pysiglinewithargsret{\bfcode{get\_info}}{}{}
Retrieve info from self.nparray

\end{fulllineitems}

\index{load() (File.HDF5File.HDF5File method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.HDF5File.HDF5File.load}\pysiglinewithargsret{\bfcode{load}}{\emph{group='resol1'}, \emph{mode='onfile'}}{}
loads the data into memory,
set self.data as a FTICRData

group defines which group is loaded (default is resol1)
mode defines how it is loaded in memory,
\begin{quote}
\begin{description}
\item[{``onfile'' (default ) the data is kept on file and loaded only on demand.}] \leavevmode
the capability of modifying the data is determined by the way the file was opened
the data cannot be modified unless the file was opened with access='w' or `rw'

\item[{``memory'' the data is copied to a memroy buffer and can be freely modified}] \leavevmode
warning - may saturate the computer memory, there is no control

\end{description}

if you want to load data into memory after having opened in `onfile'' mode, then do the following :
h.load(mode=''onfile'')
b = d.data.buffer{[}...{]}     \# data are now copied into a new memory buffer b using ellipsis syntax
d.data.buffer = b           \# and b is used as the data buffer.
\end{quote}

\end{fulllineitems}

\index{position\_array() (File.HDF5File.HDF5File method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.HDF5File.HDF5File.position_array}\pysiglinewithargsret{\bfcode{position\_array}}{\emph{group='resol1'}}{}
Fill in the HDF5 file with the given buffer, HDF5 file is created with the given numpy array and the corresponding tables

\end{fulllineitems}

\index{save() (File.HDF5File.HDF5File method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.HDF5File.HDF5File.save}\pysiglinewithargsret{\bfcode{save}}{\emph{ser\_file}, \emph{group='resol1'}}{}
save the ser\_file to the HDF5 file

\end{fulllineitems}

\index{save\_fticrd() (File.HDF5File.HDF5File method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.HDF5File.HDF5File.save_fticrd}\pysiglinewithargsret{\bfcode{save\_fticrd}}{}{}
save the FTICRData to the H5F file

\end{fulllineitems}

\index{set\_compression() (File.HDF5File.HDF5File method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.HDF5File.HDF5File.set_compression}\pysiglinewithargsret{\bfcode{set\_compression}}{\emph{On=False}}{}
sets HDF5 file compression to zlib if On is True; to none otherwise

\end{fulllineitems}

\index{set\_data() (File.HDF5File.HDF5File method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.HDF5File.HDF5File.set_data}\pysiglinewithargsret{\bfcode{set\_data}}{\emph{data}, \emph{group='resol1'}}{}
Take the ser\_file and the params and put all the informations in the HDF5File

\end{fulllineitems}

\index{set\_data\_from\_fticrd() (File.HDF5File.HDF5File method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.HDF5File.HDF5File.set_data_from_fticrd}\pysiglinewithargsret{\bfcode{set\_data\_from\_fticrd}}{\emph{buff}, \emph{group='resol1'}}{}
sets the FTICRdata attached to the (to be written) file

\end{fulllineitems}

\index{table\_update() (File.HDF5File.HDF5File method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.HDF5File.HDF5File.table_update}\pysiglinewithargsret{\bfcode{table\_update}}{\emph{group='resol1'}, \emph{axis=2}, \emph{key='highmass'}, \emph{value=4000.0}}{}
Microchangement in the wanted table

\end{fulllineitems}


\end{fulllineitems}

\index{determine\_chunkshape() (in module File.HDF5File)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.HDF5File.determine_chunkshape}\pysiglinewithargsret{\code{File.HDF5File.}\bfcode{determine\_chunkshape}}{\emph{size1}, \emph{size2}}{}
returns optimum size for chuncks for a dataset of file size1, size2
and update cachesize for accomodating dataset

\end{fulllineitems}

\index{nparray\_to\_fticrd() (in module File.HDF5File)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.HDF5File.nparray_to_fticrd}\pysiglinewithargsret{\code{File.HDF5File.}\bfcode{nparray\_to\_fticrd}}{\emph{name}, \emph{nparray}}{}
\end{fulllineitems}

\index{up0p6\_to\_0p7() (in module File.HDF5File)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.HDF5File.up0p6_to_0p7}\pysiglinewithargsret{\code{File.HDF5File.}\bfcode{up0p6\_to\_0p7}}{\emph{fname}, \emph{debug=1}}{}
docstring for up0p6\_to\_0p7
Function that deals with changing HDF5 files created with file\_version 0.6 to be read with 0.7
It modifies

\end{fulllineitems}

\index{up0p7\_to\_0p8() (in module File.HDF5File)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.HDF5File.up0p7_to_0p8}\pysiglinewithargsret{\code{File.HDF5File.}\bfcode{up0p7\_to\_0p8}}{\emph{fname}, \emph{debug=1}}{}
docstring for up0p7\_to\_0p8
Function that deals with changing HDF5 files created with file\_version 0.7 to be read with 0.8

\end{fulllineitems}

\index{update() (in module File.HDF5File)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.HDF5File.update}\pysiglinewithargsret{\code{File.HDF5File.}\bfcode{update}}{\emph{fname}, \emph{debug=1}}{}
update so that the file is up to date

\end{fulllineitems}



\subsection{Solarix}
\label{rst/code:module-File.Solarix}\label{rst/code:solarix}\index{File.Solarix (module)}
Solarix.py
\begin{quote}

Utility to Handle Solarix files
\end{quote}

Created by mac on 2013-05-24.
Copyright (c) 2013 \_\_NMRTEC\_\_. All rights reserved.
\index{Import\_1D() (in module File.Solarix)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.Solarix.Import_1D}\pysiglinewithargsret{\code{File.Solarix.}\bfcode{Import\_1D}}{\emph{folder}, \emph{outfile='`}}{}
Entry point to import 1D spectra
It returns a FTICRData
It writes a HDF5 file if an outfile is mentionned

\end{fulllineitems}

\index{Import\_2D() (in module File.Solarix)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.Solarix.Import_2D}\pysiglinewithargsret{\code{File.Solarix.}\bfcode{Import\_2D}}{\emph{folder}, \emph{outfile='`}, \emph{F1specwidth=None}}{}
Entry point to import 2D spectra
It returns a FTICRData
It writes a HDF5 file if an outfile is mentionned

\end{fulllineitems}

\index{Ser2D\_to\_FTICRFile() (in module File.Solarix)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.Solarix.Ser2D_to_FTICRFile}\pysiglinewithargsret{\code{File.Solarix.}\bfcode{Ser2D\_to\_FTICRFile}}{\emph{sizeF1}, \emph{sizeF2}, \emph{filename='ser'}, \emph{outfile='H5f.h5'}, \emph{chunks=None}}{}
Charge any ser file directly in H5f file

\end{fulllineitems}

\index{get\_param() (in module File.Solarix)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.Solarix.get_param}\pysiglinewithargsret{\code{File.Solarix.}\bfcode{get\_param}}{\emph{param}, \emph{names}, \emph{values}}{}
From params, this function returns the  value of the given param

\end{fulllineitems}

\index{locate\_acquisition() (in module File.Solarix)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.Solarix.locate_acquisition}\pysiglinewithargsret{\code{File.Solarix.}\bfcode{locate\_acquisition}}{\emph{folder}}{}
From the given folder this function return the absolute path to the apexAcquisition.method file
It should always be in a subfolder

\end{fulllineitems}

\index{read\_2D() (in module File.Solarix)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.Solarix.read_2D}\pysiglinewithargsret{\code{File.Solarix.}\bfcode{read\_2D}}{\emph{sizeF1}, \emph{sizeF2}, \emph{filename='ser'}}{}
Reads in a Apex 2D fid

sizeF1 is the number of fid
sizeF2 is the number of data-points in the fid
uses array

\end{fulllineitems}

\index{read\_3D() (in module File.Solarix)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.Solarix.read_3D}\pysiglinewithargsret{\code{File.Solarix.}\bfcode{read\_3D}}{\emph{sizeF1}, \emph{sizeF2}, \emph{sizeF3}, \emph{filename='ser'}}{}
Ebauche de fonction

Reads in a Apex 3D fid

uses array

\end{fulllineitems}

\index{read\_param() (in module File.Solarix)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.Solarix.read_param}\pysiglinewithargsret{\code{File.Solarix.}\bfcode{read\_param}}{\emph{filename}}{}
Open the given file and retrieve all parameters from apexAcquisition.method
NC is written when no value for value is found

structure : \textless{}param name = ``AMS\_ActiveExclusion''\textgreater{}\textless{}value\textgreater{}0\textless{}/value\textgreater{}\textless{}/param\textgreater{}

read\_param returns  values in a dictionnary

\end{fulllineitems}

\index{read\_scan() (in module File.Solarix)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.Solarix.read_scan}\pysiglinewithargsret{\code{File.Solarix.}\bfcode{read\_scan}}{\emph{filename}}{}
Function that returns the number of scan that have been recorded
It is used to see wether the number of recorded points correspond to the L\_20 parameter

\end{fulllineitems}

\index{write\_ser() (in module File.Solarix)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.Solarix.write_ser}\pysiglinewithargsret{\code{File.Solarix.}\bfcode{write\_ser}}{\emph{bufferdata}, \emph{filename='ser'}}{}
Write a ser file from FTICRData

\end{fulllineitems}



\subsection{Thermo}
\label{rst/code:module-File.Thermo}\label{rst/code:thermo}\index{File.Thermo (module)}
Utility to Handle Thermofisher files

Marc-André from first draft by Lionel
\index{Import\_1D() (in module File.Thermo)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.Thermo.Import_1D}\pysiglinewithargsret{\code{File.Thermo.}\bfcode{Import\_1D}}{\emph{filename}}{}
Entry point to import 1D spectra
It returns an Orbitrap data

\end{fulllineitems}

\index{Thermo\_Tests (class in File.Thermo)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.Thermo.Thermo_Tests}\pysiglinewithargsret{\strong{class }\code{File.Thermo.}\bfcode{Thermo\_Tests}}{\emph{methodName='runTest'}}{}
A FAIRE

\end{fulllineitems}

\index{read\_data() (in module File.Thermo)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.Thermo.read_data}\pysiglinewithargsret{\code{File.Thermo.}\bfcode{read\_data}}{\emph{F}, \emph{typ='float'}}{}
given F, an opened file, reads the values and 
read\_param returns  values in a dictionnary

\end{fulllineitems}

\index{read\_param() (in module File.Thermo)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.Thermo.read_param}\pysiglinewithargsret{\code{File.Thermo.}\bfcode{read\_param}}{\emph{F}}{}
given F, an opend file , retrieve all parameters found in file header

read\_param returns  values in a plain dictionnary

\end{fulllineitems}

\index{read\_thermo() (in module File.Thermo)}

\begin{fulllineitems}
\phantomsection\label{rst/code:File.Thermo.read_thermo}\pysiglinewithargsret{\code{File.Thermo.}\bfcode{read\_thermo}}{\emph{filename}}{}
reads a thermofisher orbitrap file

\end{fulllineitems}



\section{FTICR}
\label{rst/code:fticr}\label{rst/code:module-FTICR}\index{FTICR (module)}
FTMS.py

Created by Marc-André on 2011-03-20.
Copyright (c) 2011 IGBMC. All rights reserved.
\index{FTICRAxis (class in FTICR)}

\begin{fulllineitems}
\phantomsection\label{rst/code:FTICR.FTICRAxis}\pysiglinewithargsret{\strong{class }\code{FTICR.}\bfcode{FTICRAxis}}{\emph{size=1024}, \emph{specwidth=6283.185307179586}, \emph{itype=0}, \emph{units='point'}, \emph{ref\_mass=344.0974}, \emph{ref\_freq=419620.0}, \emph{highmass=10000.0}, \emph{left\_point=0.0}}{}
hold information for one FT-ICR axis
used internally
\index{Hz\_axis() (FTICR.FTICRAxis method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:FTICR.FTICRAxis.Hz_axis}\pysiglinewithargsret{\bfcode{Hz\_axis}}{}{}
return axis containing Hz values, can be used for display

\end{fulllineitems}

\index{deltamz() (FTICR.FTICRAxis method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:FTICR.FTICRAxis.deltamz}\pysiglinewithargsret{\bfcode{deltamz}}{\emph{mz\_value}}{}
computes the theorical resolution in m/z at m/z location

\end{fulllineitems}

\index{extract() (FTICR.FTICRAxis method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:FTICR.FTICRAxis.extract}\pysiglinewithargsret{\bfcode{extract}}{\emph{(start}, \emph{end)}}{}
redefines the axis parameters so that the new axe is extracted for the points {[}start:end{]}

\end{fulllineitems}

\index{freq\_axis() (FTICR.FTICRAxis method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:FTICR.FTICRAxis.freq_axis}\pysiglinewithargsret{\bfcode{freq\_axis}}{}{}
return axis containing Hz values, can be used for display

\end{fulllineitems}

\index{htoi() (FTICR.FTICRAxis method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:FTICR.FTICRAxis.htoi}\pysiglinewithargsret{\bfcode{htoi}}{\emph{value}}{}
returns point value (i) from Hz value (h)

\end{fulllineitems}

\index{itoh() (FTICR.FTICRAxis method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:FTICR.FTICRAxis.itoh}\pysiglinewithargsret{\bfcode{itoh}}{\emph{value}}{}
returns Hz value (h) from point value (i)

\end{fulllineitems}

\index{itomz() (FTICR.FTICRAxis method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:FTICR.FTICRAxis.itomz}\pysiglinewithargsret{\bfcode{itomz}}{\emph{value}}{}
return m/z (mz) from point value (i)

\end{fulllineitems}

\index{lowmass (FTICR.FTICRAxis attribute)}

\begin{fulllineitems}
\phantomsection\label{rst/code:FTICR.FTICRAxis.lowmass}\pysigline{\bfcode{lowmass}}
highest mass of interest - defined by the Nyquist frequency limit

\end{fulllineitems}

\index{mass\_axis() (FTICR.FTICRAxis method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:FTICR.FTICRAxis.mass_axis}\pysiglinewithargsret{\bfcode{mass\_axis}}{}{}
return axis containing m/z values, can be used for display

\end{fulllineitems}

\index{mz\_axis() (FTICR.FTICRAxis method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:FTICR.FTICRAxis.mz_axis}\pysiglinewithargsret{\bfcode{mz\_axis}}{}{}
return axis containing m/z values, can be used for display

\end{fulllineitems}

\index{mztoi() (FTICR.FTICRAxis method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:FTICR.FTICRAxis.mztoi}\pysiglinewithargsret{\bfcode{mztoi}}{\emph{value}}{}
return point value (i) from  m/z (mz)

\end{fulllineitems}

\index{report() (FTICR.FTICRAxis method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:FTICR.FTICRAxis.report}\pysiglinewithargsret{\bfcode{report}}{}{}
high level reporting

\end{fulllineitems}


\end{fulllineitems}

\index{FTICRData (class in FTICR)}

\begin{fulllineitems}
\phantomsection\label{rst/code:FTICR.FTICRData}\pysiglinewithargsret{\strong{class }\code{FTICR.}\bfcode{FTICRData}}{\emph{dim=1}, \emph{shape=None}, \emph{mode='memory'}, \emph{buffer=None}, \emph{name=None}, \emph{debug=0}}{}
subclass of NPKData, meant for handling FT-ICR data
allows 1D and 2D data-sets
\index{display() (FTICR.FTICRData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:FTICR.FTICRData.display}\pysiglinewithargsret{\bfcode{display}}{\emph{scale=1.0}, \emph{absmax=0.0}, \emph{show=False}, \emph{label=None}, \emph{new\_fig=True}, \emph{axis=None}, \emph{mode3D=False}, \emph{zoom=None}, \emph{xlabel='\_def\_'}, \emph{ylabel='\_def\_'}, \emph{figure=None}}{}
display the FTICR data using NPKDATA display method
check parameters in NPKDATA
\begin{itemize}
\item {} 
copied here - (might be out of date)

\end{itemize}

scale   allows to increase the vertical scale of display
absmax  overwrite the value for the largest point, which will not be computed
\begin{quote}

display is scaled so that the largest point is first computed (and stored in absmax),
and then the value at absmax/scale is set full screen
\end{quote}
\begin{description}
\item[{show    will call plot.show() at the end, allowing every declared display to be shown on-screen}] \leavevmode
useless in ipython

\end{description}

label   add a label text to plot
xlabel, ylabel : axes label (default is self.units - use None to remove)
axis    used as axis if present, axis length should match experiment length
\begin{quote}

in 2D, should be a pair (xaxis,yaxis)
\end{quote}

new\_fig will create a new window if set to True (default) (active only is figure==None)
mode3D  use malb 3D display instead of matplotlib contour for 2D display
zoom    is a tuple defining the zomm window (left,right) or   ((F1\_limits),(F2\_limits))
figure  if not None, will be used directly to display instead of using its own

can actually be called without harm, even if no graphic is available, it will just do nothing.

\end{fulllineitems}

\index{highmass (FTICR.FTICRData attribute)}

\begin{fulllineitems}
\phantomsection\label{rst/code:FTICR.FTICRData.highmass}\pysigline{\bfcode{highmass}}
copy highmass to all the axes

\end{fulllineitems}

\index{ref\_freq (FTICR.FTICRData attribute)}

\begin{fulllineitems}
\phantomsection\label{rst/code:FTICR.FTICRData.ref_freq}\pysigline{\bfcode{ref\_freq}}
copy ref\_freq to all the axes

\end{fulllineitems}

\index{ref\_mass (FTICR.FTICRData attribute)}

\begin{fulllineitems}
\phantomsection\label{rst/code:FTICR.FTICRData.ref_mass}\pysigline{\bfcode{ref\_mass}}
copy ref\_mass to all the axes

\end{fulllineitems}

\index{save\_msh5() (FTICR.FTICRData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:FTICR.FTICRData.save_msh5}\pysiglinewithargsret{\bfcode{save\_msh5}}{\emph{name}, \emph{set\_compression=False}}{}
save data to a HDF5 file

experimental !

\end{fulllineitems}

\index{specwidth (FTICR.FTICRData attribute)}

\begin{fulllineitems}
\phantomsection\label{rst/code:FTICR.FTICRData.specwidth}\pysigline{\bfcode{specwidth}}
copy specwidth to all the axes

\end{fulllineitems}

\index{trimz() (FTICR.FTICRData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:FTICR.FTICRData.trimz}\pysiglinewithargsret{\bfcode{trimz}}{\emph{axis=0}}{}
extract the data so as to keep only lowmass-highmass range
axis determines which axis to trim, axis=0 (default) indicates all axes

\end{fulllineitems}

\index{units (FTICR.FTICRData attribute)}

\begin{fulllineitems}
\phantomsection\label{rst/code:FTICR.FTICRData.units}\pysigline{\bfcode{units}}
copy units to all the axes

\end{fulllineitems}


\end{fulllineitems}

\index{fticr\_mass\_axis() (in module FTICR)}

\begin{fulllineitems}
\phantomsection\label{rst/code:FTICR.fticr_mass_axis}\pysiglinewithargsret{\code{FTICR.}\bfcode{fticr\_mass\_axis}}{\emph{length}, \emph{spectral\_width}, \emph{ref\_mass}, \emph{ref\_freq}}{}
returns an array which will calibrate a FT-ICR experiment
length : number of points in the axis
spectral\_width : of the ICR measure
ref\_mass : value of the m/z reference
ref\_freq =: frequence at which is is observed.

\end{fulllineitems}



\section{Orbitrap}
\label{rst/code:orbitrap}\label{rst/code:module-Orbitrap}\index{Orbitrap (module)}
Orbitrap.py

Created by Marc-André and Lionel on 10 april 2014
Copyright (c) 2014 IGBMC. All rights reserved.
\index{OrbiAxis (class in Orbitrap)}

\begin{fulllineitems}
\phantomsection\label{rst/code:Orbitrap.OrbiAxis}\pysiglinewithargsret{\strong{class }\code{Orbitrap.}\bfcode{OrbiAxis}}{\emph{size=1024}, \emph{specwidth=10000000.0}, \emph{itype=0}, \emph{units='point'}, \emph{ref\_mass=715.3122}, \emph{ref\_freq=1887533.975611561}, \emph{highmass=10000.0}, \emph{left\_point=0.0}}{}
hold information for one Orbitrap axis
used internally
\index{Hz\_axis() (Orbitrap.OrbiAxis method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:Orbitrap.OrbiAxis.Hz_axis}\pysiglinewithargsret{\bfcode{Hz\_axis}}{}{}
return axis containing Hz values, can be used for display

\end{fulllineitems}

\index{deltamz() (Orbitrap.OrbiAxis method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:Orbitrap.OrbiAxis.deltamz}\pysiglinewithargsret{\bfcode{deltamz}}{\emph{mz\_value}}{}
computes the theorical resolution in m/z at m/z location

\end{fulllineitems}

\index{extract() (Orbitrap.OrbiAxis method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:Orbitrap.OrbiAxis.extract}\pysiglinewithargsret{\bfcode{extract}}{\emph{(start}, \emph{end)}}{}
redefines the axis parameters so that the new axe is extracted for the points {[}start:end{]}

\end{fulllineitems}

\index{freq\_axis() (Orbitrap.OrbiAxis method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:Orbitrap.OrbiAxis.freq_axis}\pysiglinewithargsret{\bfcode{freq\_axis}}{}{}
return axis containing Hz values, can be used for display

\end{fulllineitems}

\index{htoi() (Orbitrap.OrbiAxis method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:Orbitrap.OrbiAxis.htoi}\pysiglinewithargsret{\bfcode{htoi}}{\emph{value}}{}
returns point value (i) from Hz value (h)

\end{fulllineitems}

\index{itoh() (Orbitrap.OrbiAxis method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:Orbitrap.OrbiAxis.itoh}\pysiglinewithargsret{\bfcode{itoh}}{\emph{value}}{}
returns Hz value (h) from point value (i)

\end{fulllineitems}

\index{itomz() (Orbitrap.OrbiAxis method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:Orbitrap.OrbiAxis.itomz}\pysiglinewithargsret{\bfcode{itomz}}{\emph{value}}{}
return m/z (mz) from point value (i)

\end{fulllineitems}

\index{lowmass (Orbitrap.OrbiAxis attribute)}

\begin{fulllineitems}
\phantomsection\label{rst/code:Orbitrap.OrbiAxis.lowmass}\pysigline{\bfcode{lowmass}}
highest mass of interest - defined by the Nyquist frequency limit

\end{fulllineitems}

\index{mztoi() (Orbitrap.OrbiAxis method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:Orbitrap.OrbiAxis.mztoi}\pysiglinewithargsret{\bfcode{mztoi}}{\emph{value}}{}
return point value (i) from  m/z (mz)

\end{fulllineitems}

\index{report() (Orbitrap.OrbiAxis method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:Orbitrap.OrbiAxis.report}\pysiglinewithargsret{\bfcode{report}}{}{}
high level reporting

\end{fulllineitems}


\end{fulllineitems}

\index{OrbiData (class in Orbitrap)}

\begin{fulllineitems}
\phantomsection\label{rst/code:Orbitrap.OrbiData}\pysiglinewithargsret{\strong{class }\code{Orbitrap.}\bfcode{OrbiData}}{\emph{dim=1}, \emph{shape=None}, \emph{mode='memory'}, \emph{buffer=None}, \emph{name=None}, \emph{debug=0}}{}
subclass of NPKData, meant for handling Orbitrap data
doc to be written ...
\index{display() (Orbitrap.OrbiData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:Orbitrap.OrbiData.display}\pysiglinewithargsret{\bfcode{display}}{\emph{scale=1.0}, \emph{absmax=0.0}, \emph{show=False}, \emph{label=None}, \emph{new\_fig=True}, \emph{axis=None}, \emph{mode3D=False}, \emph{zoom=None}, \emph{xlabel='\_def\_'}, \emph{ylabel='\_def\_'}, \emph{figure=None}}{}
display the Orbitrap data using NPKDATA display method
check parameters in NPKDATA
\begin{itemize}
\item {} 
copied here - (might be out of date)

\end{itemize}

scale   allows to increase the vertical scale of display
absmax  overwrite the value for the largest point, which will not be computed
\begin{quote}

display is scaled so that the largest point is first computed (and stored in absmax),
and then the value at absmax/scale is set full screen
\end{quote}
\begin{description}
\item[{show    will call plot.show() at the end, allowing every declared display to be shown on-screen}] \leavevmode
useless in ipython

\end{description}

label   add a label text to plot
xlabel, ylabel : axes label (default is self.units - use None to remove)
axis    used as axis if present, axis length should match experiment length
\begin{quote}

in 2D, should be a pair (xaxis,yaxis)
\end{quote}

new\_fig will create a new window if set to True (default) (active only is figure==None)
mode3D  use malb 3D display instead of matplotlib contour for 2D display
zoom    is a tuple defining the zomm window (left,right) or   ((F1\_limits),(F2\_limits))
figure  if not None, will be used directly to display instead of using its own

can actually be called without harm, even if no graphic is available, it will just do nothing.

\end{fulllineitems}

\index{highmass (Orbitrap.OrbiData attribute)}

\begin{fulllineitems}
\phantomsection\label{rst/code:Orbitrap.OrbiData.highmass}\pysigline{\bfcode{highmass}}
copy highmass to all the axes

\end{fulllineitems}

\index{ref\_freq (Orbitrap.OrbiData attribute)}

\begin{fulllineitems}
\phantomsection\label{rst/code:Orbitrap.OrbiData.ref_freq}\pysigline{\bfcode{ref\_freq}}
copy ref\_freq to all the axes

\end{fulllineitems}

\index{ref\_mass (Orbitrap.OrbiData attribute)}

\begin{fulllineitems}
\phantomsection\label{rst/code:Orbitrap.OrbiData.ref_mass}\pysigline{\bfcode{ref\_mass}}
copy ref\_mass to all the axes

\end{fulllineitems}

\index{save\_msh5() (Orbitrap.OrbiData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:Orbitrap.OrbiData.save_msh5}\pysiglinewithargsret{\bfcode{save\_msh5}}{\emph{name}}{}
save data to a HDF5 file

experimental !

\end{fulllineitems}

\index{specwidth (Orbitrap.OrbiData attribute)}

\begin{fulllineitems}
\phantomsection\label{rst/code:Orbitrap.OrbiData.specwidth}\pysigline{\bfcode{specwidth}}
copy specwidth to all the axes

\end{fulllineitems}

\index{trimz() (Orbitrap.OrbiData method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:Orbitrap.OrbiData.trimz}\pysiglinewithargsret{\bfcode{trimz}}{\emph{axis=0}}{}
extract the data so as to keep only lowmass-highmass range
axis determines which axis to trim, axis=0 (default) indicates all axes

\end{fulllineitems}

\index{units (Orbitrap.OrbiData attribute)}

\begin{fulllineitems}
\phantomsection\label{rst/code:Orbitrap.OrbiData.units}\pysigline{\bfcode{units}}
copy units to all the axes

\end{fulllineitems}


\end{fulllineitems}



\section{visu2D}
\label{rst/code:visu2d}\label{rst/code:module-visu2D}\index{visu2D (module)}
Created by Marc Andre Delsuc \& Lionel Chiron on 2011-05-19.
Copyright (c) 2011 IGBMC. All rights reserved.
\#\#\#
Program for visualizing FTICR2D data. 
Launch the PyQt4/PySide visualizer for FTICR2D.
\index{debugs\_activate() (in module visu2D)}

\begin{fulllineitems}
\phantomsection\label{rst/code:visu2D.debugs_activate}\pysiglinewithargsret{\code{visu2D.}\bfcode{debugs\_activate}}{\emph{*args}}{}
Debugging class methods.
Classes debugged are
-interface
-display
-convert
-gtools
-zooming
-move window
-interact

\end{fulllineitems}

\index{main() (in module visu2D)}

\begin{fulllineitems}
\phantomsection\label{rst/code:visu2D.main}\pysiglinewithargsret{\code{visu2D.}\bfcode{main}}{\emph{argv=None}}{}
creates and runs

\end{fulllineitems}



\subsection{inside Visu2D}
\label{rst/visu2d:inside-visu2d}\label{rst/visu2d::doc}

\subsubsection{Initialize and handle}
\label{rst/visu2d:initialize-and-handle}

\paragraph{interface}
\label{rst/visu2d:interface}\label{rst/visu2d:module-Visu.interface}\index{Visu.interface (module)}
Created by Lionel Chiron  02/10/2013 
Copyright (c) 2013 \_\_NMRTEC\_\_. All rights reserved.
\index{INTERFACE (class in Visu.interface)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.interface.INTERFACE}\pysigline{\strong{class }\code{Visu.interface.}\bfcode{INTERFACE}}
Creation of the graphic window  
Methods :
\begin{itemize}
\item {} 
init\_interf

\item {} 
makelayout

\item {} 
makecanvas

\item {} 
clearlayout

\item {} 
run

\end{itemize}
\index{clearlayout() (Visu.interface.INTERFACE method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.interface.INTERFACE.clearlayout}\pysiglinewithargsret{\bfcode{clearlayout}}{\emph{layout}}{}
Clear the layout of the centralwidget

\end{fulllineitems}

\index{init\_interf() (Visu.interface.INTERFACE method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.interface.INTERFACE.init_interf}\pysiglinewithargsret{\bfcode{init\_interf}}{}{}
Initialization of the interface

\end{fulllineitems}

\index{makelayout() (Visu.interface.INTERFACE method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.interface.INTERFACE.makelayout}\pysiglinewithargsret{\bfcode{makelayout}}{}{}
make the layout in the centralwidget

\end{fulllineitems}

\index{pr() (Visu.interface.INTERFACE method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.interface.INTERFACE.pr}\pysiglinewithargsret{\bfcode{pr}}{\emph{var}, \emph{message='`}}{}
print

\end{fulllineitems}


\end{fulllineitems}



\paragraph{interface\_actions}
\label{rst/visu2d:module-Visu.interface_actions}\label{rst/visu2d:interface-actions}\index{Visu.interface\_actions (module)}\index{INTERACT (class in Visu.interface\_actions)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.interface_actions.INTERACT}\pysiglinewithargsret{\strong{class }\code{Visu.interface\_actions.}\bfcode{INTERACT}}{\emph{zoom}, \emph{mwind}, \emph{data}, \emph{display}, \emph{interf}, \emph{paramz}, \emph{gtools}, \emph{zoom3d}, \emph{stools}, \emph{convert}, \emph{save}}{}
Handle all the interface interactions.
\index{afffile() (Visu.interface\_actions.INTERACT method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.interface_actions.INTERACT.afffile}\pysiglinewithargsret{\bfcode{afffile}}{}{}
Show dataset in C window and addresses of used files
vis.resmin : resolution for window D

\end{fulllineitems}

\index{backhome() (Visu.interface\_actions.INTERACT method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.interface_actions.INTERACT.backhome}\pysiglinewithargsret{\bfcode{backhome}}{}{}
going to the original view

\end{fulllineitems}

\index{backzoo() (Visu.interface\_actions.INTERACT method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.interface_actions.INTERACT.backzoo}\pysiglinewithargsret{\bfcode{backzoo}}{}{}
going back in the zooms

\end{fulllineitems}

\index{button() (Visu.interface\_actions.INTERACT method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.interface_actions.INTERACT.button}\pysiglinewithargsret{\bfcode{button}}{\emph{nb}, \emph{action}, \emph{name\_icon=None}, \emph{icon\_size=None}}{}
General definition for the buttons
nb : number for the button
action : method associated to the action.
name\_icon : name of the icon in the directory Visu/iconsUi/, must be in png format.
icon\_size : size of the icon for fitting to the button size.

\end{fulllineitems}

\index{coord\_profile\_x() (Visu.interface\_actions.INTERACT method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.interface_actions.INTERACT.coord_profile_x}\pysiglinewithargsret{\bfcode{coord\_profile\_x}}{\emph{xval}}{}
Makes coordinates profile for x profile.
Called by coord\_profile.
Returns the extreme coordinates in m/z or point format.

\end{fulllineitems}

\index{coord\_profile\_y() (Visu.interface\_actions.INTERACT method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.interface_actions.INTERACT.coord_profile_y}\pysiglinewithargsret{\bfcode{coord\_profile\_y}}{\emph{yval}}{}
Makes coordinates profile for y profile 
Called by coord\_profile
Returns the extreme coordinates in m/z or point format

\end{fulllineitems}

\index{drag\_connect() (Visu.interface\_actions.INTERACT method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.interface_actions.INTERACT.drag_connect}\pysiglinewithargsret{\bfcode{drag\_connect}}{}{}
Drag the main image.

\end{fulllineitems}

\index{forwzoo() (Visu.interface\_actions.INTERACT method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.interface_actions.INTERACT.forwzoo}\pysiglinewithargsret{\bfcode{forwzoo}}{}{}
going forward in the zooms

\end{fulllineitems}

\index{interfGraph() (Visu.interface\_actions.INTERACT method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.interface_actions.INTERACT.interfGraph}\pysiglinewithargsret{\bfcode{interfGraph}}{}{}
Defines the buttons, lineEdits and actions associated.

\end{fulllineitems}

\index{lineEdit() (Visu.interface\_actions.INTERACT method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.interface_actions.INTERACT.lineEdit}\pysiglinewithargsret{\bfcode{lineEdit}}{\emph{nb}, \emph{action}}{}
General lineEdit
nb : number of the lineEdit
action : associated action.

\end{fulllineitems}

\index{lineEdit\_and\_button() (Visu.interface\_actions.INTERACT method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.interface_actions.INTERACT.lineEdit_and_button}\pysiglinewithargsret{\bfcode{lineEdit\_and\_button}}{\emph{name\_lineEdit}, \emph{name\_button}, \emph{action}}{}
Defines a lineEdit and an associated button.
Uses self.lineEdit() and self.button()

\end{fulllineitems}

\index{list\_res() (Visu.interface\_actions.INTERACT method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.interface_actions.INTERACT.list_res}\pysiglinewithargsret{\bfcode{list\_res}}{}{}
resolutions list made from self.data

\end{fulllineitems}

\index{manual\_profile() (Visu.interface\_actions.INTERACT method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.interface_actions.INTERACT.manual_profile}\pysiglinewithargsret{\bfcode{manual\_profile}}{}{}
Manual profile

\end{fulllineitems}

\index{manual\_scale() (Visu.interface\_actions.INTERACT method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.interface_actions.INTERACT.manual_scale}\pysiglinewithargsret{\bfcode{manual\_scale}}{}{}
Manual scaling.

\end{fulllineitems}

\index{manual\_zoom() (Visu.interface\_actions.INTERACT method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.interface_actions.INTERACT.manual_zoom}\pysiglinewithargsret{\bfcode{manual\_zoom}}{}{}
Manual zoom
Coordinates are entered manually with format llx, lly, urx, ury.

\end{fulllineitems}

\index{permute\_states() (Visu.interface\_actions.INTERACT method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.interface_actions.INTERACT.permute_states}\pysiglinewithargsret{\bfcode{permute\_states}}{\emph{test}, \emph{etat0}, \emph{etat1}}{}
function for swapping between two states..
have to define first value of state before.

\end{fulllineitems}

\index{pr() (Visu.interface\_actions.INTERACT method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.interface_actions.INTERACT.pr}\pysiglinewithargsret{\bfcode{pr}}{\emph{var}, \emph{message='`}}{}
print

\end{fulllineitems}

\index{prepare\_coord\_profile() (Visu.interface\_actions.INTERACT method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.interface_actions.INTERACT.prepare_coord_profile}\pysiglinewithargsret{\bfcode{prepare\_coord\_profile}}{\emph{values}, \emph{ct=None}}{}
Makes coordinates profile
Called by take\_lineEdit\_xy\_format

\end{fulllineitems}

\index{savefigure() (Visu.interface\_actions.INTERACT method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.interface_actions.INTERACT.savefigure}\pysiglinewithargsret{\bfcode{savefigure}}{\emph{kind}}{}
Function to save figure from window C.

\end{fulllineitems}

\index{savefigurepdf() (Visu.interface\_actions.INTERACT method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.interface_actions.INTERACT.savefigurepdf}\pysiglinewithargsret{\bfcode{savefigurepdf}}{}{}
Save the main view in pdf

\end{fulllineitems}

\index{savefigurepng() (Visu.interface\_actions.INTERACT method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.interface_actions.INTERACT.savefigurepng}\pysiglinewithargsret{\bfcode{savefigurepng}}{}{}
Save the main view in png

\end{fulllineitems}

\index{scale\_control() (Visu.interface\_actions.INTERACT method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.interface_actions.INTERACT.scale_control}\pysiglinewithargsret{\bfcode{scale\_control}}{}{}
Show scale in the interface.

\end{fulllineitems}

\index{select\_curs() (Visu.interface\_actions.INTERACT method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.interface_actions.INTERACT.select_curs}\pysiglinewithargsret{\bfcode{select\_curs}}{}{}
Select the arrow cursor

\end{fulllineitems}

\index{select\_drag() (Visu.interface\_actions.INTERACT method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.interface_actions.INTERACT.select_drag}\pysiglinewithargsret{\bfcode{select\_drag}}{}{}
Select the drag function (hand)

\end{fulllineitems}

\index{select\_manual\_profile() (Visu.interface\_actions.INTERACT method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.interface_actions.INTERACT.select_manual_profile}\pysiglinewithargsret{\bfcode{select\_manual\_profile}}{}{}
Select the function manual\_profile

\end{fulllineitems}

\index{swap\_from\_mz() (Visu.interface\_actions.INTERACT method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.interface_actions.INTERACT.swap_from_mz}\pysiglinewithargsret{\bfcode{swap\_from\_mz}}{}{}
Passes from m/z to point

\end{fulllineitems}

\index{swap\_from\_proint() (Visu.interface\_actions.INTERACT method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.interface_actions.INTERACT.swap_from_proint}\pysiglinewithargsret{\bfcode{swap\_from\_proint}}{}{}
Passes from point to m/z

\end{fulllineitems}

\index{swap\_pt\_mz() (Visu.interface\_actions.INTERACT method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.interface_actions.INTERACT.swap_pt_mz}\pysiglinewithargsret{\bfcode{swap\_pt\_mz}}{}{}
Function for passing from ``point mode'' to ``m/z mode'' and inversely.
Change only in C window

\end{fulllineitems}

\index{take\_lineEdit() (Visu.interface\_actions.INTERACT method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.interface_actions.INTERACT.take_lineEdit}\pysiglinewithargsret{\bfcode{take\_lineEdit}}{\emph{ledit}}{}
Takes values from lineEdit for zoom and profile. 
Passes the coordinates in ``point mode''.
Called by manual\_profile.

\end{fulllineitems}

\index{take\_lineEdit\_xy\_format() (Visu.interface\_actions.INTERACT method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.interface_actions.INTERACT.take_lineEdit_xy_format}\pysiglinewithargsret{\bfcode{take\_lineEdit\_xy\_format}}{\emph{lineEdit\_value}}{}
Takes the profile with format ``y200'' for horizontal line y=200
ct is the coordinates type

\end{fulllineitems}

\index{zoom3D() (Visu.interface\_actions.INTERACT method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.interface_actions.INTERACT.zoom3D}\pysiglinewithargsret{\bfcode{zoom3D}}{}{}
From zoom coordinates, calculates the zoom area. 
If the area is small enough, makes the 3D reprensentation in m/z coordinates.

\end{fulllineitems}


\end{fulllineitems}



\paragraph{Pyside\_PyQt4}
\label{rst/visu2d:pyside-pyqt4}\label{rst/visu2d:module-Visu.Pyside_PyQt4}\index{Visu.Pyside\_PyQt4 (module)}

\paragraph{Load}
\label{rst/visu2d:load}\label{rst/visu2d:module-Visu.Load}\index{Visu.Load (module)}\index{LOAD (class in Visu.Load)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.Load.LOAD}\pysiglinewithargsret{\strong{class }\code{Visu.Load.}\bfcode{LOAD}}{\emph{configfile=None}, \emph{msh5file=None}}{}
Class to load the resolutions from the msh5file directly or addressed in the visu2D.mscf.
\index{loadres() (Visu.Load.LOAD method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.Load.LOAD.loadres}\pysiglinewithargsret{\bfcode{loadres}}{}{}
Loads the different resolutions from Hdf5 files and put them in a list (self.d) of FTICRdata objects. 
self.d{[}0{]} is the highest resolution. Loadres() counts also the number of resolutions in the msh5 file.

\end{fulllineitems}

\index{pr() (Visu.Load.LOAD method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.Load.LOAD.pr}\pysiglinewithargsret{\bfcode{pr}}{\emph{var}, \emph{message='`}}{}
print

\end{fulllineitems}


\end{fulllineitems}

\index{Visu\_Parameters (class in Visu.Load)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.Load.Visu_Parameters}\pysiglinewithargsret{\strong{class }\code{Visu.Load.}\bfcode{Visu\_Parameters}}{\emph{configfile=None}}{}
this class is a container for visualization parameters
\index{load() (Visu.Load.Visu\_Parameters method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.Load.Visu_Parameters.load}\pysiglinewithargsret{\bfcode{load}}{\emph{cp}}{}
Loads in self the information from the configfile.

\end{fulllineitems}

\index{pr() (Visu.Load.Visu\_Parameters method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.Load.Visu_Parameters.pr}\pysiglinewithargsret{\bfcode{pr}}{\emph{var}, \emph{message='`}}{}
print

\end{fulllineitems}

\index{report() (Visu.Load.Visu\_Parameters method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.Load.Visu_Parameters.report}\pysiglinewithargsret{\bfcode{report}}{}{}
Show all the parameters in self for the class Visu\_parameters.

\end{fulllineitems}


\end{fulllineitems}



\subsubsection{Visualization}
\label{rst/visu2d:visualization}

\paragraph{paramzoom}
\label{rst/visu2d:paramzoom}\label{rst/visu2d:module-Visu.paramzoom}\index{Visu.paramzoom (module)}\index{PARAM\_ZOOM (class in Visu.paramzoom)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.paramzoom.PARAM_ZOOM}\pysiglinewithargsret{\strong{class }\code{Visu.paramzoom.}\bfcode{PARAM\_ZOOM}}{\emph{data}}{}
Central object for zoom management.
\index{report() (Visu.paramzoom.PARAM\_ZOOM method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.paramzoom.PARAM_ZOOM.report}\pysiglinewithargsret{\bfcode{report}}{}{}
Report values for zoom, greyzoom, zoomready, movezoo etc..

\end{fulllineitems}

\index{zoom\_diag\_vector() (Visu.paramzoom.PARAM\_ZOOM method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.paramzoom.PARAM_ZOOM.zoom_diag_vector}\pysiglinewithargsret{\bfcode{zoom\_diag\_vector}}{}{}
Vector from diagonal for drag etc..

\end{fulllineitems}


\end{fulllineitems}



\paragraph{display}
\label{rst/visu2d:module-Visu.display}\label{rst/visu2d:display}\index{Visu.display (module)}\index{DISPLAY (class in Visu.display)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.display.DISPLAY}\pysiglinewithargsret{\strong{class }\code{Visu.display.}\bfcode{DISPLAY}}{\emph{QtMplCv}, \emph{data}, \emph{interface}, \emph{paramz}}{}
Fill Canvas with Matplotlib figures.
Handle connect disconnect.
\index{aff\_resolution() (Visu.display.DISPLAY method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.display.DISPLAY.aff_resolution}\pysiglinewithargsret{\bfcode{aff\_resolution}}{}{}
Shows the resolution in the interface.

\end{fulllineitems}

\index{affd() (Visu.display.DISPLAY method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.display.DISPLAY.affd}\pysiglinewithargsret{\bfcode{affd}}{\emph{d1}, \emph{d2}, \emph{layout1}, \emph{layout2=None}, \emph{zoom=True}, \emph{message=None}}{}
Routine to show the Mpl in qt zoom in main window and global window
d1 and d2 are the data to be plotted.

\end{fulllineitems}

\index{affi() (Visu.display.DISPLAY method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.display.DISPLAY.affi}\pysiglinewithargsret{\bfcode{affi}}{\emph{canvas}, \emph{d}}{}
Routine to print the 2d datas in Qt embedded environment
It uses the coordinates of the zoom for a given resolution.

\end{fulllineitems}

\index{affichd() (Visu.display.DISPLAY method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.display.DISPLAY.affichd}\pysiglinewithargsret{\bfcode{affichd}}{\emph{canvas}, \emph{d}, \emph{zoom=True}}{}
Makes the display with NPKv2.

\end{fulllineitems}

\index{afflistco() (Visu.display.DISPLAY method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.display.DISPLAY.afflistco}\pysiglinewithargsret{\bfcode{afflistco}}{}{}
Prints the element of listco containing (zoom, resolution, scale)
at position self.paramz.listview\_index.

\end{fulllineitems}

\index{change\_resolution() (Visu.display.DISPLAY method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.display.DISPLAY.change_resolution}\pysiglinewithargsret{\bfcode{change\_resolution}}{\emph{layout1=None}, \emph{layout2=None}}{}
Changes the resolution.
self.currentd is selected according to vis.resolu.

\end{fulllineitems}

\index{connect() (Visu.display.DISPLAY method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.display.DISPLAY.connect}\pysiglinewithargsret{\bfcode{connect}}{\emph{event}, \emph{action}, \emph{window='C'}}{}
Connect

\end{fulllineitems}

\index{disconnect() (Visu.display.DISPLAY method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.display.DISPLAY.disconnect}\pysiglinewithargsret{\bfcode{disconnect}}{\emph{object\_action}, \emph{window='C'}}{}
Disconnect

\end{fulllineitems}

\index{distrib() (Visu.display.DISPLAY method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.display.DISPLAY.distrib}\pysiglinewithargsret{\bfcode{distrib}}{\emph{f}, \emph{arg}}{}
Applying f to pairs of arg.

\end{fulllineitems}

\index{list\_res() (Visu.display.DISPLAY method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.display.DISPLAY.list_res}\pysiglinewithargsret{\bfcode{list\_res}}{}{}
Make list with the resolutions

\end{fulllineitems}

\index{local\_abs\_max() (Visu.display.DISPLAY method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.display.DISPLAY.local_abs_max}\pysiglinewithargsret{\bfcode{local\_abs\_max}}{}{}
maximum from local view

\end{fulllineitems}

\index{message() (Visu.display.DISPLAY method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.display.DISPLAY.message}\pysiglinewithargsret{\bfcode{message}}{\emph{message}, \emph{posx=None}, \emph{posy=None}, \emph{colorlab=(1.0}, \emph{0.7}, \emph{0.7)}}{}
function to label the peaks

\end{fulllineitems}

\index{multzoom\_coord() (Visu.display.DISPLAY method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.display.DISPLAY.multzoom_coord}\pysiglinewithargsret{\bfcode{multzoom\_coord}}{\emph{alpha}, \emph{beta}}{}
change the coordinates of the window with different
factors (alpha, beta) according to the direction.

\end{fulllineitems}

\index{pr() (Visu.display.DISPLAY method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.display.DISPLAY.pr}\pysiglinewithargsret{\bfcode{pr}}{\emph{var}, \emph{message='`}}{}
print

\end{fulllineitems}

\index{register\_coordinates() (Visu.display.DISPLAY method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.display.DISPLAY.register_coordinates}\pysiglinewithargsret{\bfcode{register\_coordinates}}{}{}
Keeps in a list ``self.paramz.listview'' the zooms coordinates and the associated resolutions.

\end{fulllineitems}

\index{res2dd() (Visu.display.DISPLAY method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.display.DISPLAY.res2dd}\pysiglinewithargsret{\bfcode{res2dd}}{}{}
Function to load the resolution from the current vis.resolu name

\end{fulllineitems}

\index{right\_order\_coord() (Visu.display.DISPLAY method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.display.DISPLAY.right_order_coord}\pysiglinewithargsret{\bfcode{right\_order\_coord}}{\emph{llx}, \emph{lly}, \emph{urx}, \emph{ury}}{}
Restablishes right order for coordinates.

\end{fulllineitems}

\index{select\_best\_resolution() (Visu.display.DISPLAY method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.display.DISPLAY.select_best_resolution}\pysiglinewithargsret{\bfcode{select\_best\_resolution}}{}{}
In function of the size of the zoom chose the best resolution.

\end{fulllineitems}

\index{set\_canvasC() (Visu.display.DISPLAY method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.display.DISPLAY.set_canvasC}\pysiglinewithargsret{\bfcode{set\_canvasC}}{}{}
Makes the canvas C

\end{fulllineitems}

\index{set\_canvasD() (Visu.display.DISPLAY method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.display.DISPLAY.set_canvasD}\pysiglinewithargsret{\bfcode{set\_canvasD}}{}{}
Makes the canvas D

\end{fulllineitems}

\index{setcursor() (Visu.display.DISPLAY method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.display.DISPLAY.setcursor}\pysiglinewithargsret{\bfcode{setcursor}}{\emph{name}, \emph{window='C'}}{}
Set the type of cursor used.

\end{fulllineitems}

\index{zoom\_area() (Visu.display.DISPLAY method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.display.DISPLAY.zoom_area}\pysiglinewithargsret{\bfcode{zoom\_area}}{}{}
Calculates area from zoom coordinates.

\end{fulllineitems}


\end{fulllineitems}



\paragraph{canvas\_event}
\label{rst/visu2d:module-Visu.canvas_event}\label{rst/visu2d:canvas-event}\index{Visu.canvas\_event (module)}\index{CANVAS\_EVENT (class in Visu.canvas\_event)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.canvas_event.CANVAS_EVENT}\pysiglinewithargsret{\strong{class }\code{Visu.canvas\_event.}\bfcode{CANVAS\_EVENT}}{\emph{display}, \emph{interf}, \emph{data}, \emph{paramz}, \emph{gtools}, \emph{convert}, \emph{stools}, \emph{mwind}, \emph{zoom}}{}
Handle Events in the Canvas.
\index{aff\_param() (Visu.canvas\_event.CANVAS\_EVENT method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.canvas_event.CANVAS_EVENT.aff_param}\pysiglinewithargsret{\bfcode{aff\_param}}{}{}
Show resolution and print coordinates in lineEdit.

\end{fulllineitems}

\index{detect\_corner() (Visu.canvas\_event.CANVAS\_EVENT method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.canvas_event.CANVAS_EVENT.detect_corner}\pysiglinewithargsret{\bfcode{detect\_corner}}{\emph{event}}{}
detect position for stretching window and put the good mouse's shape

\end{fulllineitems}

\index{interact\_with\_canvasC() (Visu.canvas\_event.CANVAS\_EVENT method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.canvas_event.CANVAS_EVENT.interact_with_canvasC}\pysiglinewithargsret{\bfcode{interact\_with\_canvasC}}{}{}
Connects event to canvas C. Press, release, corner detection.

\end{fulllineitems}

\index{make\_coord\_manual() (Visu.canvas\_event.CANVAS\_EVENT method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.canvas_event.CANVAS_EVENT.make_coord_manual}\pysiglinewithargsret{\bfcode{make\_coord\_manual}}{}{}
Mouse coordinates are automatically written in the interface for manual interaction.

\end{fulllineitems}

\index{on\_motion() (Visu.canvas\_event.CANVAS\_EVENT method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.canvas_event.CANVAS_EVENT.on_motion}\pysiglinewithargsret{\bfcode{on\_motion}}{\emph{event}}{}
Activate on mouse motion.

\end{fulllineitems}

\index{on\_press() (Visu.canvas\_event.CANVAS\_EVENT method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.canvas_event.CANVAS_EVENT.on_press}\pysiglinewithargsret{\bfcode{on\_press}}{\emph{event}}{}
When pressed, triggers the rectangle drawing
Waits for the mouse button's release to make the zoom. 
Calls self.on\_press\_D\_event and self.on\_press\_C\_event

\end{fulllineitems}

\index{on\_press\_C\_event() (Visu.canvas\_event.CANVAS\_EVENT method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.canvas_event.CANVAS_EVENT.on_press_C_event}\pysiglinewithargsret{\bfcode{on\_press\_C\_event}}{\emph{event}, \emph{xpress}, \emph{ypress}}{}
Makes the drawing of the zoom window in the layout C.
If a click is produced again in the window, it makes the zoom.

\end{fulllineitems}

\index{on\_press\_D\_event() (Visu.canvas\_event.CANVAS\_EVENT method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.canvas_event.CANVAS_EVENT.on_press_D_event}\pysiglinewithargsret{\bfcode{on\_press\_D\_event}}{\emph{event}, \emph{xpress}, \emph{ypress}}{}
Permits to interact with the zoom in window D.

\end{fulllineitems}

\index{on\_release() (Visu.canvas\_event.CANVAS\_EVENT method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.canvas_event.CANVAS_EVENT.on_release}\pysiglinewithargsret{\bfcode{on\_release}}{\emph{event}}{}
On release keep the rectangle and makes the zoom
on\_released is used to make lines .
self.paramz.listview, list of all the zooms.

\end{fulllineitems}

\index{on\_release\_C\_event() (Visu.canvas\_event.CANVAS\_EVENT method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.canvas_event.CANVAS_EVENT.on_release_C_event}\pysiglinewithargsret{\bfcode{on\_release\_C\_event}}{\emph{dx}, \emph{dy}}{}
Release C event

\end{fulllineitems}

\index{on\_release\_D\_event() (Visu.canvas\_event.CANVAS\_EVENT method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.canvas_event.CANVAS_EVENT.on_release_D_event}\pysiglinewithargsret{\bfcode{on\_release\_D\_event}}{}{}
Release D event

\end{fulllineitems}

\index{pr() (Visu.canvas\_event.CANVAS\_EVENT method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.canvas_event.CANVAS_EVENT.pr}\pysiglinewithargsret{\bfcode{pr}}{\emph{var}, \emph{message='`}}{}
print

\end{fulllineitems}

\index{recupxy() (Visu.canvas\_event.CANVAS\_EVENT method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.canvas_event.CANVAS_EVENT.recupxy}\pysiglinewithargsret{\bfcode{recupxy}}{\emph{event}}{}
Take the event coordinates and transform from ``m/z'' to ``point'' if necessary.

\end{fulllineitems}

\index{release\_refrechC() (Visu.canvas\_event.CANVAS\_EVENT method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.canvas_event.CANVAS_EVENT.release_refrechC}\pysiglinewithargsret{\bfcode{release\_refrechC}}{\emph{name\_profile=None}}{}
When mouse is released, refreshes layout C.

\end{fulllineitems}


\end{fulllineitems}



\paragraph{canvas}
\label{rst/visu2d:canvas}\label{rst/visu2d:module-Visu.canvas}\index{Visu.canvas (module)}\index{Qt4MplCanvas (class in Visu.canvas)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.canvas.Qt4MplCanvas}\pysiglinewithargsret{\strong{class }\code{Visu.canvas.}\bfcode{Qt4MplCanvas}}{\emph{parent}, \emph{paramz}}{}
Class for integrating Matplotlib in Qt
\index{contextMenuEvent() (Visu.canvas.Qt4MplCanvas method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.canvas.Qt4MplCanvas.contextMenuEvent}\pysiglinewithargsret{\bfcode{contextMenuEvent}}{\emph{event}}{}
Context menu

\end{fulllineitems}

\index{pr() (Visu.canvas.Qt4MplCanvas method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.canvas.Qt4MplCanvas.pr}\pysiglinewithargsret{\bfcode{pr}}{\emph{var}, \emph{message='`}}{}
print

\end{fulllineitems}


\end{fulllineitems}



\paragraph{convert}
\label{rst/visu2d:convert}\label{rst/visu2d:module-Visu.convert}\index{Visu.convert (module)}\index{CONVERT (class in Visu.convert)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.convert.CONVERT}\pysiglinewithargsret{\strong{class }\code{Visu.convert.}\bfcode{CONVERT}}{\emph{display}, \emph{data}, \emph{paramz}}{}
Conversion between m/z and points.
\index{itomz\_all() (Visu.convert.CONVERT method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.convert.CONVERT.itomz_all}\pysiglinewithargsret{\bfcode{itomz\_all}}{\emph{d}, \emph{llx}, \emph{lly}, \emph{urx}, \emph{ury}}{}
transforming from ``point'' coordinates to ``mz'' coordinates.

\end{fulllineitems}

\index{maxres() (Visu.convert.CONVERT method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.convert.CONVERT.maxres}\pysiglinewithargsret{\bfcode{maxres}}{\emph{llx}, \emph{lly}, \emph{urx}, \emph{ury}}{}
If mode point, converts to coordinates with maximal resolution

\end{fulllineitems}

\index{mztoi() (Visu.convert.CONVERT method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.convert.CONVERT.mztoi}\pysiglinewithargsret{\bfcode{mztoi}}{\emph{d}, \emph{coorr}, \emph{ax}}{}
mz to point for each coordinate

\end{fulllineitems}

\index{mztoi\_all() (Visu.convert.CONVERT method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.convert.CONVERT.mztoi_all}\pysiglinewithargsret{\bfcode{mztoi\_all}}{\emph{d}, \emph{llx}, \emph{lly}, \emph{urx}, \emph{ury}}{}
transforming from ``m/z'' coordinate to ``point'' coordinates of coorr (zoom window)

\end{fulllineitems}

\index{pass\_to\_curr\_mode() (Visu.convert.CONVERT method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.convert.CONVERT.pass_to_curr_mode}\pysiglinewithargsret{\bfcode{pass\_to\_curr\_mode}}{\emph{llx}, \emph{lly}, \emph{urx}, \emph{ury}}{}
If in mz/mode pass coordinates in ``m/z mode'', if in point mode pass the coordinates in ``point mode''.

\end{fulllineitems}

\index{pass\_to\_pt() (Visu.convert.CONVERT method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.convert.CONVERT.pass_to_pt}\pysiglinewithargsret{\bfcode{pass\_to\_pt}}{\emph{llx}, \emph{lly}, \emph{urx}, \emph{ury}}{}
transforming from point coordinate to m/z coordinates with mode point or m/z conditon

\end{fulllineitems}

\index{pr() (Visu.convert.CONVERT method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.convert.CONVERT.pr}\pysiglinewithargsret{\bfcode{pr}}{\emph{var}, \emph{message='`}}{}
print

\end{fulllineitems}

\index{set() (Visu.convert.CONVERT method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.convert.CONVERT.set}\pysiglinewithargsret{\bfcode{set}}{\emph{xa}, \emph{ya}, \emph{xb}, \emph{yb}}{}
Setter to put the coordinate in the right order and avoid having values outside.

\end{fulllineitems}

\index{to\_npk() (Visu.convert.CONVERT method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.convert.CONVERT.to_npk}\pysiglinewithargsret{\bfcode{to\_npk}}{}{}
return npk formated zoom

\end{fulllineitems}


\end{fulllineitems}



\paragraph{Matplotlib\_generictools}
\label{rst/visu2d:module-Visu.Matplotlib_generictools}\label{rst/visu2d:matplotlib-generictools}\index{Visu.Matplotlib\_generictools (module)}

\paragraph{profile\_popup}
\label{rst/visu2d:module-Visu.profile_popup}\label{rst/visu2d:profile-popup}\index{Visu.profile\_popup (module)}\index{Dialog (class in Visu.profile\_popup)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.profile_popup.Dialog}\pysiglinewithargsret{\strong{class }\code{Visu.profile\_popup.}\bfcode{Dialog}}{\emph{data}, \emph{save}, \emph{toolbar}}{}
Dialog box for saving CSV and PDF files.
\index{open\_file\_dialog() (Visu.profile\_popup.Dialog method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.profile_popup.Dialog.open_file_dialog}\pysiglinewithargsret{\bfcode{open\_file\_dialog}}{\emph{kind\_saved}}{}
Opens a file dialog 
Permits to save CSV and PDF.

\end{fulllineitems}

\index{pr() (Visu.profile\_popup.Dialog method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.profile_popup.Dialog.pr}\pysiglinewithargsret{\bfcode{pr}}{\emph{var}, \emph{message='`}}{}
print

\end{fulllineitems}


\end{fulllineitems}

\index{NavigToolbar (class in Visu.profile\_popup)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.profile_popup.NavigToolbar}\pysiglinewithargsret{\strong{class }\code{Visu.profile\_popup.}\bfcode{NavigToolbar}}{\emph{canvas}, \emph{parent}, \emph{data}, \emph{save}, \emph{fig}, \emph{axes}, \emph{name\_profile}, \emph{namefile}}{}
Customized navigation toolbar with CSV and PDF added functions.
\index{Button\_template() (Visu.profile\_popup.NavigToolbar method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.profile_popup.NavigToolbar.Button_template}\pysiglinewithargsret{\bfcode{Button\_template}}{\emph{add\_icon}, \emph{action}}{}
General Button template. 
Used in custom\_button\_csv and custom\_button\_pdf

\end{fulllineitems}

\index{custom\_button\_csv() (Visu.profile\_popup.NavigToolbar method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.profile_popup.NavigToolbar.custom_button_csv}\pysiglinewithargsret{\bfcode{custom\_button\_csv}}{}{}
Button for saving as CSV. 
Makes double columns CSV files using NPKv2 csv code.

\end{fulllineitems}

\index{custom\_button\_fullscale() (Visu.profile\_popup.NavigToolbar method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.profile_popup.NavigToolbar.custom_button_fullscale}\pysiglinewithargsret{\bfcode{custom\_button\_fullscale}}{}{}
Button for rescalling at fullscale.

\end{fulllineitems}

\index{custom\_button\_pdf() (Visu.profile\_popup.NavigToolbar method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.profile_popup.NavigToolbar.custom_button_pdf}\pysiglinewithargsret{\bfcode{custom\_button\_pdf}}{}{}
Button for saving PDFs.

\end{fulllineitems}

\index{pr() (Visu.profile\_popup.NavigToolbar method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.profile_popup.NavigToolbar.pr}\pysiglinewithargsret{\bfcode{pr}}{\emph{var}, \emph{message='`}}{}
print

\end{fulllineitems}


\end{fulllineitems}

\index{PROFILE (class in Visu.profile\_popup)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.profile_popup.PROFILE}\pysiglinewithargsret{\strong{class }\code{Visu.profile\_popup.}\bfcode{PROFILE}}{\emph{data\_profile}, \emph{save}, \emph{name\_profile}, \emph{namefile}, \emph{ptlx=None}}{}
Popup window for the profiles.
Creates a QMainWindow in which is made a customized toolbar.
-Possible to save in PDF, CSV
-Function for having full scale.
\index{axes\_mz() (Visu.profile\_popup.PROFILE method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.profile_popup.PROFILE.axes_mz}\pysiglinewithargsret{\bfcode{axes\_mz}}{\emph{data}}{}
Calculates axes in the case of x or y profile.

\end{fulllineitems}

\index{make\_window() (Visu.profile\_popup.PROFILE method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.profile_popup.PROFILE.make_window}\pysiglinewithargsret{\bfcode{make\_window}}{}{}
Makes the profile window

\end{fulllineitems}

\index{plot\_profile() (Visu.profile\_popup.PROFILE method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.profile_popup.PROFILE.plot_profile}\pysiglinewithargsret{\bfcode{plot\_profile}}{}{}
Plots the profile in the window

\end{fulllineitems}

\index{pr() (Visu.profile\_popup.PROFILE method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.profile_popup.PROFILE.pr}\pysiglinewithargsret{\bfcode{pr}}{\emph{var}, \emph{message='`}}{}
print

\end{fulllineitems}

\index{prepare\_window() (Visu.profile\_popup.PROFILE method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.profile_popup.PROFILE.prepare_window}\pysiglinewithargsret{\bfcode{prepare\_window}}{}{}
Prepares the window with name, size, canvas

\end{fulllineitems}


\end{fulllineitems}

\index{profile\_popup() (in module Visu.profile\_popup)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.profile_popup.profile_popup}\pysiglinewithargsret{\code{Visu.profile\_popup.}\bfcode{profile\_popup}}{\emph{data}}{}
\end{fulllineitems}



\paragraph{zooming}
\label{rst/visu2d:zooming}\label{rst/visu2d:module-Visu.zooming}\index{Visu.zooming (module)}\index{ZOOM3D (class in Visu.zooming)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.zooming.ZOOM3D}\pysigline{\strong{class }\code{Visu.zooming.}\bfcode{ZOOM3D}}
Zoom 3D
\index{drawrect() (Visu.zooming.ZOOM3D method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.zooming.ZOOM3D.drawrect}\pysiglinewithargsret{\bfcode{drawrect}}{\emph{llx}, \emph{lly}, \emph{urx}, \emph{ury}}{}
Draws rectangle for showing the area where the 3D is performed.

\end{fulllineitems}

\index{make\_mz\_xyz() (Visu.zooming.ZOOM3D method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.zooming.ZOOM3D.make_mz_xyz}\pysiglinewithargsret{\bfcode{make\_mz\_xyz}}{\emph{d}, \emph{pt1min}, \emph{pt1max}, \emph{pt2min}, \emph{pt2max}}{}
From the resolution d and frequency coordinates,
returns the m/z coordinates x, y, z for making the irregular meshgrid.

\end{fulllineitems}

\index{makemesh() (Visu.zooming.ZOOM3D method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.zooming.ZOOM3D.makemesh}\pysiglinewithargsret{\bfcode{makemesh}}{\emph{d}, \emph{pt1min}, \emph{pt1max}, \emph{pt2min}, \emph{pt2max}}{}
from frequencies limits pt1min, pt1max, pt2min, pt2max, makes the 3D mesh X, Y, Z.
Calls make\_mz\_xyz() then makemeshfromirreg().

\end{fulllineitems}

\index{makemeshfromirreg() (Visu.zooming.ZOOM3D method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.zooming.ZOOM3D.makemeshfromirreg}\pysiglinewithargsret{\bfcode{makemeshfromirreg}}{\emph{x}, \emph{y}, \emph{z}, \emph{sizef1}, \emph{sizef2}}{}
Makes the meshgrid from irregular mesh (x, y) in m/z coordinates.
Called after make\_mz\_xyz()

\end{fulllineitems}

\index{plotregion3d() (Visu.zooming.ZOOM3D method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.zooming.ZOOM3D.plotregion3d}\pysiglinewithargsret{\bfcode{plotregion3d}}{\emph{d}, \emph{pt1min}, \emph{pt1max}, \emph{pt2min}, \emph{pt2max}, \emph{visible=False}}{}
Makes the 3D plot from the meshgrid.
Makes the json that is read by FTICR2D\_3d.html

\end{fulllineitems}

\index{pr() (Visu.zooming.ZOOM3D method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.zooming.ZOOM3D.pr}\pysiglinewithargsret{\bfcode{pr}}{\emph{var}, \emph{message='`}}{}
print

\end{fulllineitems}


\end{fulllineitems}

\index{ZOOMING (class in Visu.zooming)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.zooming.ZOOMING}\pysiglinewithargsret{\strong{class }\code{Visu.zooming.}\bfcode{ZOOMING}}{\emph{display}, \emph{interf}, \emph{data}, \emph{paramz}, \emph{gtools}, \emph{convert}, \emph{stools}, \emph{mwind}}{}
Zoom and draw a rectangle around the zooming area
The coordinates are in ``point'' format at the root of the treatment
so as to simplify all the procedure.
\index{change\_view() (Visu.zooming.ZOOMING method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.zooming.ZOOMING.change_view}\pysiglinewithargsret{\bfcode{change\_view}}{\emph{change\_layoutD=False}}{}
Changes views.

\end{fulllineitems}

\index{change\_view\_from\_list() (Visu.zooming.ZOOMING method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.zooming.ZOOMING.change_view_from_list}\pysiglinewithargsret{\bfcode{change\_view\_from\_list}}{}{}
Refreshes views from history.

\end{fulllineitems}

\index{change\_zoom() (Visu.zooming.ZOOMING method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.zooming.ZOOMING.change_zoom}\pysiglinewithargsret{\bfcode{change\_zoom}}{}{}
Makes zoom and resolution if necessary, condition = self.areazoom() \textgreater{}= AREAMIN
Keeps both zoom and resolution in a list.
vis.resolu is the name of the current resolution.

\end{fulllineitems}

\index{debug\_trig() (Visu.zooming.ZOOMING method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.zooming.ZOOMING.debug_trig}\pysiglinewithargsret{\bfcode{debug\_trig}}{}{}
Debug for canvas event

\end{fulllineitems}

\index{find\_numbpix() (Visu.zooming.ZOOMING method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.zooming.ZOOMING.find_numbpix}\pysiglinewithargsret{\bfcode{find\_numbpix}}{}{}
Numper of pixels in the zoom area.

\end{fulllineitems}

\index{on\_scroll() (Visu.zooming.ZOOMING method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.zooming.ZOOMING.on_scroll}\pysiglinewithargsret{\bfcode{on\_scroll}}{\emph{event}}{}
Use of scrolling function to control the level

\end{fulllineitems}

\index{plot\_zooms() (Visu.zooming.ZOOMING method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.zooming.ZOOMING.plot_zooms}\pysiglinewithargsret{\bfcode{plot\_zooms}}{}{}
Calculates the coordinates of the zoom and prints in both windows

\end{fulllineitems}

\index{pr() (Visu.zooming.ZOOMING method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.zooming.ZOOMING.pr}\pysiglinewithargsret{\bfcode{pr}}{\emph{var}, \emph{message='`}}{}
print

\end{fulllineitems}

\index{press\_zoom() (Visu.zooming.ZOOMING method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.zooming.ZOOMING.press_zoom}\pysiglinewithargsret{\bfcode{press\_zoom}}{\emph{xpress}, \emph{ypress}}{}
Zoom activated or not after pressing the left mouse button

\end{fulllineitems}

\index{press\_zoomready\_and\_in() (Visu.zooming.ZOOMING method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.zooming.ZOOMING.press_zoomready_and_in}\pysiglinewithargsret{\bfcode{press\_zoomready\_and\_in}}{}{}
Activated when zoom is ready and pressed is in the zoom window.

\end{fulllineitems}

\index{press\_zoomready\_and\_out() (Visu.zooming.ZOOMING method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.zooming.ZOOMING.press_zoomready_and_out}\pysiglinewithargsret{\bfcode{press\_zoomready\_and\_out}}{}{}
Activated when zoom is ready an pressed is outside the zoom window

\end{fulllineitems}

\index{stretchrect() (Visu.zooming.ZOOMING method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.zooming.ZOOMING.stretchrect}\pysiglinewithargsret{\bfcode{stretchrect}}{\emph{dx}, \emph{dy}}{}
function to stretch the zoom by taking the corners

\end{fulllineitems}

\index{zoom\_check\_size() (Visu.zooming.ZOOMING method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.zooming.ZOOMING.zoom_check_size}\pysiglinewithargsret{\bfcode{zoom\_check\_size}}{}{}
If zoom too small reinitializes ie self.paramz.zoom\_coord = {[}{]}, disconnects the mouse
and sets flag self.newrectcready to True

\end{fulllineitems}


\end{fulllineitems}



\paragraph{zoom\_plot}
\label{rst/visu2d:module-Visu.zoom_plot}\label{rst/visu2d:zoom-plot}\index{Visu.zoom\_plot (module)}\index{ZOOM\_PLOT (class in Visu.zoom\_plot)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.zoom_plot.ZOOM_PLOT}\pysiglinewithargsret{\strong{class }\code{Visu.zoom\_plot.}\bfcode{ZOOM\_PLOT}}{\emph{display}, \emph{interf}, \emph{data}, \emph{paramz}, \emph{gtools}}{}
Makes the zoom rectangles for C and D window and the greyarea.
\index{drawrect() (Visu.zoom\_plot.ZOOM\_PLOT method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.zoom_plot.ZOOM_PLOT.drawrect}\pysiglinewithargsret{\bfcode{drawrect}}{\emph{llx}, \emph{lly}, \emph{urx}, \emph{ury}, \emph{layout1=None}, \emph{layout2=None}}{}
Draws rectangles with absolute coordinates llx, lly, urx, ury in C and D windows

\end{fulllineitems}

\index{drawrectC() (Visu.zoom\_plot.ZOOM\_PLOT method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.zoom_plot.ZOOM_PLOT.drawrectC}\pysiglinewithargsret{\bfcode{drawrectC}}{\emph{llx}, \emph{lly}, \emph{urx}, \emph{ury}, \emph{layout1=None}}{}
Draws the zoom rectangle in the C windows

\end{fulllineitems}

\index{drawrectD() (Visu.zoom\_plot.ZOOM\_PLOT method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.zoom_plot.ZOOM_PLOT.drawrectD}\pysiglinewithargsret{\bfcode{drawrectD}}{\emph{llx}, \emph{lly}, \emph{urx}, \emph{ury}, \emph{layout2=None}}{}
Draws the zoom rectangle in the D windows

\end{fulllineitems}

\index{greyzoom() (Visu.zoom\_plot.ZOOM\_PLOT method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.zoom_plot.ZOOM_PLOT.greyzoom}\pysiglinewithargsret{\bfcode{greyzoom}}{\emph{llx}, \emph{lly}, \emph{urx}, \emph{ury}}{}
Grey area around the zoom

\end{fulllineitems}

\index{pr() (Visu.zoom\_plot.ZOOM\_PLOT method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.zoom_plot.ZOOM_PLOT.pr}\pysiglinewithargsret{\bfcode{pr}}{\emph{var}, \emph{message='`}}{}
print

\end{fulllineitems}


\end{fulllineitems}



\paragraph{zoom\_tools}
\label{rst/visu2d:module-Visu.zoom_tools}\label{rst/visu2d:zoom-tools}\index{Visu.zoom\_tools (module)}

\paragraph{label\_2D}
\label{rst/visu2d:module-Visu.label_2D}\label{rst/visu2d:label-2d}\index{Visu.label\_2D (module)}
Illustrate simple contour plotting, contours on an image with
a colorbar for the contours, and labelled contours.

See also contour\_image.py.
\index{PEAKPICK (class in Visu.label\_2D)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.label_2D.PEAKPICK}\pysiglinewithargsret{\strong{class }\code{Visu.label\_2D.}\bfcode{PEAKPICK}}{\emph{data}, \emph{display}, \emph{convert}, \emph{paramz}}{}
Peakpicking
\index{baryc\_far() (Visu.label\_2D.PEAKPICK method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.label_2D.PEAKPICK.baryc_far}\pysiglinewithargsret{\bfcode{baryc\_far}}{}{}
Makes the points far from the self.barycenter.
self.lx, self.ly defined from a small division fo the window dimensions.

\end{fulllineitems}

\index{barycenter\_method() (Visu.label\_2D.PEAKPICK method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.label_2D.PEAKPICK.barycenter_method}\pysiglinewithargsret{\bfcode{barycenter\_method}}{}{}
Takes the labels far one from another and all the labels far from the peaks
1) Begins by  making a self.barycenter and getting the labels at the opposite of the vector `peak to self.barycenter' 
at the distance dist\_min.
2) Makes a correction on the labels ovelapping the peaks
3) Makes a correction on the labels ovelapping each other.

\end{fulllineitems}

\index{correc\_label\_label() (Visu.label\_2D.PEAKPICK method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.label_2D.PEAKPICK.correc_label_label}\pysiglinewithargsret{\bfcode{correc\_label\_label}}{\emph{correct}}{}
Correction between labels

\end{fulllineitems}

\index{correc\_peak\_label() (Visu.label\_2D.PEAKPICK method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.label_2D.PEAKPICK.correc_peak_label}\pysiglinewithargsret{\bfcode{correc\_peak\_label}}{\emph{correct}}{}
Correction between peaks and labels

\end{fulllineitems}

\index{decrossing() (Visu.label\_2D.PEAKPICK method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.label_2D.PEAKPICK.decrossing}\pysiglinewithargsret{\bfcode{decrossing}}{}{}
Avoidance of arrow crossing.

\end{fulllineitems}

\index{find\_peaks() (Visu.label\_2D.PEAKPICK method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.label_2D.PEAKPICK.find_peaks}\pysiglinewithargsret{\bfcode{find\_peaks}}{\emph{thresh}, \emph{zoom}, \emph{maxpeaks}}{}
Find the peaks in the 2D dataset.

\end{fulllineitems}

\index{get\_far() (Visu.label\_2D.PEAKPICK method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.label_2D.PEAKPICK.get_far}\pysiglinewithargsret{\bfcode{get\_far}}{\emph{method='barycenter'}}{}
Take the labels far one from another and from peaks
Two methods: barycenter

\end{fulllineitems}

\index{make\_labels() (Visu.label\_2D.PEAKPICK method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.label_2D.PEAKPICK.make_labels}\pysiglinewithargsret{\bfcode{make\_labels}}{\emph{method='barycenter'}}{}
Finds positions of the labels and plots.
self.lx, self.ly defined from dimension of the window.

\end{fulllineitems}

\index{peaklabel() (Visu.label\_2D.PEAKPICK method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.label_2D.PEAKPICK.peaklabel}\pysiglinewithargsret{\bfcode{peaklabel}}{\emph{i}}{}
function to label the peaks.
Plots the labels if the labels are not calculated outside the limited range.

\end{fulllineitems}

\index{pr() (Visu.label\_2D.PEAKPICK method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.label_2D.PEAKPICK.pr}\pysiglinewithargsret{\bfcode{pr}}{\emph{var}, \emph{message='`}}{}
print

\end{fulllineitems}

\index{test\_correct() (Visu.label\_2D.PEAKPICK method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.label_2D.PEAKPICK.test_correct}\pysiglinewithargsret{\bfcode{test\_correct}}{\emph{pt0}, \emph{pt1}, \emph{correct=False}, \emph{kind=None}}{}
correct permits to chose between correction (True) and simple test (False).. 
kind be set to `label\_label' or `peak\_label'

\end{fulllineitems}


\end{fulllineitems}



\subsubsection{Miscellaneous}
\label{rst/visu2d:miscellaneous}

\paragraph{Saving}
\label{rst/visu2d:module-Visu.Saving}\label{rst/visu2d:saving}\index{Visu.Saving (module)}\index{SAVE (class in Visu.Saving)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.Saving.SAVE}\pysiglinewithargsret{\strong{class }\code{Visu.Saving.}\bfcode{SAVE}}{\emph{data}}{}
Class for savings the 2D, 3D, profiles etc.. 
Permits to save the object in the same location : a directory named with the date etc..
\index{dir\_save() (Visu.Saving.SAVE method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.Saving.SAVE.dir_save}\pysiglinewithargsret{\bfcode{dir\_save}}{}{}
Makes a directory for the data if it doesn't exist
The directory is named with the day, the month, the year and the hour.

\end{fulllineitems}

\index{pr() (Visu.Saving.SAVE method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.Saving.SAVE.pr}\pysiglinewithargsret{\bfcode{pr}}{\emph{var}, \emph{message='`}}{}
print

\end{fulllineitems}

\index{prep\_path\_save() (Visu.Saving.SAVE method)}

\begin{fulllineitems}
\phantomsection\label{rst/visu2d:Visu.Saving.SAVE.prep_path_save}\pysiglinewithargsret{\bfcode{prep\_path\_save}}{\emph{namefile}}{}
prepares address path\_save.

\end{fulllineitems}


\end{fulllineitems}



\section{Processing 2D}
\label{rst/code:processing-2d}\label{rst/code:module-processing}\index{processing (module)}
Processing.py

This program realises the processing of an FTICR data

Created by Marc-Andre on 2011-09-23.
Copyright (c) 2011 IGBMC. All rights reserved.
\index{Proc\_Parameters (class in processing)}

\begin{fulllineitems}
\phantomsection\label{rst/code:processing.Proc_Parameters}\pysiglinewithargsret{\strong{class }\code{processing.}\bfcode{Proc\_Parameters}}{\emph{configfile=None}}{}
this class is a container for processing parameters
\index{load() (processing.Proc\_Parameters method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:processing.Proc_Parameters.load}\pysiglinewithargsret{\bfcode{load}}{\emph{cp}}{}
load from cp config file - should have been opened with ConfigParser() first

\end{fulllineitems}

\index{report() (processing.Proc\_Parameters method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:processing.Proc_Parameters.report}\pysiglinewithargsret{\bfcode{report}}{}{}
print a formatted report

\end{fulllineitems}


\end{fulllineitems}

\index{Test (class in processing)}

\begin{fulllineitems}
\phantomsection\label{rst/code:processing.Test}\pysiglinewithargsret{\strong{class }\code{processing.}\bfcode{Test}}{\emph{methodName='runTest'}}{}
tests
\index{test\_NUS() (processing.Test method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:processing.Test.test_NUS}\pysiglinewithargsret{\bfcode{test\_NUS}}{}{}
apply a complete NUS processing test

\end{fulllineitems}

\index{test\_intelli() (processing.Test method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:processing.Test.test_intelli}\pysiglinewithargsret{\bfcode{test\_intelli}}{}{}
testing `intelligent' rounding

\end{fulllineitems}

\index{test\_proc() (processing.Test method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:processing.Test.test_proc}\pysiglinewithargsret{\bfcode{test\_proc}}{}{}
apply a complete processing test

\end{fulllineitems}

\index{test\_zf() (processing.Test method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:processing.Test.test_zf}\pysiglinewithargsret{\bfcode{test\_zf}}{}{}
testing zerofilling computation

\end{fulllineitems}


\end{fulllineitems}

\index{apod() (in module processing)}

\begin{fulllineitems}
\phantomsection\label{rst/code:processing.apod}\pysiglinewithargsret{\code{processing.}\bfcode{apod}}{\emph{d}, \emph{size}, \emph{axis=0}}{}
apply sin 0.5 apodisation and change size

\end{fulllineitems}

\index{comp\_sizes() (in module processing)}

\begin{fulllineitems}
\phantomsection\label{rst/code:processing.comp_sizes}\pysiglinewithargsret{\code{processing.}\bfcode{comp\_sizes}}{\emph{d0}, \emph{zflist=None}, \emph{szmlist=None}, \emph{largest=8589934592}, \emph{sizemin=1024}, \emph{vignette=True}}{}~\begin{description}
\item[{return a list with data-sizes, computed either}] \leavevmode
zflist : from zerofilling index    eg : (1,0,-1)
szmlist : from multiplicant pairs  eg : (2,2)

\end{description}

largest determines the largest dataset allowed
sizemini determines the minimum size when downzerofilling
when vignette == True (default) a minimum size data (defined by sizemini) is appended to the list

\end{fulllineitems}

\index{do\_proc\_F1() (in module processing)}

\begin{fulllineitems}
\phantomsection\label{rst/code:processing.do_proc_F1}\pysiglinewithargsret{\code{processing.}\bfcode{do\_proc\_F1}}{\emph{dinp}, \emph{doutp}}{}
scan all cols of dinp, apply proc() and store into doutp

\end{fulllineitems}

\index{do\_proc\_F1\_flip\_modu() (in module processing)}

\begin{fulllineitems}
\phantomsection\label{rst/code:processing.do_proc_F1_flip_modu}\pysiglinewithargsret{\code{processing.}\bfcode{do\_proc\_F1\_flip\_modu}}{\emph{dinp}, \emph{doutp}, \emph{parameter}}{}
as do\_proc\_F1, but applies flip and then complex modulus() at the end

\end{fulllineitems}

\index{do\_proc\_F1\_modu() (in module processing)}

\begin{fulllineitems}
\phantomsection\label{rst/code:processing.do_proc_F1_modu}\pysiglinewithargsret{\code{processing.}\bfcode{do\_proc\_F1\_modu}}{\emph{dinp}, \emph{doutp}}{}
as do\_proc\_F1, but applies hypercomplex modulus() at the end

\end{fulllineitems}

\index{do\_proc\_F2() (in module processing)}

\begin{fulllineitems}
\phantomsection\label{rst/code:processing.do_proc_F2}\pysiglinewithargsret{\code{processing.}\bfcode{do\_proc\_F2}}{\emph{dinp}, \emph{doutp}}{}
scan all rows of dinp, apply proc() and store into doutp

\end{fulllineitems}

\index{do\_process2D() (in module processing)}

\begin{fulllineitems}
\phantomsection\label{rst/code:processing.do_process2D}\pysiglinewithargsret{\code{processing.}\bfcode{do\_process2D}}{\emph{dinp}, \emph{datatemp}, \emph{doutp}, \emph{parameter}}{}
apply the processing to an input 2D data set : dinp
result is found in an output file : doutp

dinp and doutp should have been created before, size of doutp will determine the processing
will use a temporay file if needed

\end{fulllineitems}

\index{downsample2D() (in module processing)}

\begin{fulllineitems}
\phantomsection\label{rst/code:processing.downsample2D}\pysiglinewithargsret{\code{processing.}\bfcode{downsample2D}}{\emph{data}, \emph{outp}, \emph{n1}, \emph{n2}}{}
takes data (a 2D) and generate a smaller dataset downsampled by factor (n1,n2) on each axis
then returned data-set is n1*n2 times smaller
- simply takes the mean
** Not fully tested on non powers of 2 **

\end{fulllineitems}

\index{intelliround() (in module processing)}

\begin{fulllineitems}
\phantomsection\label{rst/code:processing.intelliround}\pysiglinewithargsret{\code{processing.}\bfcode{intelliround}}{\emph{x}}{}
returns a number rounded to the nearest `round' (easy to FT) integer

\end{fulllineitems}

\index{interfproc (in module processing)}

\begin{fulllineitems}
\phantomsection\label{rst/code:processing.interfproc}\pysigline{\code{processing.}\bfcode{interfproc}\strong{ = False}}
Processing for performing urQRd and/or Fista on 2D FTICR datasets.
previous version was named processing2-urqrd-superresol
under Linux or MacOsX : mpirun -n nbproc python processing.py (configfile.mscf)
under Windows : mpiexec -n nbproc python processing.py (configfile.mscf)

\end{fulllineitems}

\index{iterarg() (in module processing)}

\begin{fulllineitems}
\phantomsection\label{rst/code:processing.iterarg}\pysiglinewithargsret{\code{processing.}\bfcode{iterarg}}{\emph{dinp}, \emph{rot}, \emph{size}, \emph{parameter}}{}
an iterator used by the processing to allow  multiprocessing or MPI set-up

\end{fulllineitems}

\index{load\_input() (in module processing)}

\begin{fulllineitems}
\phantomsection\label{rst/code:processing.load_input}\pysiglinewithargsret{\code{processing.}\bfcode{load\_input}}{\emph{name}}{}
load input file and returns it, in read-only mode

\end{fulllineitems}

\index{main() (in module processing)}

\begin{fulllineitems}
\phantomsection\label{rst/code:processing.main}\pysiglinewithargsret{\code{processing.}\bfcode{main}}{\emph{argv=None}}{}
Does the whole on-file processing, 
syntax is
processing.py {[} configuration\_file.mscf {]}
if no argument is given, the standard file : process.mscf is used.

\end{fulllineitems}

\index{pred\_sizes() (in module processing)}

\begin{fulllineitems}
\phantomsection\label{rst/code:processing.pred_sizes}\pysiglinewithargsret{\code{processing.}\bfcode{pred\_sizes}}{\emph{d0}, \emph{szmult=(1}, \emph{1)}, \emph{sizemin=1024}}{}~\begin{description}
\item[{given an input data set, determines the optimum size s1,s2 to process it}] \leavevmode
with a size multiplicant of szmult

\end{description}

szmult (szm1, szm2)     where szm1 is multiplicant for s1 and szm2 for s2
szmx = 1 : no change  /  2 : size doubling  /  0.5 : size halving
any strictly positive value is possible, 0.2 0.33 1.1 2 2.2 5 etc...

however, axes can never get smaller than sizemin
returns (si1, si2, ...) as the dataset dimension

\end{fulllineitems}

\index{pred\_sizes\_zf() (in module processing)}

\begin{fulllineitems}
\phantomsection\label{rst/code:processing.pred_sizes_zf}\pysiglinewithargsret{\code{processing.}\bfcode{pred\_sizes\_zf}}{\emph{d0}, \emph{zf=0}, \emph{sizemin=1024}}{}
given an input data set, determines the optimum size s1,s2 to process it with a zerofilling of zf
zf = +n is doubling n times along each axis
zf = -n is halving n times along each axis
zf = 0 is no zerofiling
however, axes can never get smaller than sizemin
returns (si1, si2, ...) as the dataset dimension

\end{fulllineitems}

\index{print\_time() (in module processing)}

\begin{fulllineitems}
\phantomsection\label{rst/code:processing.print_time}\pysiglinewithargsret{\code{processing.}\bfcode{print\_time}}{\emph{t}, \emph{st='Processing time'}}{}
prints processing time

\end{fulllineitems}



\section{Algorithms}
\label{rst/code:algorithms}

\subsection{urQRd}
\label{rst/code:urqrd}\label{rst/code:module-Algo.urQRd}\index{Algo.urQRd (module)}

\subsubsection{urQRd.py}
\label{rst/code:urqrd-py}
Algorithm for denoising time series, named urQRd (standing for ``uncoiled random QR denoising'')

main function is 
urQRd(data, rank)
data : the series to be denoised
rank : the rank of the analysis

Copyright (c) 2013 IGBMC. All rights reserved.
Marc-Andr'e Delsuc \textless{}\href{mailto:madelsuc@unistra.fr}{madelsuc@unistra.fr}\textgreater{}
Lionel Chiron \textless{}\href{mailto:lionel.chiron@gmail.com}{lionel.chiron@gmail.com}\textgreater{}

This software is a computer program whose purpose is to compute urQRd denoising.

This software is governed by the CeCILL  license under French law and
abiding by the rules of distribution of free software.  You can  use, 
modify and/ or redistribute the software under the terms of the CeCILL
license as circulated by CEA, CNRS and INRIA at the following URL
``\href{http://www.cecill.info}{http://www.cecill.info}''.

As a counterpart to the access to the source code and  rights to copy,
modify and redistribute granted by the license, users are provided only
with a limited warranty  and the software's author,  the holder of the
economic rights,  and the successive licensors  have only  limited
liability.

In this respect, the user's attention is drawn to the risks associated
with loading,  using,  modifying and/or developing or reproducing the
software by the user in light of its specific status of free software,
that may mean  that it is complicated to manipulate,  and  that  also
therefore means  that it is reserved for developers  and  experienced
professionals having in-depth computer knowledge. Users are therefore
encouraged to load and test the software's suitability as regards their
requirements in conditions enabling the security of their systems and/or 
data to be ensured and,  more generally, to use and operate it in the 
same conditions as regards security.

The fact that you are presently reading this means that you have had
knowledge of the CeCILL license and that you accept its terms.

Created by Lionel Chiron and Marc-Andr'e on 2013-10-13.

version 2.0 
28/oct/2013
\index{FastHankel\_prod\_mat\_mat() (in module Algo.urQRd)}

\begin{fulllineitems}
\phantomsection\label{rst/code:Algo.urQRd.FastHankel_prod_mat_mat}\pysiglinewithargsret{\code{Algo.urQRd.}\bfcode{FastHankel\_prod\_mat\_mat}}{\emph{gene\_vect}, \emph{matrix}}{}
Fast Hankel structured matrix matrix product based on FastHankel\_prod\_mat\_vec

\end{fulllineitems}

\index{FastHankel\_prod\_mat\_vec() (in module Algo.urQRd)}

\begin{fulllineitems}
\phantomsection\label{rst/code:Algo.urQRd.FastHankel_prod_mat_vec}\pysiglinewithargsret{\code{Algo.urQRd.}\bfcode{FastHankel\_prod\_mat\_vec}}{\emph{gene\_vect}, \emph{prod\_vect}}{}
Compute product of Hankel matrix (gene\_vect)  by vector prod\_vect.
H is not computed
M is the length of the result

\end{fulllineitems}

\index{Fast\_Hankel2dt() (in module Algo.urQRd)}

\begin{fulllineitems}
\phantomsection\label{rst/code:Algo.urQRd.Fast_Hankel2dt}\pysiglinewithargsret{\code{Algo.urQRd.}\bfcode{Fast\_Hankel2dt}}{\emph{Q}, \emph{QH}}{}
returning to data from Q and QstarH
Based on FastHankel\_prod\_mat\_vec.

\end{fulllineitems}

\index{urQRd() (in module Algo.urQRd)}

\begin{fulllineitems}
\phantomsection\label{rst/code:Algo.urQRd.urQRd}\pysiglinewithargsret{\code{Algo.urQRd.}\bfcode{urQRd}}{\emph{data}, \emph{k}, \emph{orda=None}, \emph{iterations=1}, \emph{optk=False}}{}
urQRd algorithm. Name stands for uncoiled random QR denoising.
From a data series return a denoised series denoised
data : the series to be denoised - a (normally complex) numpy buffer
k : the rank of the analysis
orda : is the order of the analysis
\begin{quote}

internally, a Hankel matrix (M,N) is constructed, with M = orda and N = len(data)-orda+1
if None (default) orda = (len(data)+1)/2
\end{quote}

iterations : the number of time the operation should be repeated

values are such that
orda \textless{}= (len(data)+1)/2
k \textless{} orda
N = len(data)-orda+1
Omega is (N x k)
\#\#\#\#\#\#\#\#\#\#
BECAREFUL datasize must be different from a product of primes !!!!!!..
a processing with a datasize of 120022 for example will be 50 times longer than
a procesing of a datasize of 120000.
\#\#\#\#\#\#\#\#\#\#

\end{fulllineitems}

\index{urQRdCore() (in module Algo.urQRd)}

\begin{fulllineitems}
\phantomsection\label{rst/code:Algo.urQRd.urQRdCore}\pysiglinewithargsret{\code{Algo.urQRd.}\bfcode{urQRdCore}}{\emph{data}, \emph{Omega}}{}
Core of urQRd algorithm

\end{fulllineitems}

\index{vec\_mean() (in module Algo.urQRd)}

\begin{fulllineitems}
\phantomsection\label{rst/code:Algo.urQRd.vec_mean}\pysiglinewithargsret{\code{Algo.urQRd.}\bfcode{vec\_mean}}{\emph{M}, \emph{L}}{}
Vector for calculating the mean from the sum on the antidiagonal.
data = vec\_sum*vec\_mean

\end{fulllineitems}



\subsection{Linpredic}
\label{rst/code:linpredic}\label{rst/code:module-Algo.Linpredic}\index{Algo.Linpredic (module)}
Adaptation of code from :

file              CollombBurg.py
author/translator Ernesto P. Adorio
\begin{quote}

UPDEPP (UP Clark)
\href{mailto:ernesto.adorio@gmail.com}{ernesto.adorio@gmail.com}
\end{quote}

Version           0.0.1 jun 11, 2010 \# first release.
References        Burg's Method, Algorithm and Recursion, pp. 9-11

Created by Lionel on 2011-09-18.
Removed the ``for loops'' so as to speed up using numpy capabilities.
Copyright (c) 2010 IGBMC. All rights reserved.
\index{LinpredTests (class in Algo.Linpredic)}

\begin{fulllineitems}
\phantomsection\label{rst/code:Algo.Linpredic.LinpredTests}\pysiglinewithargsret{\strong{class }\code{Algo.Linpredic.}\bfcode{LinpredTests}}{\emph{methodName='runTest'}}{}~\begin{itemize}
\item {} 
Testing linear prediction , Burg algorithm-

\end{itemize}
\index{test\_burg() (Algo.Linpredic.LinpredTests method)}

\begin{fulllineitems}
\phantomsection\label{rst/code:Algo.Linpredic.LinpredTests.test_burg}\pysiglinewithargsret{\bfcode{test\_burg}}{}{}~\begin{itemize}
\item {} 
testing burg algo -

\end{itemize}

\end{fulllineitems}


\end{fulllineitems}

\index{burg() (in module Algo.Linpredic)}

\begin{fulllineitems}
\phantomsection\label{rst/code:Algo.Linpredic.burg}\pysiglinewithargsret{\code{Algo.Linpredic.}\bfcode{burg}}{\emph{m}, \emph{x}}{}
Based on Collomb's C++ code, pp. 10-11
Burgs Method, algorithm and recursion
\begin{quote}

m - number of lags in autoregressive model.
x  - data vector to approximate.
\end{quote}

\end{fulllineitems}

\index{denoise() (in module Algo.Linpredic)}

\begin{fulllineitems}
\phantomsection\label{rst/code:Algo.Linpredic.denoise}\pysiglinewithargsret{\code{Algo.Linpredic.}\bfcode{denoise}}{\emph{data}, \emph{ar}}{}
returned a denoised version of ``data'', using ``ar'' polynomial
first len(ar) points are untouched.

\end{fulllineitems}

\index{predict() (in module Algo.Linpredic)}

\begin{fulllineitems}
\phantomsection\label{rst/code:Algo.Linpredic.predict}\pysiglinewithargsret{\code{Algo.Linpredic.}\bfcode{predict}}{\emph{data}, \emph{ar}, \emph{length}}{}
returns a vector with additional points, predicted at the end of ``data'' up to total size ``length'', using ``ar'' polynomial

\end{fulllineitems}



\chapter{Licenses}
\label{rst/licenses:licenses}\label{rst/licenses::doc}

\section{SPIKE License}
\label{rst/licenses:spike-license}
This software is governed by the CeCILL  license under French law and
abiding by the rules of distribution of free software.  You can  use,
modify and/ or redistribute the software under the terms of the CeCILL
license as circulated by CEA, CNRS and INRIA at the following URL
``\href{http://www.cecill.info}{http://www.cecill.info}''.

As a counterpart to the access to the source code and  rights to copy,
modify and redistribute granted by the license, users are provided only
with a limited warranty  and the software's author,  the holder of the
economic rights,  and the successive licensors  have only  limited
liability.

In this respect, the user's attention is drawn to the risks associated
with loading,  using,  modifying and/or developing or reproducing the
software by the user in light of its specific status of free software,
that may mean  that it is complicated to manipulate,  and  that  also
therefore means  that it is reserved for developers  and  experienced
professionals having in-depth computer knowledge. Users are therefore
encouraged to load and test the software's suitability as regards their
requirements in conditions enabling the security of their systems and/or
data to be ensured and,  more generally, to use and operate it in the
same conditions as regards security.

The fact that you are presently reading this means that you have had
knowledge of the CeCILL license and that you accept its terms.


\section{Secondary Licenses}
\label{rst/licenses:secondary-licenses}

\subsection{urQRd License}
\label{rst/licenses:urqrd-license}
Copyright (c) 2013 IGBMC. All rights reserved.
Marc-Andr'e Delsuc \textless{}\href{mailto:madelsuc@unistra.fr}{madelsuc@unistra.fr}\textgreater{}
Lionel Chiron \textless{}\href{mailto:lionel.chiron@gmail.com}{lionel.chiron@gmail.com}\textgreater{}

This software is a computer program whose purpose is to compute urQRd denoising.

This software is governed by the CeCILL  license under French law and
abiding by the rules of distribution of free software.  You can  use,
modify and/ or redistribute the software under the terms of the CeCILL
license as circulated by CEA, CNRS and INRIA at the following URL
``\href{http://www.cecill.info}{http://www.cecill.info}''.

As a counterpart to the access to the source code and  rights to copy,
modify and redistribute granted by the license, users are provided only
with a limited warranty  and the software's author,  the holder of the
economic rights,  and the successive licensors  have only  limited
liability.

In this respect, the user's attention is drawn to the risks associated
with loading,  using,  modifying and/or developing or reproducing the
software by the user in light of its specific status of free software,
that may mean  that it is complicated to manipulate,  and  that  also
therefore means  that it is reserved for developers  and  experienced
professionals having in-depth computer knowledge. Users are therefore
encouraged to load and test the software's suitability as regards their
requirements in conditions enabling the security of their systems and/or
data to be ensured and,  more generally, to use and operate it in the
same conditions as regards security.

The fact that you are presently reading this means that you have had
knowledge of the CeCILL license and that you accept its terms.


\subsection{Anaconda License}
\label{rst/licenses:anaconda-license}
Anaconda END USER LICENSE AGREEMENT

Anaconda (“the Software Product”) and accompanying documentation is licensed and not sold. The Software Product is protected by copyright laws and treaties, as well as laws and treaties related to other forms of intellectual property. Continuum Analytics Inc or its subsidiaries, affiliates, and suppliers (collectively “Continuum”) own intellectual property rights in the Software Product. The Licensee’s (“you” or “your”) license to download, use, copy, or change the Software Product is subject to these rights and to all the terms and conditions of this End User License Agreement (“Agreement”).

In addition to Continuum-licensed software, the Software product contains a collection of software packages from other sources (“Other Vendor Tools”). Continuum may also distribute updates to these packages on an “as is” basis and subject to their individual license agreements. These licenses are available either in the package itself or at \href{http://docs.continuum.io/anaconda/licenses.html}{http://docs.continuum.io/anaconda/licenses.html}. Continuum reserves the right to change which Other Vendor Tools are provided in Anaconda.


\subsection{Licenses of Anaconda packages}
\label{rst/licenses:licenses-of-anaconda-packages}
\begin{DUlineblock}{0em}
\item[] Name  Version         License
\item[] apptools      4.2.1   BSD
\item[] argcomplete   0.6.7   Apache Software License
\item[] astroid       1.1.1   LGPL
\item[] astropy       0.3.1   BSD
\item[] atom  0.3.7   BSD
\item[] basemap       1.0.7   PSF
\item[] beautiful-soup        4.3.1   PSF/MIT
\item[] binstar       0.5.2   BSD
\item[] biopython     1.63    BSD-like
\item[] bitarray      0.8.1   PSF
\item[] blaze         0.4.2   BSD
\item[] blist         1.3.6   BSD
\item[] blz   0.6.2   BSD
\item[] bokeh         0.4.4   New BSD
\item[] boto  2.28.0  MIT
\item[] bsdiff4       1.1.4   BSD
\item[] cairo         1.12.2  LGPL 2.1 and MPL 1.1
\item[] casuarius     1.1     LGPL
\item[] cdecimal      2.3     BSD
\item[] cffi  0.8.2   MIT
\item[] chaco         4.4.1   BSD
\item[] cheetah       2.4.4   MIT
\item[] chrpath       0.13    GPL
\item[] colorama      0.2.7   BSD
\item[] conda         3.4.3   BSD
\item[] conda-api     1.1.0   BSD
\item[] conda-build   1.3.3   BSD
\item[] configobj     5.0.5   BSD
\item[] coverage      3.7.1   BSD
\item[] cubes         0.10.2  MIT
\item[] curl  7.30.0  MIT/X derivate
\item[] cython        0.20.1  Apache 2.0
\item[] datashape     0.1.1   BSD
\item[] dateutil      2.1     BSD
\item[] decorator     3.4.0   BSD
\item[] distribute    0.6.45  PSF or ZPL
\item[] dnspython     1.10.0  as-is
\item[] docutils      0.11    Public-Domain, PSF, 2-clause BSD, GPL3
\item[] dynd-python   0.6.1   BSD
\item[] ecdsa         0.11    MIT
\item[] enable        4.3.0   BSD
\item[] enaml         0.9.1   BSD
\item[] envisage      4.4.0   BSD
\item[] faulthandler  2.3     BSD
\item[] feedparser    5.1.3   MIT
\item[] fiona         1.1.4   BSD
\item[] flake8        2.1.0   MIT
\item[] flask         0.10.1  BSD
\item[] freetype      2.4.10  FreeType License
\item[] future        0.12.0  MIT
\item[] futures       2.1.6   BSD
\item[] gdal  1.10.1  MIT
\item[] gdata         2.0.18  Apache 2.0
\item[] geos  3.3.3   LGPL
\item[] gevent        1.0     MIT
\item[] gevent-websocket      0.9.2   Apache
\item[] gevent\_zeromq         0.2.5   New BSD
\item[] googlecl      0.9.12  Apache 2.0
\item[] greenlet      0.4.2   MIT
\item[] grin  1.2.1   BSD
\item[] gunicorn      18.0    MIT
\item[] h5py  2.3.0   New BSD
\item[] hdf5  1.8.9   BSD-style
\item[] html5lib      0.999   MIT
\item[] hyde  0.8.5   MIT
\item[] iopro         1.6.5   proprietary - Continuum Analytics, Inc.
\item[] ipython       2.0.0   BSD
\item[] itsdangerous  0.24    BSD License
\item[] jinja2        2.7.2   BSD
\item[] jpeg  8d      Custom free software license
\item[] keyring       3.7     PSF
\item[] kiwisolver    0.1.2   BSD
\item[] launcher      0.1.2   proprietary - Continuum Analytics, Inc.
\item[] lcms  1.19    MIT
\item[] libdynd       0.6.1   BSD
\item[] libffi        3.0.13  MIT
\item[] libnetcdf     4.2.1.1         MIT
\item[] libpng        1.5.13  Open Source
\item[] libsodium     0.4.5   MIT
\item[] libtiff       4.0.2   as-is
\item[] libxml2       2.9.0   MIT
\item[] libxslt       1.1.28  MIT
\item[] llvm  3.3     Open Source
\item[] llvmpy        0.12.4  New BSD License
\item[] logilab-common        0.61.0  LGPL
\item[] lxml  3.3.4   BSD
\item[] markdown      2.4     BSD
\item[] markupsafe    0.18    BSD
\item[] mathjax       2.2     Apache
\item[] matplotlib    1.3.1   PSF-based
\item[] mayavi        4.3.1   BSD
\item[] mccabe        0.2.1   Expat
\item[] mdp   3.3     BSD
\item[] menuinst      1.0.3   BDF
\item[] mercurial     2.9.1   GPLv2
\item[] mingw         4.7     GPL
\item[] mock  1.0.1   BSD
\item[] mpi4py        1.3     BSD
\item[] mpich2        1.4.1p1         mpich license
\item[] multipledispatch      0.4.0   BSD
\item[] netcdf4       1.0.8   MIT
\item[] networkx      1.8.1   BSD
\item[] nltk  2.0.4   Apache 2.0
\item[] nose  1.3.3   LGPL
\item[] numba         0.13.1  numba license
\item[] numexpr       2.3.1   MIT
\item[] numpy         1.8.1   BSD
\item[] numpydoc      0.4     BSD
\item[] openpyxl      1.8.5   MIT/Expat
\item[] openssl       1.0.1g  Apache-style
\item[] pandas        0.13.1  BSD
\item[] pandasql      0.4.2   BSD
\item[] paramiko      1.14.0  LGPL
\item[] pastedeploy   1.5.2   MIT
\item[] patchelf      0.6     GPL3
\item[] patsy         0.2.1   BSD License
\item[] pep8  1.5.6   MIT License
\item[] pil   1.1.7   PIL license
\item[] pillow        2.4.0   Standard PIL license
\item[] pip   1.5.5   MIT
\item[] pixman        0.26.2  MIT
\item[] ply   3.4     BSD
\item[] psutil        1.2.1   BSD
\item[] py    1.4.20  MIT
\item[] py2cairo      1.10.0  LGPL 2.1 and MPL 1.1
\item[] pyasn1        0.1.6   BSD
\item[] pyaudio       0.2.7   MIT
\item[] pycosat       0.6.1   MIT
\item[] pycparser     2.10    BSD
\item[] pycrypto      2.6.1   Public Domain
\item[] pycurl        7.19.3.1        LGPL and MIT/X
\item[] pyface        4.4.0   BSD
\item[] pyflakes      0.8.1   MIT
\item[] pygments      1.6     BSD
\item[] pykit         0.2.0   BSD
\item[] pylint        1.2.1   GPL
\item[] pymc  2.3.2   Academic Free License
\item[] pyodbc        3.0.7   MIT
\item[] pyparsing     2.0.1   MIT
\item[] pyqt  4.10.4  GPL
\item[] pyreadline    2.0     BSD
\item[] pysal         1.6.0   New BSD License
\item[] pysam         0.6     MIT
\item[] pytables      3.1.1   BSD
\item[] pytest        2.5.2   MIT
\item[] python        2.7.6   PSF
\item[] pytz  2014.2  MIT
\item[] pywin32       218.4   PSF
\item[] pyyaml        3.11    MIT
\item[] pyzmq         14.3.0  BSD License and GNU Library or Lesser General Public License
\item[] qt    4.8.5   LGPL
\item[] readline      6.2     GPL 3
\item[] redis         2.6.9   3-clause BSD
\item[] redis-py      2.9.1   MIT
\item[] reportlab     3.1.8   BSD
\item[] requests      2.2.1   ISC
\item[] rope  0.9.4   GPL
\item[] runipy        0.0.8   BSD
\item[] scikit-image  0.9.3   Modified BSD
\item[] scikit-learn  0.14.1  3-clause BSD
\item[] scipy         0.14.0  BSD
\item[] setuptools    3.6     PSF or ZPL
\item[] shapely       1.3.1   BSD
\item[] sip   4.15.5  GPL
\item[] six   1.6.1   MIT
\item[] sphinx        1.2.2   BSD
\item[] spyder        2.2.5   MIT
\item[] sqlalchemy    0.9.4   MIT
\item[] sqlite        3.8.4.1         Public Domain
\item[] sqlparse      0.1.11  BSD
\item[] ssh   1.8.0   LGPL
\item[] ssl\_match\_hostname    3.4.0.2         PSF
\item[] starcluster   0.93.3  LGPL
\item[] statsmodels   0.5.0   3-clause Modified BSD
\item[] sympy         0.7.5   New BSD
\item[] theano        0.6.0   BSD
\item[] tk    8.5.15  BSD-style
\item[] tornado       3.2.1   Apache
\item[] traits        4.4.0   BSD
\item[] traitsui      4.4.0   BSD
\item[] twisted       13.2.0  MIT
\item[] ujson         1.33    BSD
\item[] unixodbc      2.3.1   ???
\item[] util-linux    2.21    GPL
\item[] vtk   5.10.1  BSD
\item[] w3lib         1.5     BSD
\item[] werkzeug      0.9.4   BSD
\item[] whoosh        2.5.7   BSD
\item[] workerpool    0.9.2   MIT
\item[] xlrd  0.9.3   BSD
\item[] xlsxwriter    0.5.5   BSD
\item[] xlwings       0.1.0   BSD 3-clause
\item[] xlwt  0.7.5   BSD
\item[] yaml  0.1.4   MIT
\item[] yt    2.6.2   BSD
\item[] zeromq        4.0.4   LGPL
\item[] zlib  1.2.7   zlib
\item[] zope.interface        4.0.5   Zope Public License
\end{DUlineblock}


\chapter{Indices and tables}
\label{index:indices-and-tables}\begin{itemize}
\item {} 
\emph{genindex}

\item {} 
\emph{modindex}

\item {} 
\emph{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{theindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{a}
\item {\texttt{Algo.Linpredic}}, \pageref{rst/code:module-Algo.Linpredic}
\item {\texttt{Algo.urQRd}}, \pageref{rst/code:module-Algo.urQRd}
\indexspace
\bigletter{f}
\item {\texttt{File.Apex}}, \pageref{rst/code:module-File.Apex}
\item {\texttt{File.csv}}, \pageref{rst/code:module-File.csv}
\item {\texttt{File.GifaFile}}, \pageref{rst/code:module-File.GifaFile}
\item {\texttt{File.HDF5File}}, \pageref{rst/code:module-File.HDF5File}
\item {\texttt{File.Solarix}}, \pageref{rst/code:module-File.Solarix}
\item {\texttt{File.Thermo}}, \pageref{rst/code:module-File.Thermo}
\item {\texttt{FTICR}}, \pageref{rst/code:module-FTICR}
\indexspace
\bigletter{n}
\item {\texttt{NPKData}}, \pageref{rst/code:module-NPKData}
\indexspace
\bigletter{o}
\item {\texttt{Orbitrap}}, \pageref{rst/code:module-Orbitrap}
\indexspace
\bigletter{p}
\item {\texttt{processing}}, \pageref{rst/code:module-processing}
\indexspace
\bigletter{v}
\item {\texttt{Visu.canvas}}, \pageref{rst/visu2d:module-Visu.canvas}
\item {\texttt{Visu.canvas\_event}}, \pageref{rst/visu2d:module-Visu.canvas_event}
\item {\texttt{Visu.convert}}, \pageref{rst/visu2d:module-Visu.convert}
\item {\texttt{Visu.display}}, \pageref{rst/visu2d:module-Visu.display}
\item {\texttt{Visu.interface}}, \pageref{rst/visu2d:module-Visu.interface}
\item {\texttt{Visu.interface\_actions}}, \pageref{rst/visu2d:module-Visu.interface_actions}
\item {\texttt{Visu.label\_2D}}, \pageref{rst/visu2d:module-Visu.label_2D}
\item {\texttt{Visu.Load}}, \pageref{rst/visu2d:module-Visu.Load}
\item {\texttt{Visu.Matplotlib\_generictools}}, \pageref{rst/visu2d:module-Visu.Matplotlib_generictools}
\item {\texttt{Visu.paramzoom}}, \pageref{rst/visu2d:module-Visu.paramzoom}
\item {\texttt{Visu.profile\_popup}}, \pageref{rst/visu2d:module-Visu.profile_popup}
\item {\texttt{Visu.Pyside\_PyQt4}}, \pageref{rst/visu2d:module-Visu.Pyside_PyQt4}
\item {\texttt{Visu.Saving}}, \pageref{rst/visu2d:module-Visu.Saving}
\item {\texttt{Visu.zoom\_plot}}, \pageref{rst/visu2d:module-Visu.zoom_plot}
\item {\texttt{Visu.zoom\_tools}}, \pageref{rst/visu2d:module-Visu.zoom_tools}
\item {\texttt{Visu.zooming}}, \pageref{rst/visu2d:module-Visu.zooming}
\item {\texttt{visu2D}}, \pageref{rst/code:module-visu2D}
\end{theindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
