
<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Code &mdash; spike 1.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/bootstrap-3.0.0/css/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="../_static/bootstrap-3.0.0/css/bootstrap-theme.min.css" type="text/css" />
    <link rel="stylesheet" href="../_static/bootstrap-sphinx.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/js/jquery-1.9.1.min.js"></script>
    <script type="text/javascript" src="../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-3.0.0/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-sphinx.js"></script>
    <link rel="top" title="spike 1.0 documentation" href="../index.html" />
    <link rel="next" title="inside Visu2D" href="visu2d.html" />
    <link rel="prev" title="Tutorial" href="tutorial.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

  </head>
  <body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../index.html">
          spike</a>
        <span class="navbar-text navbar-version pull-left"><b>1.0</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            <li class="divider-vertical"></li>
            
            
              <li class="dropdown globaltoc-container">
  <a href="../index.html"
     class="dropdown-toggle"
     data-toggle="dropdown">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
    ><ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial.html">Tutorial</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="">Code</a></li>
<li class="toctree-l1"><a class="reference internal" href="licenses.html">Licenses</a></li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"><ul>
<li><a class="reference internal" href="#">Code</a><ul>
<li><a class="reference internal" href="#module-NPKData">NPKData</a></li>
<li><a class="reference internal" href="#file-formats">File formats</a><ul>
<li><a class="reference internal" href="#module-File.Apex">Apex</a></li>
<li><a class="reference internal" href="#module-File.GifaFile">GifaFile</a></li>
<li><a class="reference internal" href="#module-File.HDF5File">HDF5File</a></li>
<li><a class="reference internal" href="#module-File.Solarix">Solarix</a></li>
<li><a class="reference internal" href="#module-File.Thermo">Thermo</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-FTICR">FTICR</a></li>
<li><a class="reference internal" href="#module-Orbitrap">Orbitrap</a></li>
<li><a class="reference internal" href="#module-visu2D">visu2D</a><ul>
</ul>
</li>
<li><a class="reference internal" href="#module-processing">Processing 2D</a></li>
<li><a class="reference internal" href="#algorithms">Algorithms</a><ul>
<li><a class="reference internal" href="#module-Algo.urQRd">urQRd</a><ul>
<li><a class="reference internal" href="#urqrd-py">urQRd.py</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-Algo.Linpredic">Linpredic</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
              
                
  <li>
    <a href="tutorial.html" title="Previous Chapter: Tutorial"><span class="glyphicon glyphicon-chevron-left visible-sm"></span><span class="hidden-sm">&laquo; Tutorial</span>
    </a>
  </li>
  <li>
    <a href="visu2d.html" title="Next Chapter: inside Visu2D"><span class="glyphicon glyphicon-chevron-right visible-sm"></span><span class="hidden-sm">inside Visu2D &raquo;</span>
    </a>
  </li>
              
            
            
            
            
              <li class="hidden-sm">
<div id="sourcelink">
  <a href="../_sources/rst/code.txt"
     rel="nofollow">Source</a>
</div></li>
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="col-md-12">
      
  <div class="section" id="code">
<h1>Code<a class="headerlink" href="#code" title="Permalink to this headline">¶</a></h1>
<div class="section" id="module-NPKData">
<span id="npkdata"></span><h2>NPKData<a class="headerlink" href="#module-NPKData" title="Permalink to this headline">¶</a></h2>
<p>NPKData.py</p>
<p>Implement the basic mechanisms for NMR data-sets</p>
<p>Created by Marc-André and Marie-Aude on 2010-03-17.
Copyright (c) 2010 IGBMC and NMRTEC. All rights reserved.</p>
<dl class="class">
<dt id="NPKData.Axis">
<em class="property">class </em><tt class="descclassname">NPKData.</tt><tt class="descname">Axis</tt><big>(</big><em>size=64</em>, <em>itype=0</em>, <em>units='point'</em><big>)</big><a class="headerlink" href="#NPKData.Axis" title="Permalink to this definition">¶</a></dt>
<dd><p>hold information for one spectral axis
used internally</p>
<dl class="method">
<dt id="NPKData.Axis.check_zoom">
<tt class="descname">check_zoom</tt><big>(</big><em>zoom</em><big>)</big><a class="headerlink" href="#NPKData.Axis.check_zoom" title="Permalink to this definition">¶</a></dt>
<dd><p>check whether a zoom window, given as (low,high) is valid
- check low&lt;high and within axis size
- check that it starts on a real index in itype is complex
return a boolean</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.Axis.get_sampling">
<tt class="descname">get_sampling</tt><big>(</big><big>)</big><a class="headerlink" href="#NPKData.Axis.get_sampling" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the sampling scheme contained in current axis</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.Axis.load_sampling">
<tt class="descname">load_sampling</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#NPKData.Axis.load_sampling" title="Permalink to this definition">¶</a></dt>
<dd><p>loads the sampling scheme contained in an external file
file should contain index values, one per line, comment lines start with a #
complex axes should be sampled by complex pairs, and indices go up to self.size1/2</p>
<p>sampling is loaded into self.sampling  and self.sampling_info is a dictionnary with information</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.Axis.points_axis">
<tt class="descname">points_axis</tt><big>(</big><big>)</big><a class="headerlink" href="#NPKData.Axis.points_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>return axis in points units, actually 0..size-1</p>
</dd></dl>

<dl class="attribute">
<dt id="NPKData.Axis.sampled">
<tt class="descname">sampled</tt><a class="headerlink" href="#NPKData.Axis.sampled" title="Permalink to this definition">¶</a></dt>
<dd><p>true is sampled axis</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.Axis.set_sampling">
<tt class="descname">set_sampling</tt><big>(</big><em>sampling</em><big>)</big><a class="headerlink" href="#NPKData.Axis.set_sampling" title="Permalink to this definition">¶</a></dt>
<dd><p>sets the sampling scheme contained in current axis</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.Axis.typestr">
<tt class="descname">typestr</tt><big>(</big><big>)</big><a class="headerlink" href="#NPKData.Axis.typestr" title="Permalink to this definition">¶</a></dt>
<dd><p>returns its type (real or complex) as a string</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.Axis.unit_axis">
<tt class="descname">unit_axis</tt><big>(</big><big>)</big><a class="headerlink" href="#NPKData.Axis.unit_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>returns an axis in the unit defined in self.units</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="NPKData.LaplaceAxis">
<em class="property">class </em><tt class="descclassname">NPKData.</tt><tt class="descname">LaplaceAxis</tt><big>(</big><em>size=64</em>, <em>dmin=1.0</em>, <em>dmax=10.0</em>, <em>dfactor=1.0</em>, <em>units='points'</em><big>)</big><a class="headerlink" href="#NPKData.LaplaceAxis" title="Permalink to this definition">¶</a></dt>
<dd><p>hold information for one Laplace axis (DOSY)
used internally</p>
<dl class="method">
<dt id="NPKData.LaplaceAxis.dtoi">
<tt class="descname">dtoi</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#NPKData.LaplaceAxis.dtoi" title="Permalink to this definition">¶</a></dt>
<dd><p>returns point value (i) from damping value (d)</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.LaplaceAxis.itod">
<tt class="descname">itod</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#NPKData.LaplaceAxis.itod" title="Permalink to this definition">¶</a></dt>
<dd><p>returns damping value (d) from point value (i)</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.LaplaceAxis.report">
<tt class="descname">report</tt><big>(</big><big>)</big><a class="headerlink" href="#NPKData.LaplaceAxis.report" title="Permalink to this definition">¶</a></dt>
<dd><p>hight level report</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="NPKData.NMRAxis">
<em class="property">class </em><tt class="descclassname">NPKData.</tt><tt class="descname">NMRAxis</tt><big>(</big><em>size=64</em>, <em>specwidth=6283.185307179586</em>, <em>offset=0.0</em>, <em>frequency=400.0</em>, <em>itype=0</em>, <em>units='points'</em><big>)</big><a class="headerlink" href="#NPKData.NMRAxis" title="Permalink to this definition">¶</a></dt>
<dd><p>hold information for one NMR axis
used internally</p>
<dl class="method">
<dt id="NPKData.NMRAxis.Hz_axis">
<tt class="descname">Hz_axis</tt><big>(</big><big>)</big><a class="headerlink" href="#NPKData.NMRAxis.Hz_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>return axis containing Hz values, can be used for display</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NMRAxis.extract">
<tt class="descname">extract</tt><big>(</big><em>(start</em>, <em>end)</em><big>)</big><a class="headerlink" href="#NPKData.NMRAxis.extract" title="Permalink to this definition">¶</a></dt>
<dd><p>redefines the axis parameters so that the new axe is extracted for the points [start:end]</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NMRAxis.freq_axis">
<tt class="descname">freq_axis</tt><big>(</big><big>)</big><a class="headerlink" href="#NPKData.NMRAxis.freq_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>return axis containing Hz values, can be used for display</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NMRAxis.htoi">
<tt class="descname">htoi</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#NPKData.NMRAxis.htoi" title="Permalink to this definition">¶</a></dt>
<dd><p>returns point value (i) from Hz value (h)</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NMRAxis.htop">
<tt class="descname">htop</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#NPKData.NMRAxis.htop" title="Permalink to this definition">¶</a></dt>
<dd><p>returns ppm value (p) from Hz value (h)</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NMRAxis.itoh">
<tt class="descname">itoh</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#NPKData.NMRAxis.itoh" title="Permalink to this definition">¶</a></dt>
<dd><p>returns Hz value (h) from point value (i)</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NMRAxis.itop">
<tt class="descname">itop</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#NPKData.NMRAxis.itop" title="Permalink to this definition">¶</a></dt>
<dd><p>returns ppm value (p) from point value (i)</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NMRAxis.ppm_axis">
<tt class="descname">ppm_axis</tt><big>(</big><big>)</big><a class="headerlink" href="#NPKData.NMRAxis.ppm_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>return axis containing ppm values, can be used for display</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NMRAxis.ptoh">
<tt class="descname">ptoh</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#NPKData.NMRAxis.ptoh" title="Permalink to this definition">¶</a></dt>
<dd><p>returns Hz value (h) from ppm value (p)</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NMRAxis.ptoi">
<tt class="descname">ptoi</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#NPKData.NMRAxis.ptoi" title="Permalink to this definition">¶</a></dt>
<dd><p>returns point value (i) from ppm value (p)</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NMRAxis.report">
<tt class="descname">report</tt><big>(</big><big>)</big><a class="headerlink" href="#NPKData.NMRAxis.report" title="Permalink to this definition">¶</a></dt>
<dd><p>high level reporting</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="NPKData.NPKData">
<em class="property">class </em><tt class="descclassname">NPKData.</tt><tt class="descname">NPKData</tt><big>(</big><em>dim=1</em>, <em>shape=None</em>, <em>buffer=None</em>, <em>name=None</em>, <em>debug=0</em><big>)</big><a class="headerlink" href="#NPKData.NPKData" title="Permalink to this definition">¶</a></dt>
<dd><p>a working data used by the NPK package</p>
<p>The data is a numpy array, found in self.buffer     can also be accessed directly d[i], d[i,j], ...</p>
<p>1D 2D and 3D are handled, 3 axes are defined : axis1 axis2 axis3
axes are defined as in NMR
in 1D, every is in axis1
in 2D, the fastest varying dimension is in axis2, the slowest in axis1
in 3D, the fastest varying dimension is in axis3, the slowest in axis1
see axis_index
typical properties and methods are :
utilities:</p>
<blockquote>
<div>.display() 
.check()</div></blockquote>
<dl class="docutils">
<dt>properties</dt>
<dd>.itype
.dim .size1, .size2, .size3 ...</dd>
<dt>moving data :</dt>
<dd>.row(i) .col(i) .set_row(i)  .set_col(i)
.copy()
.load() .save()</dd>
<dt>processing :</dt>
<dd>.fft() .rfft() .modulus() .apod_xxx()  sg()  transpose() ...</dd>
<dt>arithmetics :</dt>
<dd>.fill() .mult .add()
also direct arithmetics : f = 2*d+e</dd>
</dl>
<p>all methods return self, so computation can be piped
etc...</p>
<dl class="method">
<dt id="NPKData.NPKData.abs">
<tt class="descname">abs</tt><big>(</big><big>)</big><a class="headerlink" href="#NPKData.NPKData.abs" title="Permalink to this definition">¶</a></dt>
<dd><p>This command takes the absolute value of the current the data set</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.adapt_size">
<tt class="descname">adapt_size</tt><big>(</big><big>)</big><a class="headerlink" href="#NPKData.NPKData.adapt_size" title="Permalink to this definition">¶</a></dt>
<dd><p>adapt the sizes held in the axis objects to the size of the buffer
TO BE CALLED each time the buffer size is modified
otherwise strange things will happen</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.add">
<tt class="descname">add</tt><big>(</big><em>otherdata</em><big>)</big><a class="headerlink" href="#NPKData.NPKData.add" title="Permalink to this definition">¶</a></dt>
<dd><p>add the provided data : otherdata to the current one
eg : data.add(otherdata) add content of otherdata to data buffer</p>
<p>can add NPKData and numbers</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.addbase">
<tt class="descname">addbase</tt><big>(</big><em>constant</em><big>)</big><a class="headerlink" href="#NPKData.NPKData.addbase" title="Permalink to this definition">¶</a></dt>
<dd><p>add a constant to the data</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.addfreq">
<tt class="descname">addfreq</tt><big>(</big><em>freq</em>, <em>amp=1.0</em><big>)</big><a class="headerlink" href="#NPKData.NPKData.addfreq" title="Permalink to this definition">¶</a></dt>
<dd><p>add to the current data-set (1D, 2D, 3D) a single frequency sinusoid
characterized by its frequency (from axis.specwidth) and amplitude</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.addnoise">
<tt class="descname">addnoise</tt><big>(</big><em>noise</em>, <em>seed=None</em><big>)</big><a class="headerlink" href="#NPKData.NPKData.addnoise" title="Permalink to this definition">¶</a></dt>
<dd><p>add to the current data-set (1D, 2D, 3D) a white-gaussian, 
characterized by its level noise, and the random generator seed.</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.apod_apply">
<tt class="descname">apod_apply</tt><big>(</big><em>axis</em>, <em>apod_buf</em><big>)</big><a class="headerlink" href="#NPKData.NPKData.apod_apply" title="Permalink to this definition">¶</a></dt>
<dd><p>apply an apodisation, held into the buffer apod_buf</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.apod_em">
<tt class="descname">apod_em</tt><big>(</big><em>axis=0</em>, <em>lb=1.0</em><big>)</big><a class="headerlink" href="#NPKData.NPKData.apod_em" title="Permalink to this definition">¶</a></dt>
<dd><p>apply an exponential apodisation, lb is in Hz
WARNING : different from common definition of apodisation</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.apod_gm">
<tt class="descname">apod_gm</tt><big>(</big><em>axis=0</em>, <em>gb=1.0</em><big>)</big><a class="headerlink" href="#NPKData.NPKData.apod_gm" title="Permalink to this definition">¶</a></dt>
<dd><p>apply an gaussian apodisation, gb is in Hz
WARNING : different from common definition of apodisation</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.apod_sin">
<tt class="descname">apod_sin</tt><big>(</big><em>axis=0</em>, <em>maxi=0</em><big>)</big><a class="headerlink" href="#NPKData.NPKData.apod_sin" title="Permalink to this definition">¶</a></dt>
<dd><p>apply a sinebell apodisation
maxi ranges from 0 to 0.5</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.apod_sq_sin">
<tt class="descname">apod_sq_sin</tt><big>(</big><em>axis=0</em>, <em>maxi=0</em><big>)</big><a class="headerlink" href="#NPKData.NPKData.apod_sq_sin" title="Permalink to this definition">¶</a></dt>
<dd><p>apply a squared sinebell apodisation
maxi ranges from 0 to 0.5</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.apod_tm">
<tt class="descname">apod_tm</tt><big>(</big><em>axis=0</em>, <em>tm1=0</em>, <em>tm2=0</em><big>)</big><a class="headerlink" href="#NPKData.NPKData.apod_tm" title="Permalink to this definition">¶</a></dt>
<dd><p>apply a trapezoide apodisation, lb is in Hz
WARNING : different from common definition of apodisation
This commands applies a trapezoid filter function to the data-
set. The function raises from 0.0 to 1.0 from the first point to 
point n1. The function then stays to 1.0 until point n2, from which 
it goes down to 0.0 at the last point.
If in 2D or 3D then Fx tells on which axis to apply the filter.</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.apply_process">
<tt class="descname">apply_process</tt><big>(</big><em>axis_it</em>, <em>process</em>, <em>axis=0</em>, <em>mp=True</em>, <em>N_proc=None</em><big>)</big><a class="headerlink" href="#NPKData.NPKData.apply_process" title="Permalink to this definition">¶</a></dt>
<dd><p>scans through given data, using axis_it which is an iterator,
applying process method (by its name)
store results into self, along to axis
if axis_it iterates over self, then processing is in-place</p>
<blockquote>
<div>however it can iterate over an other data-set, thus importing the data</div></blockquote>
<p>if self.dim is equal to axis_it().dim, then data are</p>
<p>if mp,  does it in a multiprocessing fashion using multiprocessing.Pool()
if N_proc is None, finds the optimum number itself.</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.axes">
<tt class="descname">axes</tt><big>(</big><em>axis</em><big>)</big><a class="headerlink" href="#NPKData.NPKData.axes" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the required axis : 1, 2 or 3</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.centroid1d">
<tt class="descname">centroid1d</tt><big>(</big><em>npoints=3</em><big>)</big><a class="headerlink" href="#NPKData.NPKData.centroid1d" title="Permalink to this definition">¶</a></dt>
<dd><p>from peak lists determined with peak()
realize a centroid fit of the peak summit and width,
computes Full width at half maximum
creates lists self.centered_peaks and self.width_peaks</p>
<dl class="docutils">
<dt>Temporary  so far,</dt>
<dd>only based on regular sampling, not unit axis.
ah-hoc structure, waiting for a real PEAK object</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.check">
<tt class="descname">check</tt><big>(</big><em>warn=False</em><big>)</big><a class="headerlink" href="#NPKData.NPKData.check" title="Permalink to this definition">¶</a></dt>
<dd><p>check basic internal validity
raises exceptions unless warn is set to True - in which case, only warnings are issued
can be used in pipes as it returns self if everything is ok</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.check1D">
<tt class="descname">check1D</tt><big>(</big><big>)</big><a class="headerlink" href="#NPKData.NPKData.check1D" title="Permalink to this definition">¶</a></dt>
<dd><p>true for a 1D</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.check2D">
<tt class="descname">check2D</tt><big>(</big><big>)</big><a class="headerlink" href="#NPKData.NPKData.check2D" title="Permalink to this definition">¶</a></dt>
<dd><p>true for a 2D</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.check3D">
<tt class="descname">check3D</tt><big>(</big><big>)</big><a class="headerlink" href="#NPKData.NPKData.check3D" title="Permalink to this definition">¶</a></dt>
<dd><p>true for a 3D</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.check_zoom">
<tt class="descname">check_zoom</tt><big>(</big><em>zoom</em><big>)</big><a class="headerlink" href="#NPKData.NPKData.check_zoom" title="Permalink to this definition">¶</a></dt>
<dd><p>check whether a zoom window, given as (low,high) or ((low1,high1),(low2,high2))  is valid
- check low&lt;high and within axis size
- check that it starts on a real index in itype is complex
return a boolean</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.chsize">
<tt class="descname">chsize</tt><big>(</big><em>sz1=-1</em>, <em>sz2=-1</em>, <em>sz3=-1</em><big>)</big><a class="headerlink" href="#NPKData.NPKData.chsize" title="Permalink to this definition">¶</a></dt>
<dd><p>Change size of data, zero-fill or truncate. 
DO NOT change the value of OFFSET and SPECW, so EXTRACT should 
always be preferred on spectra (unless you know exactly what your are doing).</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.col">
<tt class="descname">col</tt><big>(</big><em>i</em><big>)</big><a class="headerlink" href="#NPKData.NPKData.col" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a 1D extracted from the current 2D at position 0&lt;=i&lt;=size2-1</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.conjg">
<tt class="descname">conjg</tt><big>(</big><em>axis=0</em><big>)</big><a class="headerlink" href="#NPKData.NPKData.conjg" title="Permalink to this definition">¶</a></dt>
<dd><p>take the inverse conjugate of the buffer</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.conv_n_p">
<tt class="descname">conv_n_p</tt><big>(</big><big>)</big><a class="headerlink" href="#NPKData.NPKData.conv_n_p" title="Permalink to this definition">¶</a></dt>
<dd><p>realises the n+p to SH conversion</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.copy">
<tt class="descname">copy</tt><big>(</big><big>)</big><a class="headerlink" href="#NPKData.NPKData.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>return a copy of itself</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.diag">
<tt class="descname">diag</tt><big>(</big><em>direc='F12'</em><big>)</big><a class="headerlink" href="#NPKData.NPKData.diag" title="Permalink to this definition">¶</a></dt>
<dd><p>In 2D, extracts the diagonal of the 2D and put into the 1D buffer.</p>
<p>In 3D, extracts one diagonal plane of the 3D cube, chosen with the direc parameter 
and put it into the 2D buffer
direct values are :</p>
<p>&#8220;F12&#8221; is the F1=F2 diagonal
&#8220;F23&#8221; is the F2=F3 diagonal
&#8220;F13&#8221; is the F1=F3 diagonal</p>
</dd></dl>

<dl class="attribute">
<dt id="NPKData.NPKData.dim">
<tt class="descname">dim</tt><a class="headerlink" href="#NPKData.NPKData.dim" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the dimension of data : 1 2 or 3 (for 1D 2D or 3D)</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.display">
<tt class="descname">display</tt><big>(</big><em>scale=1.0</em>, <em>absmax=0.0</em>, <em>show=False</em>, <em>label=None</em>, <em>new_fig=True</em>, <em>axis=None</em>, <em>mode3D=False</em>, <em>zoom=None</em>, <em>xlabel='_def_'</em>, <em>ylabel='_def_'</em>, <em>figure=None</em><big>)</big><a class="headerlink" href="#NPKData.NPKData.display" title="Permalink to this definition">¶</a></dt>
<dd><p>not so quick and dirty display using matplotlib or mlab - still a first try</p>
<p>scale   allows to increase the vertical scale of display
absmax  overwrite the value for the largest point, which will not be computed</p>
<blockquote>
<div>display is scaled so that the largest point is first computed (and stored in absmax),
and then the value at absmax/scale is set full screen</div></blockquote>
<dl class="docutils">
<dt>show    will call plot.show() at the end, allowing every declared display to be shown on-screen</dt>
<dd>useless in ipython</dd>
</dl>
<p>label   add a label text to plot
xlabel, ylabel : axes label (default is self.units - use None to remove)
axis    used as axis if present, axis length should match experiment length</p>
<blockquote>
<div>in 2D, should be a pair (xaxis,yaxis)</div></blockquote>
<p>new_fig will create a new window if set to True (default) (active only is figure==None)
mode3D  use malb 3D display instead of matplotlib contour for 2D display
zoom    is a tuple defining the zoom window (left,right) or   ((F1_limits),(F2_limits))
figure  if not None, will be used directly to display instead of using its own</p>
<p>can actually be called without harm, even if no graphic is available, it will just do nothing.</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.display_peaks">
<tt class="descname">display_peaks</tt><big>(</big><em>axis=None</em>, <em>peak_label=False</em>, <em>zoom=None</em>, <em>show=False</em><big>)</big><a class="headerlink" href="#NPKData.NPKData.display_peaks" title="Permalink to this definition">¶</a></dt>
<dd><p>displays peaks generated with peak()</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.extract">
<tt class="descname">extract</tt><big>(</big><span class="optional">[</span><span class="optional">[</span><em>x1</em>, <em>y1</em><span class="optional">]</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#NPKData.NPKData.extract" title="Permalink to this definition">¶</a></dt>
<dd><p>extract([x1, y1], [x2, y2]) or extract([x1, y1, x2, y2])
etc...</p>
<p>Permits to extract a portion of the data.
Data can then be processed as a regular data-set.
EXTRACT changes the value of OFFSET and SPECW accordingly.</p>
<blockquote>
<div><ul class="simple">
<li>extract(x1,y1) for 1D datasets.</li>
<li>extract(x1, y1, x2, y2) for 2D datasets.</li>
</ul>
</div></blockquote>
<p>see also : chsize</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.f">
<tt class="descname">f</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#NPKData.NPKData.f" title="Permalink to this definition">¶</a></dt>
<dd><p>used by 3D display</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.fastclean">
<tt class="descname">fastclean</tt><big>(</big><em>nsigma=2.0</em>, <em>nbseg=20</em>, <em>axis=0</em><big>)</big><a class="headerlink" href="#NPKData.NPKData.fastclean" title="Permalink to this definition">¶</a></dt>
<dd><p>set to zeros all points below nsigma times the noise level
This allows the corresponding data-set, once stored to file, to be considerably more compressive.</p>
<dl class="docutils">
<dt>nsigma: float</dt>
<dd>the ratio used, typically 1.0 to 3.0 (higher compression)</dd>
<dt>nbseg: int</dt>
<dd>the number of segment used for noise evaluation, see util.signal_tools.findnoiselevel</dd>
<dt>axis: int</dt>
<dd>the axis on which the noise is evaluated, default is fastest varying dimension</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.fft">
<tt class="descname">fft</tt><big>(</big><em>axis=0</em><big>)</big><a class="headerlink" href="#NPKData.NPKData.fft" title="Permalink to this definition">¶</a></dt>
<dd><p>computes the complex Fourier transform,</p>
<p>takes complex time domain data and returns complex frequency domain data</p>
<p>see test_axis for information on axis</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.fftr">
<tt class="descname">fftr</tt><big>(</big><em>axis=0</em><big>)</big><a class="headerlink" href="#NPKData.NPKData.fftr" title="Permalink to this definition">¶</a></dt>
<dd><p>computes the alternate Fourier transform,</p>
<p>takes complex time domain data and returns real frequency domain data</p>
<p>see test_axis for information on axis</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.flip">
<tt class="descname">flip</tt><big>(</big><big>)</big><a class="headerlink" href="#NPKData.NPKData.flip" title="Permalink to this definition">¶</a></dt>
<dd><p>on a 2D with axis2.itype==1 and axis1.itype==0
copies the imaginary from on axis to the other
after this, we have</p>
<blockquote>
<div>axis2.itype==0 and axis1.itype==1
size1 is doubled
size2 is halved</div></blockquote>
<p>Useful for complex FT
this is the opposite of flop()</p>
<p>&gt;&gt;&gt;bb=NPKData(buffer=array([[  0.,   1.,   2.,   3.],[  4.,   5.,   6.,   7.],[  8.,   9.,  10.,  11.],[ 12.,  13.,  14.,  15.]]))
&gt;&gt;&gt;print bb.buffer
array([[  0.,   1.,   2.,   3.],</p>
<blockquote>
<div>[  4.,   5.,   6.,   7.],
[  8.,   9.,  10.,  11.],
[ 12.,  13.,  14.,  15.]])</div></blockquote>
<p>&gt;&gt;&gt;bb.axis2.itype=1
&gt;&gt;&gt;bb.flip()
&gt;&gt;&gt;print bb.buffer
array([[  0.,   2.],</p>
<blockquote>
<div>[  1.,   3.],
[  4.,   6.],
[  5.,   7.],
[  8.,  10.],
[  9.,  11.],
[ 12.,  14.],
[ 13.,  15.]])</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.flipphase">
<tt class="descname">flipphase</tt><big>(</big><em>ph0</em>, <em>ph1</em>, <em>axis=1</em><big>)</big><a class="headerlink" href="#NPKData.NPKData.flipphase" title="Permalink to this definition">¶</a></dt>
<dd><p>equivalent to   flip(); phase();flop()   but much faster
apply a phase correction along F1 axis of a 2D.
on 2D where axis1.itype = 0   and   axis2.itype = 1
using pairs of columns as real and imaginary pair
phase corrections are in degree</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.flop">
<tt class="descname">flop</tt><big>(</big><big>)</big><a class="headerlink" href="#NPKData.NPKData.flop" title="Permalink to this definition">¶</a></dt>
<dd><p>on a 2D with axis2.itype==0 and axis1.itype==1
copies the imaginary from on axis to the other
after this, we have</p>
<blockquote>
<div>axis2.itype==1 and axis1.itype==0
size1 is halved
size2 is doubled</div></blockquote>
<p>Useful for complex FT
this is the opposite of flip()</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.get_buffer">
<tt class="descname">get_buffer</tt><big>(</big><em>copy=False</em><big>)</big><a class="headerlink" href="#NPKData.NPKData.get_buffer" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a view or a copy of the numpy buffer containing the NPKData values
dtype is either real or complex if axis is complex.
remarks :</p>
<blockquote>
<div><ul class="simple">
<li>default is a view, if you want a copy, simply do d.get_buffer(copy=True)</li>
<li>if you use a view, do not modify the size, nor the dtype</li>
<li>see set_buffer()</li>
</ul>
</div></blockquote>
<p>WARNING
- In nD with n&gt;1 and if NPKData is hypercomplex, only the fastest (n) axis is considered, all other imaginary parts are left as real.</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.ifft">
<tt class="descname">ifft</tt><big>(</big><em>axis=0</em><big>)</big><a class="headerlink" href="#NPKData.NPKData.ifft" title="Permalink to this definition">¶</a></dt>
<dd><p>computes the inverse of fft(),
takes complex frequency domain data and returns complex time domain data</p>
<p>see test_axis for information on axis</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.ifftr">
<tt class="descname">ifftr</tt><big>(</big><em>axis=0</em><big>)</big><a class="headerlink" href="#NPKData.NPKData.ifftr" title="Permalink to this definition">¶</a></dt>
<dd><p>computes the inverse of fftr,
takes real frequency domain data and returns complex time domain data</p>
<p>see test_axis for information on axis</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.irfft">
<tt class="descname">irfft</tt><big>(</big><em>axis=0</em><big>)</big><a class="headerlink" href="#NPKData.NPKData.irfft" title="Permalink to this definition">¶</a></dt>
<dd><p>computes the inverse of rfft(),
takes complex frequency domain data and returns real time domain data</p>
<p>see test_axis for information on axis</p>
</dd></dl>

<dl class="attribute">
<dt id="NPKData.NPKData.itype">
<tt class="descname">itype</tt><a class="headerlink" href="#NPKData.NPKData.itype" title="Permalink to this definition">¶</a></dt>
<dd><p>returns complex type of each axes coded as single number, using NPKv1 code</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.linear_interpolate">
<tt class="descname">linear_interpolate</tt><big>(</big><em>xpoints</em>, <em>axis='F2'</em><big>)</big><a class="headerlink" href="#NPKData.NPKData.linear_interpolate" title="Permalink to this definition">¶</a></dt>
<dd><p>&#8220;compute and applies a linear function as a baseline correction</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.load">
<tt class="descname">load</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#NPKData.NPKData.load" title="Permalink to this definition">¶</a></dt>
<dd><p>load data from a file</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.load_txt">
<tt class="descname">load_txt</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#NPKData.NPKData.load_txt" title="Permalink to this definition">¶</a></dt>
<dd><p>load 1D data in texte, single column, no unit - with attributes as pseudo comments</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.mean">
<tt class="descname">mean</tt><big>(</big><em>zone</em><big>)</big><a class="headerlink" href="#NPKData.NPKData.mean" title="Permalink to this definition">¶</a></dt>
<dd><p>computes mean value  in the designed spectral zone
Consider array as real even if itype is 1</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.median">
<tt class="descname">median</tt><big>(</big><big>)</big><a class="headerlink" href="#NPKData.NPKData.median" title="Permalink to this definition">¶</a></dt>
<dd><p>Executes a median filter on the data-set (1D or 2D).a window of x 
points (or y by x in 2D) is moved along the data set, the point are 
ordered, and the indexth point is taken as the new point for the 
data set.</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.minus">
<tt class="descname">minus</tt><big>(</big><big>)</big><a class="headerlink" href="#NPKData.NPKData.minus" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets to zero the positive part of the data set
see also :  minus, zeroing</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.modulus">
<tt class="descname">modulus</tt><big>(</big><big>)</big><a class="headerlink" href="#NPKData.NPKData.modulus" title="Permalink to this definition">¶</a></dt>
<dd><p>takes the modulus of the dataset
depends on the value f axis(i).itype</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.mult">
<tt class="descname">mult</tt><big>(</big><em>multiplier</em><big>)</big><a class="headerlink" href="#NPKData.NPKData.mult" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply data-set by a scalar
eg : d.mult(alpha) multiplies d buffer by alpha</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.mult_by_vector">
<tt class="descname">mult_by_vector</tt><big>(</big><em>axis</em>, <em>vector</em>, <em>mode='real'</em><big>)</big><a class="headerlink" href="#NPKData.NPKData.mult_by_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>multiply the data-set by a vector, along a given axis
if mode == &#8220;real&#8221;, does it point by point regardles of itype
if mode == &#8220;complex&#8221; uses axis.itype to determine how handle complex values</p>
<blockquote>
<div>in all cases vector can be real or complex</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.peak">
<tt class="descname">peak</tt><big>(</big><em>pos_neg=1</em>, <em>threshold=0.1</em>, <em>offset=None</em><big>)</big><a class="headerlink" href="#NPKData.NPKData.peak" title="Permalink to this definition">¶</a></dt>
<dd><p>first trial for peakpicker
1D only
pos_neg = 1 / -1 / 0   :  type of peaks positive / negative / 
threshold = minimum level, as absolute value
self.peaks : index of the peaks
self.peaks_ordered : index of the ordered peaks from maximum to minimum.</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.peaks2d">
<tt class="descname">peaks2d</tt><big>(</big><em>threshold=0.1</em>, <em>zoom=None</em>, <em>value=False</em><big>)</big><a class="headerlink" href="#NPKData.NPKData.peaks2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract peaks from 2d Array dataset
if value is True, return the magnitude at position (x,y)</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.phase">
<tt class="descname">phase</tt><big>(</big><em>ph0</em>, <em>ph1</em>, <em>axis=0</em><big>)</big><a class="headerlink" href="#NPKData.NPKData.phase" title="Permalink to this definition">¶</a></dt>
<dd><p>apply a phase correction along given axis
phase corrections are in degree</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.plane">
<tt class="descname">plane</tt><big>(</big><em>axis</em>, <em>i</em><big>)</big><a class="headerlink" href="#NPKData.NPKData.plane" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a 2D extracted from the current 3D at position 0&lt;=i&lt;=size1-1</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.plus">
<tt class="descname">plus</tt><big>(</big><big>)</big><a class="headerlink" href="#NPKData.NPKData.plus" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets to zero the negative part of the data set
see also :  minus, zeroing</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.proj">
<tt class="descname">proj</tt><big>(</big><em>axis=0</em>, <em>projtype='s'</em><big>)</big><a class="headerlink" href="#NPKData.NPKData.proj" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a projection of the dataset on the given axis
projtype determines the algorithm :</p>
<blockquote>
<div>&#8220;s&#8221; is for skyline projection (the highest point is retained)
&#8220;m&#8221; is for mean,</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.real">
<tt class="descname">real</tt><big>(</big><em>axis=0</em><big>)</big><a class="headerlink" href="#NPKData.NPKData.real" title="Permalink to this definition">¶</a></dt>
<dd><p>This command extract the real part of the current the data set 
considered as complex.
&lt;ul&gt;
&lt;li&gt;axis is not needed in 1D, 
&lt;li&gt;can be F1, F2 or F12 in 2D,
&lt;li&gt;and can be F1, F2, F3, F12, F13, F23, or F123 in 3D.
&lt;/ul&gt;</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.report">
<tt class="descname">report</tt><big>(</big><big>)</big><a class="headerlink" href="#NPKData.NPKData.report" title="Permalink to this definition">¶</a></dt>
<dd><p>reports itself</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.reverse">
<tt class="descname">reverse</tt><big>(</big><em>axis=0</em><big>)</big><a class="headerlink" href="#NPKData.NPKData.reverse" title="Permalink to this definition">¶</a></dt>
<dd><p>reverse the order of the current data-set (i.e. first points are 
last, last points are first).
If dataset is complex, REVERSE will reverse the complex  vector (2  by 2).</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.revf">
<tt class="descname">revf</tt><big>(</big><em>axis=0</em><big>)</big><a class="headerlink" href="#NPKData.NPKData.revf" title="Permalink to this definition">¶</a></dt>
<dd><p>Processes FID data-sets by multiplying by -1 2 points out of 4. 
Permits to preprocess Bruker FIDs in Dim 2 (Bruker trick) before 
RFT, or permits to bring back zero frequency in the center for some 
other data formats</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.rfft">
<tt class="descname">rfft</tt><big>(</big><em>axis=0</em><big>)</big><a class="headerlink" href="#NPKData.NPKData.rfft" title="Permalink to this definition">¶</a></dt>
<dd><p>computes the real Fourier transform,
takes real time domain data and returns complex frequency domain data</p>
<p>see test_axis for information on axis</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.row">
<tt class="descname">row</tt><big>(</big><em>i</em><big>)</big><a class="headerlink" href="#NPKData.NPKData.row" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a 1D extracted from the current 2D at position 0&lt;=i&lt;=size1-1</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.save">
<tt class="descname">save</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#NPKData.NPKData.save" title="Permalink to this definition">¶</a></dt>
<dd><p>save data to a file</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.save_csv">
<tt class="descname">save_csv</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#NPKData.NPKData.save_csv" title="Permalink to this definition">¶</a></dt>
<dd><p>save 1D data in csv,
in 2 columns : 
x, y   x values are conditions by the .units attribute
data attributes are stored as pseudo comments</p>
<p>data can be read back with File.csv.Import_1D()</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.save_txt">
<tt class="descname">save_txt</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#NPKData.NPKData.save_txt" title="Permalink to this definition">¶</a></dt>
<dd><p>save 1D data in texte, single column, no unit - with attributes as pseudo comments</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.set_buffer">
<tt class="descname">set_buffer</tt><big>(</big><em>buff</em><big>)</big><a class="headerlink" href="#NPKData.NPKData.set_buffer" title="Permalink to this definition">¶</a></dt>
<dd><p>modify the internal buffer of the NPKData.
allows real or complex arrays to be used
remarks</p>
<blockquote>
<div><ul class="simple">
<li>see get_buffer()</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.set_col">
<tt class="descname">set_col</tt><big>(</big><em>i</em>, <em>d1D</em><big>)</big><a class="headerlink" href="#NPKData.NPKData.set_col" title="Permalink to this definition">¶</a></dt>
<dd><p>set into the current 2D the given 1D, as the column at position 0&lt;=i&lt;=size2-1</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.set_row">
<tt class="descname">set_row</tt><big>(</big><em>i</em>, <em>d1D</em><big>)</big><a class="headerlink" href="#NPKData.NPKData.set_row" title="Permalink to this definition">¶</a></dt>
<dd><p>set into the current 2D the given 1D, as the row at position 0&lt;=i&lt;=size1-1</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.sg">
<tt class="descname">sg</tt><big>(</big><em>window_size</em>, <em>order</em>, <em>deriv=0</em>, <em>axis=0</em><big>)</big><a class="headerlink" href="#NPKData.NPKData.sg" title="Permalink to this definition">¶</a></dt>
<dd><p>applies saviski-golay of order filter to data
window_size : int</p>
<blockquote>
<div>the length of the window. Must be an odd integer number.</div></blockquote>
<dl class="docutils">
<dt>order <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>the order of the polynomial used in the filtering.
Must be less than <cite>window_size</cite> - 1.</dd>
<dt>deriv: int</dt>
<dd>the order of the derivative to compute (default = 0 means only smoothing)</dd>
<dt>axis: int</dt>
<dd>the axis on which the filter is to be applied, default is fastest varying dimension</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.sg2D">
<tt class="descname">sg2D</tt><big>(</big><em>window_size</em>, <em>order</em>, <em>deriv=None</em><big>)</big><a class="headerlink" href="#NPKData.NPKData.sg2D" title="Permalink to this definition">¶</a></dt>
<dd><p>applies a 2D saviski-golay of order filter to data
window_size : int</p>
<blockquote>
<div>the length of the square window. Must be an odd integer number.</div></blockquote>
<dl class="docutils">
<dt>order <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>the order of the polynomial used in the filtering.
Must be less than <cite>window_size</cite> - 1.</dd>
<dt>deriv: None, &#8216;col&#8217;, or &#8216;row&#8217;.   &#8216;both&#8217; mode does not work.</dt>
<dd>the direction of the derivative to compute (default = None means only smoothing)</dd>
</dl>
<p>can be applied to a 2D only.</p>
</dd></dl>

<dl class="attribute">
<dt id="NPKData.NPKData.size1">
<tt class="descname">size1</tt><a class="headerlink" href="#NPKData.NPKData.size1" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the size of the F1 spectral axis in 1D 2D and 3D
i.e. the unique axis in 1D, the slowest axis in 2D and 3D
warning, if data along axis is complex, the size is twice the number of complex pairs</p>
</dd></dl>

<dl class="attribute">
<dt id="NPKData.NPKData.size2">
<tt class="descname">size2</tt><a class="headerlink" href="#NPKData.NPKData.size2" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the size of the F2 spectral axis in 2D and 3D
i.e. the slowest axis in 2D and the intermediate in 3D
warning, if data along axis is complex, the size is twice the number of complex pairs</p>
</dd></dl>

<dl class="attribute">
<dt id="NPKData.NPKData.size3">
<tt class="descname">size3</tt><a class="headerlink" href="#NPKData.NPKData.size3" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the size of the F3 spectral axis in 3D
i.e. the slowest axis in 3D
warning, if data along axis is complex, the size is twice the number of complex pairs</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.spline_interpolate">
<tt class="descname">spline_interpolate</tt><big>(</big><em>xpoints</em>, <em>axis='F2'</em>, <em>kind=3</em><big>)</big><a class="headerlink" href="#NPKData.NPKData.spline_interpolate" title="Permalink to this definition">¶</a></dt>
<dd><p>compute and applies a spline function as a baseline correction</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.std">
<tt class="descname">std</tt><big>(</big><em>zone</em><big>)</big><a class="headerlink" href="#NPKData.NPKData.std" title="Permalink to this definition">¶</a></dt>
<dd><p>computes standard deviation in the designed spectral zone
Computes value on the real part only ** CHANGED ON July 2012 **</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.swap">
<tt class="descname">swap</tt><big>(</big><em>axis=0</em><big>)</big><a class="headerlink" href="#NPKData.NPKData.swap" title="Permalink to this definition">¶</a></dt>
<dd><p>swap both parth to complex
this is the opposite of swa()
&gt;&gt;&gt;aa=NPKData(buffer=arange(8.))
&gt;&gt;&gt;aa.axis1.itype=1
&gt;&gt;&gt;print aa.buffer
array([ 0.,  1.,  2.,  3.,  4.,  5.,  6.,  7.])
&gt;&gt;&gt;print aa.swa().buffer
array([ 0.,  4.,  1.,  5.,  2.,  6.,  3.,  7.])</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.test_axis">
<tt class="descname">test_axis</tt><big>(</big><em>axis=0</em><big>)</big><a class="headerlink" href="#NPKData.NPKData.test_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>tests on axis</p>
<dl class="docutils">
<dt>in 1D,  axis is not used</dt>
<dd>axis has to be 1 or &#8220;F1&#8221;</dd>
<dt>in 2D,  axis is either 2 for horizontal / faster incremented dimension  == &#8220;F2&#8221;</dt>
<dd>or 1 for the other dimension == &#8220;F1&#8221;
defaut is 2</dd>
<dt>in 3D, axis is 3, 2 or 1 with 3 the faster incremented and 1 the slower == F3 F2 F1</dt>
<dd>defaut is 3</dd>
</dl>
<p>alternativaly, you may use the strings &#8220;F1&#8221;, &#8220;F2&#8221; or &#8220;F3&#8221;
BUT not F12 F23 as 
0 is rest to default</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.transpose">
<tt class="descname">transpose</tt><big>(</big><em>axis=0</em><big>)</big><a class="headerlink" href="#NPKData.NPKData.transpose" title="Permalink to this definition">¶</a></dt>
<dd><p>Transposes the 2D matrix or planes of the 3D cube. The sizes of 
the matrix must be a power of two for this command to be used. After 
transposition, the two dimensions are completely permuted</p>
<p>axis is used in 3D to tell which submatrices should be transposed</p>
<p>see also : sym chsize modifysize</p>
</dd></dl>

<dl class="attribute">
<dt id="NPKData.NPKData.units">
<tt class="descname">units</tt><a class="headerlink" href="#NPKData.NPKData.units" title="Permalink to this definition">¶</a></dt>
<dd><p>copy units to all the axes</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.unswap">
<tt class="descname">unswap</tt><big>(</big><em>axis=0</em><big>)</big><a class="headerlink" href="#NPKData.NPKData.unswap" title="Permalink to this definition">¶</a></dt>
<dd><p>this is the opposite of swap()
&gt;&gt;&gt;aa=NPKData(buffer=arange(8.))
&gt;&gt;&gt;aa.axis1.itype=1
&gt;&gt;&gt;print aa.buffer
array([ 0.,  1.,  2.,  3.,  4.,  5.,  6.,  7.])
&gt;&gt;&gt;print aa.unswa().buffer
array([ 0.,  2.,  4.,  6.,  1.,  3.,  5.,  7.])</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.urqrd">
<tt class="descname">urqrd</tt><big>(</big><em>k</em>, <em>orda=None</em>, <em>iterations=1</em>, <em>axis=0</em><big>)</big><a class="headerlink" href="#NPKData.NPKData.urqrd" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply urQRd denoising to data
k is about 2 x number_of_expected_lines
Manages real and complex cases.
Handles the case of hypercomplex for denoising of 2D FTICR for example.</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.xcol">
<tt class="descname">xcol</tt><big>(</big><em>start=0</em>, <em>stop=None</em>, <em>step=1</em><big>)</big><a class="headerlink" href="#NPKData.NPKData.xcol" title="Permalink to this definition">¶</a></dt>
<dd><p>an iterator over columns of a 2D
so 
for c in matrix.xcol():</p>
<blockquote>
<div>do something with c...</div></blockquote>
<p>is equivalent to
for i in range(matrix.size2):     # i.e. all cols</p>
<blockquote>
<div>c = matrix.col(i)
do something with c...</div></blockquote>
<p>you can limit the range by giving start, stop and step arguments - using the same syntax as xrange()</p>
<p>on hypercomplex data
matrix.xcol( step=matrix.axis2.itype+1 )
will step only on cols associated to the real point</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.xrow">
<tt class="descname">xrow</tt><big>(</big><em>start=0</em>, <em>stop=None</em>, <em>step=1</em><big>)</big><a class="headerlink" href="#NPKData.NPKData.xrow" title="Permalink to this definition">¶</a></dt>
<dd><p>an iterator over rows of a 2D
so 
for r in matrix.xrow():</p>
<blockquote>
<div>do something with r...</div></blockquote>
<p>is equivalent to
for i in range(matrix.size1):     # i.e. all rows</p>
<blockquote>
<div>r = matrix.row(i)
do something with r...</div></blockquote>
<p>you can limit the range by giving start, stop and step arguments - using the same syntax as xrange()</p>
<p>on hypercomplex data
matrix.xrow( step=matrix.axis1.itype+1 )
will step only on rows associated to the real point</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.zeroing">
<tt class="descname">zeroing</tt><big>(</big><em>threshold</em><big>)</big><a class="headerlink" href="#NPKData.NPKData.zeroing" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets to zero points below threshold (in absolute value)
see also :  plus, minus</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.zf">
<tt class="descname">zf</tt><big>(</big><em>zf1=None</em>, <em>zf2=None</em>, <em>zf3=None</em><big>)</big><a class="headerlink" href="#NPKData.NPKData.zf" title="Permalink to this definition">¶</a></dt>
<dd><p>Zerofill data by adding zeros.
for a dataset of length size, will add zeros up to zf*size</p>
<p>do nothing by default unless axis is sampled,
in which case, missing unsampled points are replaced by 0.0</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKData.zoom">
<tt class="descname">zoom</tt><big>(</big><em>dim</em>, <em>*args</em><big>)</big><a class="headerlink" href="#NPKData.NPKData.zoom" title="Permalink to this definition">¶</a></dt>
<dd><p>The basic command for defining region of interest window</p>
<ul class="simple">
<li>if n=0, zoom mode is off.</li>
<li>if n=1, zoom mode is on,</li>
</ul>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="NPKData.NPKDataTests">
<em class="property">class </em><tt class="descclassname">NPKData.</tt><tt class="descname">NPKDataTests</tt><big>(</big><em>methodName='runTest'</em><big>)</big><a class="headerlink" href="#NPKData.NPKDataTests" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Testing NPKData basic behaviour -</li>
</ul>
<dl class="method">
<dt id="NPKData.NPKDataTests.test_dampingunit">
<tt class="descname">test_dampingunit</tt><big>(</big><big>)</big><a class="headerlink" href="#NPKData.NPKDataTests.test_dampingunit" title="Permalink to this definition">¶</a></dt>
<dd><p>test itod and dtoi</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKDataTests.test_fft">
<tt class="descname">test_fft</tt><big>(</big><big>)</big><a class="headerlink" href="#NPKData.NPKDataTests.test_fft" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Testing FFT methods -</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKDataTests.test_flatten">
<tt class="descname">test_flatten</tt><big>(</big><big>)</big><a class="headerlink" href="#NPKData.NPKDataTests.test_flatten" title="Permalink to this definition">¶</a></dt>
<dd><p>test the flatten utility</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKDataTests.test_hypercomplex_modulus">
<tt class="descname">test_hypercomplex_modulus</tt><big>(</big><big>)</big><a class="headerlink" href="#NPKData.NPKDataTests.test_hypercomplex_modulus" title="Permalink to this definition">¶</a></dt>
<dd><p>Test of hypercomplex modulus</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKDataTests.test_load">
<tt class="descname">test_load</tt><big>(</big><big>)</big><a class="headerlink" href="#NPKData.NPKDataTests.test_load" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Testing load methods</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKDataTests.test_math">
<tt class="descname">test_math</tt><big>(</big><big>)</big><a class="headerlink" href="#NPKData.NPKDataTests.test_math" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Testing math methods -</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKDataTests.test_peaks1d">
<tt class="descname">test_peaks1d</tt><big>(</big><big>)</big><a class="headerlink" href="#NPKData.NPKDataTests.test_peaks1d" title="Permalink to this definition">¶</a></dt>
<dd><p>test 1D peak picker</p>
</dd></dl>

<dl class="method">
<dt id="NPKData.NPKDataTests.test_peaks2d">
<tt class="descname">test_peaks2d</tt><big>(</big><big>)</big><a class="headerlink" href="#NPKData.NPKDataTests.test_peaks2d" title="Permalink to this definition">¶</a></dt>
<dd><p>test 2D peak picker</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="NPKData.as_cpx">
<tt class="descclassname">NPKData.</tt><tt class="descname">as_cpx</tt><big>(</big><em>arr</em><big>)</big><a class="headerlink" href="#NPKData.as_cpx" title="Permalink to this definition">¶</a></dt>
<dd><p>interpret arr as a complex array
useful to move between complex and real arrays (see as_float)</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">as_cpx</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">4.0</span><span class="p">))</span>
<span class="go">[ 0.+1.j  2.+3.j]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="NPKData.as_float">
<tt class="descclassname">NPKData.</tt><tt class="descname">as_float</tt><big>(</big><em>arr</em><big>)</big><a class="headerlink" href="#NPKData.as_float" title="Permalink to this definition">¶</a></dt>
<dd><p>interpret arr as a float array
useful to move between complex and real arrays (see as_float)</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">as_float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="p">))</span>
<span class="go">[ 0.  0.  1.  1.  2.  2.  3.  3.]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="NPKData.conj_ip">
<tt class="descclassname">NPKData.</tt><tt class="descname">conj_ip</tt><big>(</big><em>a</em><big>)</big><a class="headerlink" href="#NPKData.conj_ip" title="Permalink to this definition">¶</a></dt>
<dd><p>computes conjugate() in-place</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">conj_ip</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="p">))</span>
<span class="go">[ 0.-0.j  1.-1.j  2.-2.j  3.-3.j]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="NPKData.copyaxes">
<tt class="descclassname">NPKData.</tt><tt class="descname">copyaxes</tt><big>(</big><em>inp</em>, <em>out</em><big>)</big><a class="headerlink" href="#NPKData.copyaxes" title="Permalink to this definition">¶</a></dt>
<dd><p>copy axes values from NPKDAta in to out.</p>
<p>internal use</p>
</dd></dl>

<dl class="function">
<dt id="NPKData.flatten">
<tt class="descclassname">NPKData.</tt><tt class="descname">flatten</tt><big>(</big><em>*arg</em><big>)</big><a class="headerlink" href="#NPKData.flatten" title="Permalink to this definition">¶</a></dt>
<dd><p>flatten recursively a list of lists</p>
<p>&gt;&gt;&gt;print flatten( ( (1,2), 3, (4, (5,), (6,7) ) ) )
[1, 2, 3, 4, 5, 6, 7]</p>
</dd></dl>

<dl class="function">
<dt id="NPKData.hypercomplex_modulus">
<tt class="descclassname">NPKData.</tt><tt class="descname">hypercomplex_modulus</tt><big>(</big><em>arr</em>, <em>size1</em>, <em>size2</em><big>)</big><a class="headerlink" href="#NPKData.hypercomplex_modulus" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the modulus of an array of hypercomplex numbers.
input:</p>
<blockquote>
<div>arr : hypercomplex array
size1 : size counting horizontally each half quadrant.
size2 : siez counting vertically each half quadrant.</div></blockquote>
<dl class="docutils">
<dt>eg:</dt>
<dd>arr = np.array([[1, 4],[3, 7],[1, 9],[5, 7]])
is an hypercomplex with size1 = 2 and size2 = 2</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="NPKData.warning">
<tt class="descclassname">NPKData.</tt><tt class="descname">warning</tt><big>(</big><em>msg</em><big>)</big><a class="headerlink" href="#NPKData.warning" title="Permalink to this definition">¶</a></dt>
<dd><p>issue a warning message to the user</p>
</dd></dl>

</div>
<div class="section" id="file-formats">
<h2>File formats<a class="headerlink" href="#file-formats" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-File.Apex">
<span id="apex"></span><h3>Apex<a class="headerlink" href="#module-File.Apex" title="Permalink to this headline">¶</a></h3>
<p>Utility to Handle Apex files</p>
<dl class="function">
<dt id="File.Apex.Import_1D">
<tt class="descclassname">File.Apex.</tt><tt class="descname">Import_1D</tt><big>(</big><em>folder</em>, <em>outfile=''</em><big>)</big><a class="headerlink" href="#File.Apex.Import_1D" title="Permalink to this definition">¶</a></dt>
<dd><p>Entry point to import 1D spectra
It returns a FTICRData
It writes a HDF5 file if an outfile is mentionned</p>
</dd></dl>

<dl class="function">
<dt id="File.Apex.Import_2D">
<tt class="descclassname">File.Apex.</tt><tt class="descname">Import_2D</tt><big>(</big><em>folder</em>, <em>outfile=''</em>, <em>F1specwidth=None</em><big>)</big><a class="headerlink" href="#File.Apex.Import_2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Entry point to import 2D spectra
It returns a FTICRData
It writes a HDF5 file if an outfile is mentionned</p>
</dd></dl>

<dl class="function">
<dt id="File.Apex.Ser2D_to_H5f">
<tt class="descclassname">File.Apex.</tt><tt class="descname">Ser2D_to_H5f</tt><big>(</big><em>sizeF1</em>, <em>sizeF2</em>, <em>filename='ser'</em>, <em>outfile='H5f.h5'</em>, <em>chunks=None</em><big>)</big><a class="headerlink" href="#File.Apex.Ser2D_to_H5f" title="Permalink to this definition">¶</a></dt>
<dd><p>Charge any ser file directly in H5f file</p>
</dd></dl>

<dl class="function">
<dt id="File.Apex.get_param">
<tt class="descclassname">File.Apex.</tt><tt class="descname">get_param</tt><big>(</big><em>param</em>, <em>names</em>, <em>values</em><big>)</big><a class="headerlink" href="#File.Apex.get_param" title="Permalink to this definition">¶</a></dt>
<dd><p>From params, this function returns the  value of the given param</p>
</dd></dl>

<dl class="function">
<dt id="File.Apex.locate_acquisition">
<tt class="descclassname">File.Apex.</tt><tt class="descname">locate_acquisition</tt><big>(</big><em>folder</em><big>)</big><a class="headerlink" href="#File.Apex.locate_acquisition" title="Permalink to this definition">¶</a></dt>
<dd><p>From the given folder this function return the absolute path to the apexAcquisition.method file
It should always be in a subfolder</p>
</dd></dl>

<dl class="function">
<dt id="File.Apex.read_2D">
<tt class="descclassname">File.Apex.</tt><tt class="descname">read_2D</tt><big>(</big><em>sizeF1</em>, <em>sizeF2</em>, <em>filename='ser'</em><big>)</big><a class="headerlink" href="#File.Apex.read_2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads in a Apex 2D fid</p>
<p>sizeF1 is the number of fid
sizeF2 is the number of data-points in the fid
uses array</p>
</dd></dl>

<dl class="function">
<dt id="File.Apex.read_3D">
<tt class="descclassname">File.Apex.</tt><tt class="descname">read_3D</tt><big>(</big><em>sizeF1</em>, <em>sizeF2</em>, <em>sizeF3</em>, <em>filename='ser'</em><big>)</big><a class="headerlink" href="#File.Apex.read_3D" title="Permalink to this definition">¶</a></dt>
<dd><p>Ebauche de fonction</p>
<p>Reads in a Apex 3D fid</p>
<p>uses array</p>
</dd></dl>

<dl class="function">
<dt id="File.Apex.read_param">
<tt class="descclassname">File.Apex.</tt><tt class="descname">read_param</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#File.Apex.read_param" title="Permalink to this definition">¶</a></dt>
<dd><p>Open the given file and retrieve all parameters written initially for apexAcquisition.method
NC is written when no value for value is found</p>
<p>structure : &lt;param&gt;&lt;name&gt;C_MsmsE&lt;/name&gt;&lt;value&gt;0.0&lt;/value&gt;&lt;/param&gt;</p>
<p>read_param returns  values in a dictionnary</p>
</dd></dl>

<dl class="function">
<dt id="File.Apex.read_scan">
<tt class="descclassname">File.Apex.</tt><tt class="descname">read_scan</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#File.Apex.read_scan" title="Permalink to this definition">¶</a></dt>
<dd><p>Function that returns the number of scan that have been recorded
It is used to see wether the number of recorded points correspond to the L_20 parameter</p>
</dd></dl>

<dl class="function">
<dt id="File.Apex.write_ser">
<tt class="descclassname">File.Apex.</tt><tt class="descname">write_ser</tt><big>(</big><em>bufferdata</em>, <em>filename='ser'</em><big>)</big><a class="headerlink" href="#File.Apex.write_ser" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a ser file from FTICRData</p>
</dd></dl>

<span class="target" id="module-File.csv"></span><p>Utility to import and export data in text and csv files</p>
<p>all functions compress transparently if the filenales end with .gz
Marc-André adapted from some Lionel code</p>
<dl class="function">
<dt id="File.csv.Import_1D">
<tt class="descclassname">File.csv.</tt><tt class="descname">Import_1D</tt><big>(</big><em>filename</em>, <em>column=0</em>, <em>delimiter='</em>, <em>'</em><big>)</big><a class="headerlink" href="#File.csv.Import_1D" title="Permalink to this definition">¶</a></dt>
<dd><p>import a 1D file stored as csv
header as comments (#)
parameters in pseudocomments :</p>
<blockquote>
<div>#$key value</div></blockquote>
<p>then one value per line
column and delimiter  as in load()</p>
</dd></dl>

<dl class="class">
<dt id="File.csv.NPKDataTests">
<em class="property">class </em><tt class="descclassname">File.csv.</tt><tt class="descname">NPKDataTests</tt><big>(</big><em>methodName='runTest'</em><big>)</big><a class="headerlink" href="#File.csv.NPKDataTests" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Testing NPKData basic behaviour -</li>
</ul>
</dd></dl>

<dl class="function">
<dt id="File.csv.load">
<tt class="descclassname">File.csv.</tt><tt class="descname">load</tt><big>(</big><em>filename</em>, <em>column=0</em>, <em>delimiter='</em>, <em>'</em><big>)</big><a class="headerlink" href="#File.csv.load" title="Permalink to this definition">¶</a></dt>
<dd><p>load 1D data from txt or csv file,
attribute are in pseuo-coments startin with #$
value are in columns, separated by delimiter - only the columun given in arg will be loaded
column = 0 is fine for text files
column = 1 is fine for csv files with units
returns a numpy buffer and an attribute dictionary</p>
</dd></dl>

<dl class="function">
<dt id="File.csv.save">
<tt class="descclassname">File.csv.</tt><tt class="descname">save</tt><big>(</big><em>data</em>, <em>filename</em>, <em>delimiter='</em>, <em>'</em><big>)</big><a class="headerlink" href="#File.csv.save" title="Permalink to this definition">¶</a></dt>
<dd><p>save 1D data in txt, single column, no unit - with attributes as pseudo comments</p>
</dd></dl>

<dl class="function">
<dt id="File.csv.save_unit">
<tt class="descclassname">File.csv.</tt><tt class="descname">save_unit</tt><big>(</big><em>data</em>, <em>filename</em>, <em>delimiter='</em>, <em>'</em><big>)</big><a class="headerlink" href="#File.csv.save_unit" title="Permalink to this definition">¶</a></dt>
<dd><p>save 1D data in csv,
in 2 columns, with attributes as pseudo comments</p>
</dd></dl>

</div>
<div class="section" id="module-File.GifaFile">
<span id="gifafile"></span><h3>GifaFile<a class="headerlink" href="#module-File.GifaFile" title="Permalink to this headline">¶</a></h3>
<p>GifaFile.py</p>
<p>Created by Marc-André on 2010-03-17.
Copyright (c) 2010 IGBMC. All rights reserved.</p>
<p>This module provides a simple access to NMR files in the Gifa format.</p>
<dl class="class">
<dt id="File.GifaFile.GifaFile">
<em class="property">class </em><tt class="descclassname">File.GifaFile.</tt><tt class="descname">GifaFile</tt><big>(</big><em>fname</em>, <em>access='r'</em>, <em>debug=0</em><big>)</big><a class="headerlink" href="#File.GifaFile.GifaFile" title="Permalink to this definition">¶</a></dt>
<dd><p>defines the interface to simply (read/write) acces Gifa v4 files
standard methods are load() and save()</p>
<p>standard sequence to read is
F = GifaFile(filename,&#8221;r&#8221;)
B = F.get_data()      # B is a NPKdata
F.close()</p>
<p>or
F = GifaFile(filename,&#8221;r&#8221;)
F.load()
B = F.data      # B is a NPKdata
F.close()</p>
<p>and to write
F = GifaFile(filename,&#8221;w&#8221;)
F.set_data(B)         # where B is a NPKdata; do not use    F.data = B
F.save()
F.close()</p>
<p>The file consists of a header (of size headersize) and data
The header is handled as a dictionnary  self.header
data is handled as a NPKdata    self.data</p>
<blockquote>
<div>so numpy ndarray are in                self.data.buffer</div></blockquote>
<dl class="attribute">
<dt id="File.GifaFile.GifaFile.byte_order">
<tt class="descname">byte_order</tt><a class="headerlink" href="#File.GifaFile.GifaFile.byte_order" title="Permalink to this definition">¶</a></dt>
<dd><p>pour intel</p>
</dd></dl>

<dl class="method">
<dt id="File.GifaFile.GifaFile.close">
<tt class="descname">close</tt><big>(</big><big>)</big><a class="headerlink" href="#File.GifaFile.GifaFile.close" title="Permalink to this definition">¶</a></dt>
<dd><p>closes the associated file</p>
</dd></dl>

<dl class="method">
<dt id="File.GifaFile.GifaFile.copyaxesfromheader">
<tt class="descname">copyaxesfromheader</tt><big>(</big><em>n_axis</em><big>)</big><a class="headerlink" href="#File.GifaFile.GifaFile.copyaxesfromheader" title="Permalink to this definition">¶</a></dt>
<dd><p>get values from axis &#8220;n_axis&#8221; from header, and creates and returns a new (NMRAxis) axis with this values
itype is not handled (not coded per axis in header)
used internally</p>
</dd></dl>

<dl class="method">
<dt id="File.GifaFile.GifaFile.copydiffaxesfromheader">
<tt class="descname">copydiffaxesfromheader</tt><big>(</big><big>)</big><a class="headerlink" href="#File.GifaFile.GifaFile.copydiffaxesfromheader" title="Permalink to this definition">¶</a></dt>
<dd><p>get values from axis &#8220;n&#8221; from header, and creates and returns a new (LaplaceAxis) axis with this values
used internally</p>
</dd></dl>

<dl class="attribute">
<dt id="File.GifaFile.GifaFile.dim">
<tt class="descname">dim</tt><a class="headerlink" href="#File.GifaFile.GifaFile.dim" title="Permalink to this definition">¶</a></dt>
<dd><p>dimensionality of the dataset 1 2 or 3</p>
</dd></dl>

<dl class="method">
<dt id="File.GifaFile.GifaFile.get_data">
<tt class="descname">get_data</tt><big>(</big><big>)</big><a class="headerlink" href="#File.GifaFile.GifaFile.get_data" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the NPKdata attached to the (read) file</p>
</dd></dl>

<dl class="attribute">
<dt id="File.GifaFile.GifaFile.itype">
<tt class="descname">itype</tt><a class="headerlink" href="#File.GifaFile.GifaFile.itype" title="Permalink to this definition">¶</a></dt>
<dd><p>Real/complex type of the dataset
in 1D :     0 : real  1: complex
in 2D :     0 : real on both;</p>
<blockquote>
<div>1 : complex on F2
2 : complex on F1
3 : complex on both</div></blockquote>
<dl class="docutils">
<dt>in 3D <span class="classifier-delimiter">:</span> <span class="classifier">0</span> <span class="classifier-delimiter">:</span> <span class="classifier">real on all; </span></dt>
<dd>1 : complex on F3
2 : complex on F2
3 : complex on F3-F2
4 : complex on F1
5 : complex on F1-F3
6 : complex on F1-F2
7 : complex on all</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="File.GifaFile.GifaFile.load">
<tt class="descname">load</tt><big>(</big><big>)</big><a class="headerlink" href="#File.GifaFile.GifaFile.load" title="Permalink to this definition">¶</a></dt>
<dd><p>creates a NPKdata loaded with the file content</p>
</dd></dl>

<dl class="method">
<dt id="File.GifaFile.GifaFile.load_header">
<tt class="descname">load_header</tt><big>(</big><big>)</big><a class="headerlink" href="#File.GifaFile.GifaFile.load_header" title="Permalink to this definition">¶</a></dt>
<dd><p>load the header from file and set-up every thing</p>
</dd></dl>

<dl class="attribute">
<dt id="File.GifaFile.GifaFile.nblock1">
<tt class="descname">nblock1</tt><a class="headerlink" href="#File.GifaFile.GifaFile.nblock1" title="Permalink to this definition">¶</a></dt>
<dd><p>number of data block on disk along F1 axis</p>
</dd></dl>

<dl class="attribute">
<dt id="File.GifaFile.GifaFile.nblock2">
<tt class="descname">nblock2</tt><a class="headerlink" href="#File.GifaFile.GifaFile.nblock2" title="Permalink to this definition">¶</a></dt>
<dd><p>number of data block on disk along F2 axis</p>
</dd></dl>

<dl class="attribute">
<dt id="File.GifaFile.GifaFile.nblock3">
<tt class="descname">nblock3</tt><a class="headerlink" href="#File.GifaFile.GifaFile.nblock3" title="Permalink to this definition">¶</a></dt>
<dd><p>number of data block on disk along F3 axis</p>
</dd></dl>

<dl class="method">
<dt id="File.GifaFile.GifaFile.read_header">
<tt class="descname">read_header</tt><big>(</big><big>)</big><a class="headerlink" href="#File.GifaFile.GifaFile.read_header" title="Permalink to this definition">¶</a></dt>
<dd><p>return a dictionnary of the file header
internal use</p>
</dd></dl>

<dl class="method">
<dt id="File.GifaFile.GifaFile.readc">
<tt class="descname">readc</tt><big>(</big><big>)</big><a class="headerlink" href="#File.GifaFile.GifaFile.readc" title="Permalink to this definition">¶</a></dt>
<dd><p>read a file in Gifa format, and returns the binary buffer as a numpy array
internal use - use load()</p>
</dd></dl>

<dl class="method">
<dt id="File.GifaFile.GifaFile.report">
<tt class="descname">report</tt><big>(</big><big>)</big><a class="headerlink" href="#File.GifaFile.GifaFile.report" title="Permalink to this definition">¶</a></dt>
<dd><p>prints a little debugging report</p>
</dd></dl>

<dl class="method">
<dt id="File.GifaFile.GifaFile.save">
<tt class="descname">save</tt><big>(</big><big>)</big><a class="headerlink" href="#File.GifaFile.GifaFile.save" title="Permalink to this definition">¶</a></dt>
<dd><p>save the NPKdata to the file</p>
</dd></dl>

<dl class="method">
<dt id="File.GifaFile.GifaFile.set_data">
<tt class="descname">set_data</tt><big>(</big><em>buff</em><big>)</big><a class="headerlink" href="#File.GifaFile.GifaFile.set_data" title="Permalink to this definition">¶</a></dt>
<dd><p>sets the NPKdata attached to the (to be written) file</p>
</dd></dl>

<dl class="method">
<dt id="File.GifaFile.GifaFile.setup_header">
<tt class="descname">setup_header</tt><big>(</big><big>)</big><a class="headerlink" href="#File.GifaFile.GifaFile.setup_header" title="Permalink to this definition">¶</a></dt>
<dd><p>setup file header, from self.data</p>
</dd></dl>

<dl class="attribute">
<dt id="File.GifaFile.GifaFile.size1">
<tt class="descname">size1</tt><a class="headerlink" href="#File.GifaFile.GifaFile.size1" title="Permalink to this definition">¶</a></dt>
<dd><p>size along the F1 axis (either 1D, or slowest varyong axis in nD)</p>
</dd></dl>

<dl class="attribute">
<dt id="File.GifaFile.GifaFile.size2">
<tt class="descname">size2</tt><a class="headerlink" href="#File.GifaFile.GifaFile.size2" title="Permalink to this definition">¶</a></dt>
<dd><p>size along the F2 axis (fastest varying in 2D)</p>
</dd></dl>

<dl class="attribute">
<dt id="File.GifaFile.GifaFile.size3">
<tt class="descname">size3</tt><a class="headerlink" href="#File.GifaFile.GifaFile.size3" title="Permalink to this definition">¶</a></dt>
<dd><p>size along the F3 axis (fastest varying in 3D)</p>
</dd></dl>

<dl class="attribute">
<dt id="File.GifaFile.GifaFile.szblock1">
<tt class="descname">szblock1</tt><a class="headerlink" href="#File.GifaFile.GifaFile.szblock1" title="Permalink to this definition">¶</a></dt>
<dd><p>size of data block on disk along F1 axis</p>
</dd></dl>

<dl class="attribute">
<dt id="File.GifaFile.GifaFile.szblock2">
<tt class="descname">szblock2</tt><a class="headerlink" href="#File.GifaFile.GifaFile.szblock2" title="Permalink to this definition">¶</a></dt>
<dd><p>size of data block on disk along F2 axis</p>
</dd></dl>

<dl class="attribute">
<dt id="File.GifaFile.GifaFile.szblock3">
<tt class="descname">szblock3</tt><a class="headerlink" href="#File.GifaFile.GifaFile.szblock3" title="Permalink to this definition">¶</a></dt>
<dd><p>size of data block on disk along F3 axis</p>
</dd></dl>

<dl class="method">
<dt id="File.GifaFile.GifaFile.write_header">
<tt class="descname">write_header</tt><big>(</big><big>)</big><a class="headerlink" href="#File.GifaFile.GifaFile.write_header" title="Permalink to this definition">¶</a></dt>
<dd><p>write file header
setup_header() should have been called first</p>
</dd></dl>

<dl class="method">
<dt id="File.GifaFile.GifaFile.write_header_line">
<tt class="descname">write_header_line</tt><big>(</big><em>key</em><big>)</big><a class="headerlink" href="#File.GifaFile.GifaFile.write_header_line" title="Permalink to this definition">¶</a></dt>
<dd><p>write into the header the entry key
returns the number of byte written
internal use</p>
</dd></dl>

<dl class="method">
<dt id="File.GifaFile.GifaFile.writec">
<tt class="descname">writec</tt><big>(</big><big>)</big><a class="headerlink" href="#File.GifaFile.GifaFile.writec" title="Permalink to this definition">¶</a></dt>
<dd><p>write a file in Gifa format
internal use - use save()</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="File.GifaFile.GifaFileTests">
<em class="property">class </em><tt class="descclassname">File.GifaFile.</tt><tt class="descname">GifaFileTests</tt><big>(</big><em>methodName='runTest'</em><big>)</big><a class="headerlink" href="#File.GifaFile.GifaFileTests" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Testing GifaFile on various 1D and 2D files -</li>
</ul>
<dl class="attribute">
<dt id="File.GifaFile.GifaFileTests.tempfile">
<tt class="descname">tempfile</tt><em class="property"> = &lt;module 'tempfile' from '/Library/Frameworks/EPD64.framework/Versions/7.3/lib/python2.7/tempfile.pyc'&gt;</em><a class="headerlink" href="#File.GifaFile.GifaFileTests.tempfile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-File.HDF5File">
<span id="hdf5file"></span><h3>HDF5File<a class="headerlink" href="#module-File.HDF5File" title="Permalink to this headline">¶</a></h3>
<p>HDF5File.py</p>
<p>Created by Marc-André Delsuc, Marie-Aude Coutouly on 2011-07-13.
Copyright (c) 2011 __NMRTEC__. All rights reserved.</p>
<p>API dealing with HDF5File. For now it is non surclassing tables, you have to use <a href="#id1"><span class="problematic" id="id2">*</span></a>.hf. to access all tables functionalities</p>
<dl class="class">
<dt id="File.HDF5File.HDF5File">
<em class="property">class </em><tt class="descclassname">File.HDF5File.</tt><tt class="descname">HDF5File</tt><big>(</big><em>fname</em>, <em>access='r'</em>, <em>info=None</em>, <em>nparray=None</em>, <em>fticrd=None</em>, <em>debug=0</em><big>)</big><a class="headerlink" href="#File.HDF5File.HDF5File" title="Permalink to this definition">¶</a></dt>
<dd><p>defines the interface to simply (read/write) access HDF5 files
standard methods are load() and save()</p>
<p>standard sequence to read is
H = HDF5File(filename,&#8221;r&#8221;)
B = H.get_data()      # B is a FTICRdata
H.close()</p>
<p>or
H = HDF5File(filename,&#8221;r&#8221;)
H.load()
B = H.data      # B is a FTICRdata
H.close()</p>
<p>and to write
H = HDF5File(filename,&#8221;w&#8221;)
H.set_data(B)         # where B is a FTICRdata; do not use    H.data = B
H.save()
H.close()</p>
<dl class="method">
<dt id="File.HDF5File.HDF5File.axes_update">
<tt class="descname">axes_update</tt><big>(</big><em>group='resol1'</em>, <em>axis=2</em>, <em>infos=None</em><big>)</big><a class="headerlink" href="#File.HDF5File.HDF5File.axes_update" title="Permalink to this definition">¶</a></dt>
<dd><p>routine called when you want to modify the information on a given axis
group is the group name, default is resol1
axis is the dimension we want to adjust
infos is a dictionnary with al fields we want to adjust</p>
</dd></dl>

<dl class="method">
<dt id="File.HDF5File.HDF5File.checkversion">
<tt class="descname">checkversion</tt><big>(</big><big>)</big><a class="headerlink" href="#File.HDF5File.HDF5File.checkversion" title="Permalink to this definition">¶</a></dt>
<dd><p>check file version and exit if incompatible</p>
</dd></dl>

<dl class="method">
<dt id="File.HDF5File.HDF5File.close">
<tt class="descname">close</tt><big>(</big><big>)</big><a class="headerlink" href="#File.HDF5File.HDF5File.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Closes HDF5File</p>
</dd></dl>

<dl class="method">
<dt id="File.HDF5File.HDF5File.createCArray">
<tt class="descname">createCArray</tt><big>(</big><em>where</em>, <em>name</em>, <em>data_type</em>, <em>shape</em>, <em>chunk=None</em><big>)</big><a class="headerlink" href="#File.HDF5File.HDF5File.createCArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a CArray in the given hf_file</p>
</dd></dl>

<dl class="method">
<dt id="File.HDF5File.HDF5File.createGroup">
<tt class="descname">createGroup</tt><big>(</big><em>where</em>, <em>name</em><big>)</big><a class="headerlink" href="#File.HDF5File.HDF5File.createGroup" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a group in the given hf_file</p>
</dd></dl>

<dl class="method">
<dt id="File.HDF5File.HDF5File.createTable">
<tt class="descname">createTable</tt><big>(</big><em>where</em>, <em>name</em>, <em>description</em><big>)</big><a class="headerlink" href="#File.HDF5File.HDF5File.createTable" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a Table in the given hf_file at the given position with the right description</p>
</dd></dl>

<dl class="method">
<dt id="File.HDF5File.HDF5File.create_HDF5_info">
<tt class="descname">create_HDF5_info</tt><big>(</big><big>)</big><a class="headerlink" href="#File.HDF5File.HDF5File.create_HDF5_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a HDF5 file, takes info as parameter</p>
</dd></dl>

<dl class="method">
<dt id="File.HDF5File.HDF5File.create_HDF5_nparray">
<tt class="descname">create_HDF5_nparray</tt><big>(</big><big>)</big><a class="headerlink" href="#File.HDF5File.HDF5File.create_HDF5_nparray" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a HDF5 file, takes nparray as parameters</p>
</dd></dl>

<dl class="method">
<dt id="File.HDF5File.HDF5File.create_from_template">
<tt class="descname">create_from_template</tt><big>(</big><em>data</em>, <em>group='resol1'</em><big>)</big><a class="headerlink" href="#File.HDF5File.HDF5File.create_from_template" title="Permalink to this definition">¶</a></dt>
<dd><p>Take params from the empty FTICR data and put all the informations in the HDF5File
creates an empty data, and attach it to data.buffer
data is created in group, with default value &#8216;resol1&#8217;</p>
</dd></dl>

<dl class="method">
<dt id="File.HDF5File.HDF5File.create_generic">
<tt class="descname">create_generic</tt><big>(</big><em>owner='NMRTEC'</em><big>)</big><a class="headerlink" href="#File.HDF5File.HDF5File.create_generic" title="Permalink to this definition">¶</a></dt>
<dd><p>A table is created with all generic informations about the file : owner, method, HDF5 Release,CreationDate, Last modification</p>
</dd></dl>

<dl class="method">
<dt id="File.HDF5File.HDF5File.create_tables">
<tt class="descname">create_tables</tt><big>(</big><big>)</big><a class="headerlink" href="#File.HDF5File.HDF5File.create_tables" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates the different tables needed in a HDF5File according to the info parameters given 
If you don&#8217;t pass any info dictionnary, it will take parameters from the self.header</p>
</dd></dl>

<dl class="method">
<dt id="File.HDF5File.HDF5File.determine_chunkshape">
<tt class="descname">determine_chunkshape</tt><big>(</big><em>sizeF1=None</em>, <em>sizeF2=None</em><big>)</big><a class="headerlink" href="#File.HDF5File.HDF5File.determine_chunkshape" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine a good chunkshape according to the size of each axis</p>
</dd></dl>

<dl class="method">
<dt id="File.HDF5File.HDF5File.fill_table">
<tt class="descname">fill_table</tt><big>(</big><em>table</em>, <em>infos</em><big>)</big><a class="headerlink" href="#File.HDF5File.HDF5File.fill_table" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill in the given table. Axis is the dimension we are processing</p>
</dd></dl>

<dl class="method">
<dt id="File.HDF5File.HDF5File.get_data">
<tt class="descname">get_data</tt><big>(</big><em>group='resol1'</em>, <em>mode='onfile'</em><big>)</big><a class="headerlink" href="#File.HDF5File.HDF5File.get_data" title="Permalink to this definition">¶</a></dt>
<dd><p>loads and returns the FTICRdata attached to the self file
same parameters as load()</p>
</dd></dl>

<dl class="method">
<dt id="File.HDF5File.HDF5File.get_file_infos">
<tt class="descname">get_file_infos</tt><big>(</big><big>)</big><a class="headerlink" href="#File.HDF5File.HDF5File.get_file_infos" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the generic_table and return the informations</p>
</dd></dl>

<dl class="method">
<dt id="File.HDF5File.HDF5File.get_info">
<tt class="descname">get_info</tt><big>(</big><big>)</big><a class="headerlink" href="#File.HDF5File.HDF5File.get_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve info from self.nparray</p>
</dd></dl>

<dl class="method">
<dt id="File.HDF5File.HDF5File.load">
<tt class="descname">load</tt><big>(</big><em>group='resol1'</em>, <em>mode='onfile'</em><big>)</big><a class="headerlink" href="#File.HDF5File.HDF5File.load" title="Permalink to this definition">¶</a></dt>
<dd><p>loads the data into memory,
set self.data as a FTICRData</p>
<p>group defines which group is loaded (default is resol1)
mode defines how it is loaded in memory,</p>
<blockquote>
<div><dl class="docutils">
<dt>&#8220;onfile&#8221; (default ) the data is kept on file and loaded only on demand.</dt>
<dd>the capability of modifying the data is determined by the way the file was opened
the data cannot be modified unless the file was opened with access=&#8217;w&#8217; or &#8216;rw&#8217;</dd>
<dt>&#8220;memory&#8221; the data is copied to a memroy buffer and can be freely modified</dt>
<dd>warning - may saturate the computer memory, there is no control</dd>
</dl>
<p>if you want to load data into memory after having opened in &#8216;onfile&#8221; mode, then do the following :
h.load(mode=&#8221;onfile&#8221;)
b = d.data.buffer[...]     # data are now copied into a new memory buffer b using ellipsis syntax
d.data.buffer = b           # and b is used as the data buffer.</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="File.HDF5File.HDF5File.position_array">
<tt class="descname">position_array</tt><big>(</big><em>group='resol1'</em><big>)</big><a class="headerlink" href="#File.HDF5File.HDF5File.position_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill in the HDF5 file with the given buffer, HDF5 file is created with the given numpy array and the corresponding tables</p>
</dd></dl>

<dl class="method">
<dt id="File.HDF5File.HDF5File.save">
<tt class="descname">save</tt><big>(</big><em>ser_file</em>, <em>group='resol1'</em><big>)</big><a class="headerlink" href="#File.HDF5File.HDF5File.save" title="Permalink to this definition">¶</a></dt>
<dd><p>save the ser_file to the HDF5 file</p>
</dd></dl>

<dl class="method">
<dt id="File.HDF5File.HDF5File.save_fticrd">
<tt class="descname">save_fticrd</tt><big>(</big><big>)</big><a class="headerlink" href="#File.HDF5File.HDF5File.save_fticrd" title="Permalink to this definition">¶</a></dt>
<dd><p>save the FTICRData to the H5F file</p>
</dd></dl>

<dl class="method">
<dt id="File.HDF5File.HDF5File.set_compression">
<tt class="descname">set_compression</tt><big>(</big><em>On=False</em><big>)</big><a class="headerlink" href="#File.HDF5File.HDF5File.set_compression" title="Permalink to this definition">¶</a></dt>
<dd><p>sets HDF5 file compression to zlib if On is True; to none otherwise</p>
</dd></dl>

<dl class="method">
<dt id="File.HDF5File.HDF5File.set_data">
<tt class="descname">set_data</tt><big>(</big><em>data</em>, <em>group='resol1'</em><big>)</big><a class="headerlink" href="#File.HDF5File.HDF5File.set_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Take the ser_file and the params and put all the informations in the HDF5File</p>
</dd></dl>

<dl class="method">
<dt id="File.HDF5File.HDF5File.set_data_from_fticrd">
<tt class="descname">set_data_from_fticrd</tt><big>(</big><em>buff</em>, <em>group='resol1'</em><big>)</big><a class="headerlink" href="#File.HDF5File.HDF5File.set_data_from_fticrd" title="Permalink to this definition">¶</a></dt>
<dd><p>sets the FTICRdata attached to the (to be written) file</p>
</dd></dl>

<dl class="method">
<dt id="File.HDF5File.HDF5File.table_update">
<tt class="descname">table_update</tt><big>(</big><em>group='resol1'</em>, <em>axis=2</em>, <em>key='highmass'</em>, <em>value=4000.0</em><big>)</big><a class="headerlink" href="#File.HDF5File.HDF5File.table_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Microchangement in the wanted table</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="File.HDF5File.determine_chunkshape">
<tt class="descclassname">File.HDF5File.</tt><tt class="descname">determine_chunkshape</tt><big>(</big><em>size1</em>, <em>size2</em><big>)</big><a class="headerlink" href="#File.HDF5File.determine_chunkshape" title="Permalink to this definition">¶</a></dt>
<dd><p>returns optimum size for chuncks for a dataset of file size1, size2
and update cachesize for accomodating dataset</p>
</dd></dl>

<dl class="function">
<dt id="File.HDF5File.nparray_to_fticrd">
<tt class="descclassname">File.HDF5File.</tt><tt class="descname">nparray_to_fticrd</tt><big>(</big><em>name</em>, <em>nparray</em><big>)</big><a class="headerlink" href="#File.HDF5File.nparray_to_fticrd" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="File.HDF5File.up0p6_to_0p7">
<tt class="descclassname">File.HDF5File.</tt><tt class="descname">up0p6_to_0p7</tt><big>(</big><em>fname</em>, <em>debug=1</em><big>)</big><a class="headerlink" href="#File.HDF5File.up0p6_to_0p7" title="Permalink to this definition">¶</a></dt>
<dd><p>docstring for up0p6_to_0p7
Function that deals with changing HDF5 files created with file_version 0.6 to be read with 0.7
It modifies</p>
</dd></dl>

<dl class="function">
<dt id="File.HDF5File.up0p7_to_0p8">
<tt class="descclassname">File.HDF5File.</tt><tt class="descname">up0p7_to_0p8</tt><big>(</big><em>fname</em>, <em>debug=1</em><big>)</big><a class="headerlink" href="#File.HDF5File.up0p7_to_0p8" title="Permalink to this definition">¶</a></dt>
<dd><p>docstring for up0p7_to_0p8
Function that deals with changing HDF5 files created with file_version 0.7 to be read with 0.8</p>
</dd></dl>

<dl class="function">
<dt id="File.HDF5File.update">
<tt class="descclassname">File.HDF5File.</tt><tt class="descname">update</tt><big>(</big><em>fname</em>, <em>debug=1</em><big>)</big><a class="headerlink" href="#File.HDF5File.update" title="Permalink to this definition">¶</a></dt>
<dd><p>update so that the file is up to date</p>
</dd></dl>

</div>
<div class="section" id="module-File.Solarix">
<span id="solarix"></span><h3>Solarix<a class="headerlink" href="#module-File.Solarix" title="Permalink to this headline">¶</a></h3>
<p>Solarix.py</p>
<blockquote>
<div>Utility to Handle Solarix files</div></blockquote>
<p>Created by mac on 2013-05-24.
Copyright (c) 2013 __NMRTEC__. All rights reserved.</p>
<dl class="function">
<dt id="File.Solarix.Import_1D">
<tt class="descclassname">File.Solarix.</tt><tt class="descname">Import_1D</tt><big>(</big><em>folder</em>, <em>outfile=''</em><big>)</big><a class="headerlink" href="#File.Solarix.Import_1D" title="Permalink to this definition">¶</a></dt>
<dd><p>Entry point to import 1D spectra
It returns a FTICRData
It writes a HDF5 file if an outfile is mentionned</p>
</dd></dl>

<dl class="function">
<dt id="File.Solarix.Import_2D">
<tt class="descclassname">File.Solarix.</tt><tt class="descname">Import_2D</tt><big>(</big><em>folder</em>, <em>outfile=''</em>, <em>F1specwidth=None</em><big>)</big><a class="headerlink" href="#File.Solarix.Import_2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Entry point to import 2D spectra
It returns a FTICRData
It writes a HDF5 file if an outfile is mentionned</p>
</dd></dl>

<dl class="function">
<dt id="File.Solarix.Ser2D_to_FTICRFile">
<tt class="descclassname">File.Solarix.</tt><tt class="descname">Ser2D_to_FTICRFile</tt><big>(</big><em>sizeF1</em>, <em>sizeF2</em>, <em>filename='ser'</em>, <em>outfile='H5f.h5'</em>, <em>chunks=None</em><big>)</big><a class="headerlink" href="#File.Solarix.Ser2D_to_FTICRFile" title="Permalink to this definition">¶</a></dt>
<dd><p>Charge any ser file directly in H5f file</p>
</dd></dl>

<dl class="function">
<dt id="File.Solarix.get_param">
<tt class="descclassname">File.Solarix.</tt><tt class="descname">get_param</tt><big>(</big><em>param</em>, <em>names</em>, <em>values</em><big>)</big><a class="headerlink" href="#File.Solarix.get_param" title="Permalink to this definition">¶</a></dt>
<dd><p>From params, this function returns the  value of the given param</p>
</dd></dl>

<dl class="function">
<dt id="File.Solarix.locate_acquisition">
<tt class="descclassname">File.Solarix.</tt><tt class="descname">locate_acquisition</tt><big>(</big><em>folder</em><big>)</big><a class="headerlink" href="#File.Solarix.locate_acquisition" title="Permalink to this definition">¶</a></dt>
<dd><p>From the given folder this function return the absolute path to the apexAcquisition.method file
It should always be in a subfolder</p>
</dd></dl>

<dl class="function">
<dt id="File.Solarix.read_2D">
<tt class="descclassname">File.Solarix.</tt><tt class="descname">read_2D</tt><big>(</big><em>sizeF1</em>, <em>sizeF2</em>, <em>filename='ser'</em><big>)</big><a class="headerlink" href="#File.Solarix.read_2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads in a Apex 2D fid</p>
<p>sizeF1 is the number of fid
sizeF2 is the number of data-points in the fid
uses array</p>
</dd></dl>

<dl class="function">
<dt id="File.Solarix.read_3D">
<tt class="descclassname">File.Solarix.</tt><tt class="descname">read_3D</tt><big>(</big><em>sizeF1</em>, <em>sizeF2</em>, <em>sizeF3</em>, <em>filename='ser'</em><big>)</big><a class="headerlink" href="#File.Solarix.read_3D" title="Permalink to this definition">¶</a></dt>
<dd><p>Ebauche de fonction</p>
<p>Reads in a Apex 3D fid</p>
<p>uses array</p>
</dd></dl>

<dl class="function">
<dt id="File.Solarix.read_param">
<tt class="descclassname">File.Solarix.</tt><tt class="descname">read_param</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#File.Solarix.read_param" title="Permalink to this definition">¶</a></dt>
<dd><p>Open the given file and retrieve all parameters from apexAcquisition.method
NC is written when no value for value is found</p>
<p>structure : &lt;param name = &#8220;AMS_ActiveExclusion&#8221;&gt;&lt;value&gt;0&lt;/value&gt;&lt;/param&gt;</p>
<p>read_param returns  values in a dictionnary</p>
</dd></dl>

<dl class="function">
<dt id="File.Solarix.read_scan">
<tt class="descclassname">File.Solarix.</tt><tt class="descname">read_scan</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#File.Solarix.read_scan" title="Permalink to this definition">¶</a></dt>
<dd><p>Function that returns the number of scan that have been recorded
It is used to see wether the number of recorded points correspond to the L_20 parameter</p>
</dd></dl>

<dl class="function">
<dt id="File.Solarix.write_ser">
<tt class="descclassname">File.Solarix.</tt><tt class="descname">write_ser</tt><big>(</big><em>bufferdata</em>, <em>filename='ser'</em><big>)</big><a class="headerlink" href="#File.Solarix.write_ser" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a ser file from FTICRData</p>
</dd></dl>

</div>
<div class="section" id="module-File.Thermo">
<span id="thermo"></span><h3>Thermo<a class="headerlink" href="#module-File.Thermo" title="Permalink to this headline">¶</a></h3>
<p>Utility to Handle Thermofisher files</p>
<p>Marc-André from first draft by Lionel</p>
<dl class="function">
<dt id="File.Thermo.Import_1D">
<tt class="descclassname">File.Thermo.</tt><tt class="descname">Import_1D</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#File.Thermo.Import_1D" title="Permalink to this definition">¶</a></dt>
<dd><p>Entry point to import 1D spectra
It returns an Orbitrap data</p>
</dd></dl>

<dl class="class">
<dt id="File.Thermo.Thermo_Tests">
<em class="property">class </em><tt class="descclassname">File.Thermo.</tt><tt class="descname">Thermo_Tests</tt><big>(</big><em>methodName='runTest'</em><big>)</big><a class="headerlink" href="#File.Thermo.Thermo_Tests" title="Permalink to this definition">¶</a></dt>
<dd><p>A FAIRE</p>
</dd></dl>

<dl class="function">
<dt id="File.Thermo.read_data">
<tt class="descclassname">File.Thermo.</tt><tt class="descname">read_data</tt><big>(</big><em>F</em>, <em>typ='float'</em><big>)</big><a class="headerlink" href="#File.Thermo.read_data" title="Permalink to this definition">¶</a></dt>
<dd><p>given F, an opened file, reads the values and 
read_param returns  values in a dictionnary</p>
</dd></dl>

<dl class="function">
<dt id="File.Thermo.read_param">
<tt class="descclassname">File.Thermo.</tt><tt class="descname">read_param</tt><big>(</big><em>F</em><big>)</big><a class="headerlink" href="#File.Thermo.read_param" title="Permalink to this definition">¶</a></dt>
<dd><p>given F, an opend file , retrieve all parameters found in file header</p>
<p>read_param returns  values in a plain dictionnary</p>
</dd></dl>

<dl class="function">
<dt id="File.Thermo.read_thermo">
<tt class="descclassname">File.Thermo.</tt><tt class="descname">read_thermo</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#File.Thermo.read_thermo" title="Permalink to this definition">¶</a></dt>
<dd><p>reads a thermofisher orbitrap file</p>
</dd></dl>

</div>
</div>
<div class="section" id="module-FTICR">
<span id="fticr"></span><h2>FTICR<a class="headerlink" href="#module-FTICR" title="Permalink to this headline">¶</a></h2>
<p>FTMS.py</p>
<p>Created by Marc-André on 2011-03-20.
Copyright (c) 2011 IGBMC. All rights reserved.</p>
<dl class="class">
<dt id="FTICR.FTICRAxis">
<em class="property">class </em><tt class="descclassname">FTICR.</tt><tt class="descname">FTICRAxis</tt><big>(</big><em>size=1024</em>, <em>specwidth=6283.185307179586</em>, <em>itype=0</em>, <em>units='point'</em>, <em>ref_mass=344.0974</em>, <em>ref_freq=419620.0</em>, <em>highmass=10000.0</em>, <em>left_point=0.0</em><big>)</big><a class="headerlink" href="#FTICR.FTICRAxis" title="Permalink to this definition">¶</a></dt>
<dd><p>hold information for one FT-ICR axis
used internally</p>
<dl class="method">
<dt id="FTICR.FTICRAxis.Hz_axis">
<tt class="descname">Hz_axis</tt><big>(</big><big>)</big><a class="headerlink" href="#FTICR.FTICRAxis.Hz_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>return axis containing Hz values, can be used for display</p>
</dd></dl>

<dl class="method">
<dt id="FTICR.FTICRAxis.deltamz">
<tt class="descname">deltamz</tt><big>(</big><em>mz_value</em><big>)</big><a class="headerlink" href="#FTICR.FTICRAxis.deltamz" title="Permalink to this definition">¶</a></dt>
<dd><p>computes the theorical resolution in m/z at m/z location</p>
</dd></dl>

<dl class="method">
<dt id="FTICR.FTICRAxis.extract">
<tt class="descname">extract</tt><big>(</big><em>(start</em>, <em>end)</em><big>)</big><a class="headerlink" href="#FTICR.FTICRAxis.extract" title="Permalink to this definition">¶</a></dt>
<dd><p>redefines the axis parameters so that the new axe is extracted for the points [start:end]</p>
</dd></dl>

<dl class="method">
<dt id="FTICR.FTICRAxis.freq_axis">
<tt class="descname">freq_axis</tt><big>(</big><big>)</big><a class="headerlink" href="#FTICR.FTICRAxis.freq_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>return axis containing Hz values, can be used for display</p>
</dd></dl>

<dl class="method">
<dt id="FTICR.FTICRAxis.htoi">
<tt class="descname">htoi</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#FTICR.FTICRAxis.htoi" title="Permalink to this definition">¶</a></dt>
<dd><p>returns point value (i) from Hz value (h)</p>
</dd></dl>

<dl class="method">
<dt id="FTICR.FTICRAxis.itoh">
<tt class="descname">itoh</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#FTICR.FTICRAxis.itoh" title="Permalink to this definition">¶</a></dt>
<dd><p>returns Hz value (h) from point value (i)</p>
</dd></dl>

<dl class="method">
<dt id="FTICR.FTICRAxis.itomz">
<tt class="descname">itomz</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#FTICR.FTICRAxis.itomz" title="Permalink to this definition">¶</a></dt>
<dd><p>return m/z (mz) from point value (i)</p>
</dd></dl>

<dl class="attribute">
<dt id="FTICR.FTICRAxis.lowmass">
<tt class="descname">lowmass</tt><a class="headerlink" href="#FTICR.FTICRAxis.lowmass" title="Permalink to this definition">¶</a></dt>
<dd><p>highest mass of interest - defined by the Nyquist frequency limit</p>
</dd></dl>

<dl class="method">
<dt id="FTICR.FTICRAxis.mass_axis">
<tt class="descname">mass_axis</tt><big>(</big><big>)</big><a class="headerlink" href="#FTICR.FTICRAxis.mass_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>return axis containing m/z values, can be used for display</p>
</dd></dl>

<dl class="method">
<dt id="FTICR.FTICRAxis.mz_axis">
<tt class="descname">mz_axis</tt><big>(</big><big>)</big><a class="headerlink" href="#FTICR.FTICRAxis.mz_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>return axis containing m/z values, can be used for display</p>
</dd></dl>

<dl class="method">
<dt id="FTICR.FTICRAxis.mztoi">
<tt class="descname">mztoi</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#FTICR.FTICRAxis.mztoi" title="Permalink to this definition">¶</a></dt>
<dd><p>return point value (i) from  m/z (mz)</p>
</dd></dl>

<dl class="method">
<dt id="FTICR.FTICRAxis.report">
<tt class="descname">report</tt><big>(</big><big>)</big><a class="headerlink" href="#FTICR.FTICRAxis.report" title="Permalink to this definition">¶</a></dt>
<dd><p>high level reporting</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="FTICR.FTICRData">
<em class="property">class </em><tt class="descclassname">FTICR.</tt><tt class="descname">FTICRData</tt><big>(</big><em>dim=1</em>, <em>shape=None</em>, <em>mode='memory'</em>, <em>buffer=None</em>, <em>name=None</em>, <em>debug=0</em><big>)</big><a class="headerlink" href="#FTICR.FTICRData" title="Permalink to this definition">¶</a></dt>
<dd><p>subclass of NPKData, meant for handling FT-ICR data
allows 1D and 2D data-sets</p>
<dl class="method">
<dt id="FTICR.FTICRData.display">
<tt class="descname">display</tt><big>(</big><em>scale=1.0</em>, <em>absmax=0.0</em>, <em>show=False</em>, <em>label=None</em>, <em>new_fig=True</em>, <em>axis=None</em>, <em>mode3D=False</em>, <em>zoom=None</em>, <em>xlabel='_def_'</em>, <em>ylabel='_def_'</em>, <em>figure=None</em><big>)</big><a class="headerlink" href="#FTICR.FTICRData.display" title="Permalink to this definition">¶</a></dt>
<dd><p>display the FTICR data using NPKDATA display method
check parameters in NPKDATA</p>
<ul class="simple">
<li>copied here - (might be out of date)</li>
</ul>
<p>scale   allows to increase the vertical scale of display
absmax  overwrite the value for the largest point, which will not be computed</p>
<blockquote>
<div>display is scaled so that the largest point is first computed (and stored in absmax),
and then the value at absmax/scale is set full screen</div></blockquote>
<dl class="docutils">
<dt>show    will call plot.show() at the end, allowing every declared display to be shown on-screen</dt>
<dd>useless in ipython</dd>
</dl>
<p>label   add a label text to plot
xlabel, ylabel : axes label (default is self.units - use None to remove)
axis    used as axis if present, axis length should match experiment length</p>
<blockquote>
<div>in 2D, should be a pair (xaxis,yaxis)</div></blockquote>
<p>new_fig will create a new window if set to True (default) (active only is figure==None)
mode3D  use malb 3D display instead of matplotlib contour for 2D display
zoom    is a tuple defining the zomm window (left,right) or   ((F1_limits),(F2_limits))
figure  if not None, will be used directly to display instead of using its own</p>
<p>can actually be called without harm, even if no graphic is available, it will just do nothing.</p>
</dd></dl>

<dl class="attribute">
<dt id="FTICR.FTICRData.highmass">
<tt class="descname">highmass</tt><a class="headerlink" href="#FTICR.FTICRData.highmass" title="Permalink to this definition">¶</a></dt>
<dd><p>copy highmass to all the axes</p>
</dd></dl>

<dl class="attribute">
<dt id="FTICR.FTICRData.ref_freq">
<tt class="descname">ref_freq</tt><a class="headerlink" href="#FTICR.FTICRData.ref_freq" title="Permalink to this definition">¶</a></dt>
<dd><p>copy ref_freq to all the axes</p>
</dd></dl>

<dl class="attribute">
<dt id="FTICR.FTICRData.ref_mass">
<tt class="descname">ref_mass</tt><a class="headerlink" href="#FTICR.FTICRData.ref_mass" title="Permalink to this definition">¶</a></dt>
<dd><p>copy ref_mass to all the axes</p>
</dd></dl>

<dl class="method">
<dt id="FTICR.FTICRData.save_msh5">
<tt class="descname">save_msh5</tt><big>(</big><em>name</em>, <em>set_compression=False</em><big>)</big><a class="headerlink" href="#FTICR.FTICRData.save_msh5" title="Permalink to this definition">¶</a></dt>
<dd><p>save data to a HDF5 file</p>
<p>experimental !</p>
</dd></dl>

<dl class="attribute">
<dt id="FTICR.FTICRData.specwidth">
<tt class="descname">specwidth</tt><a class="headerlink" href="#FTICR.FTICRData.specwidth" title="Permalink to this definition">¶</a></dt>
<dd><p>copy specwidth to all the axes</p>
</dd></dl>

<dl class="method">
<dt id="FTICR.FTICRData.trimz">
<tt class="descname">trimz</tt><big>(</big><em>axis=0</em><big>)</big><a class="headerlink" href="#FTICR.FTICRData.trimz" title="Permalink to this definition">¶</a></dt>
<dd><p>extract the data so as to keep only lowmass-highmass range
axis determines which axis to trim, axis=0 (default) indicates all axes</p>
</dd></dl>

<dl class="attribute">
<dt id="FTICR.FTICRData.units">
<tt class="descname">units</tt><a class="headerlink" href="#FTICR.FTICRData.units" title="Permalink to this definition">¶</a></dt>
<dd><p>copy units to all the axes</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="FTICR.fticr_mass_axis">
<tt class="descclassname">FTICR.</tt><tt class="descname">fticr_mass_axis</tt><big>(</big><em>length</em>, <em>spectral_width</em>, <em>ref_mass</em>, <em>ref_freq</em><big>)</big><a class="headerlink" href="#FTICR.fticr_mass_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>returns an array which will calibrate a FT-ICR experiment
length : number of points in the axis
spectral_width : of the ICR measure
ref_mass : value of the m/z reference
ref_freq =: frequence at which is is observed.</p>
</dd></dl>

</div>
<div class="section" id="module-Orbitrap">
<span id="orbitrap"></span><h2>Orbitrap<a class="headerlink" href="#module-Orbitrap" title="Permalink to this headline">¶</a></h2>
<p>Orbitrap.py</p>
<p>Created by Marc-André and Lionel on 10 april 2014
Copyright (c) 2014 IGBMC. All rights reserved.</p>
<dl class="class">
<dt id="Orbitrap.OrbiAxis">
<em class="property">class </em><tt class="descclassname">Orbitrap.</tt><tt class="descname">OrbiAxis</tt><big>(</big><em>size=1024</em>, <em>specwidth=10000000.0</em>, <em>itype=0</em>, <em>units='point'</em>, <em>ref_mass=715.3122</em>, <em>ref_freq=1887533.975611561</em>, <em>highmass=10000.0</em>, <em>left_point=0.0</em><big>)</big><a class="headerlink" href="#Orbitrap.OrbiAxis" title="Permalink to this definition">¶</a></dt>
<dd><p>hold information for one Orbitrap axis
used internally</p>
<dl class="method">
<dt id="Orbitrap.OrbiAxis.Hz_axis">
<tt class="descname">Hz_axis</tt><big>(</big><big>)</big><a class="headerlink" href="#Orbitrap.OrbiAxis.Hz_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>return axis containing Hz values, can be used for display</p>
</dd></dl>

<dl class="method">
<dt id="Orbitrap.OrbiAxis.deltamz">
<tt class="descname">deltamz</tt><big>(</big><em>mz_value</em><big>)</big><a class="headerlink" href="#Orbitrap.OrbiAxis.deltamz" title="Permalink to this definition">¶</a></dt>
<dd><p>computes the theorical resolution in m/z at m/z location</p>
</dd></dl>

<dl class="method">
<dt id="Orbitrap.OrbiAxis.extract">
<tt class="descname">extract</tt><big>(</big><em>(start</em>, <em>end)</em><big>)</big><a class="headerlink" href="#Orbitrap.OrbiAxis.extract" title="Permalink to this definition">¶</a></dt>
<dd><p>redefines the axis parameters so that the new axe is extracted for the points [start:end]</p>
</dd></dl>

<dl class="method">
<dt id="Orbitrap.OrbiAxis.freq_axis">
<tt class="descname">freq_axis</tt><big>(</big><big>)</big><a class="headerlink" href="#Orbitrap.OrbiAxis.freq_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>return axis containing Hz values, can be used for display</p>
</dd></dl>

<dl class="method">
<dt id="Orbitrap.OrbiAxis.htoi">
<tt class="descname">htoi</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#Orbitrap.OrbiAxis.htoi" title="Permalink to this definition">¶</a></dt>
<dd><p>returns point value (i) from Hz value (h)</p>
</dd></dl>

<dl class="method">
<dt id="Orbitrap.OrbiAxis.itoh">
<tt class="descname">itoh</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#Orbitrap.OrbiAxis.itoh" title="Permalink to this definition">¶</a></dt>
<dd><p>returns Hz value (h) from point value (i)</p>
</dd></dl>

<dl class="method">
<dt id="Orbitrap.OrbiAxis.itomz">
<tt class="descname">itomz</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#Orbitrap.OrbiAxis.itomz" title="Permalink to this definition">¶</a></dt>
<dd><p>return m/z (mz) from point value (i)</p>
</dd></dl>

<dl class="attribute">
<dt id="Orbitrap.OrbiAxis.lowmass">
<tt class="descname">lowmass</tt><a class="headerlink" href="#Orbitrap.OrbiAxis.lowmass" title="Permalink to this definition">¶</a></dt>
<dd><p>highest mass of interest - defined by the Nyquist frequency limit</p>
</dd></dl>

<dl class="method">
<dt id="Orbitrap.OrbiAxis.mztoi">
<tt class="descname">mztoi</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#Orbitrap.OrbiAxis.mztoi" title="Permalink to this definition">¶</a></dt>
<dd><p>return point value (i) from  m/z (mz)</p>
</dd></dl>

<dl class="method">
<dt id="Orbitrap.OrbiAxis.report">
<tt class="descname">report</tt><big>(</big><big>)</big><a class="headerlink" href="#Orbitrap.OrbiAxis.report" title="Permalink to this definition">¶</a></dt>
<dd><p>high level reporting</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Orbitrap.OrbiData">
<em class="property">class </em><tt class="descclassname">Orbitrap.</tt><tt class="descname">OrbiData</tt><big>(</big><em>dim=1</em>, <em>shape=None</em>, <em>mode='memory'</em>, <em>buffer=None</em>, <em>name=None</em>, <em>debug=0</em><big>)</big><a class="headerlink" href="#Orbitrap.OrbiData" title="Permalink to this definition">¶</a></dt>
<dd><p>subclass of NPKData, meant for handling Orbitrap data
doc to be written ...</p>
<dl class="method">
<dt id="Orbitrap.OrbiData.display">
<tt class="descname">display</tt><big>(</big><em>scale=1.0</em>, <em>absmax=0.0</em>, <em>show=False</em>, <em>label=None</em>, <em>new_fig=True</em>, <em>axis=None</em>, <em>mode3D=False</em>, <em>zoom=None</em>, <em>xlabel='_def_'</em>, <em>ylabel='_def_'</em>, <em>figure=None</em><big>)</big><a class="headerlink" href="#Orbitrap.OrbiData.display" title="Permalink to this definition">¶</a></dt>
<dd><p>display the Orbitrap data using NPKDATA display method
check parameters in NPKDATA</p>
<ul class="simple">
<li>copied here - (might be out of date)</li>
</ul>
<p>scale   allows to increase the vertical scale of display
absmax  overwrite the value for the largest point, which will not be computed</p>
<blockquote>
<div>display is scaled so that the largest point is first computed (and stored in absmax),
and then the value at absmax/scale is set full screen</div></blockquote>
<dl class="docutils">
<dt>show    will call plot.show() at the end, allowing every declared display to be shown on-screen</dt>
<dd>useless in ipython</dd>
</dl>
<p>label   add a label text to plot
xlabel, ylabel : axes label (default is self.units - use None to remove)
axis    used as axis if present, axis length should match experiment length</p>
<blockquote>
<div>in 2D, should be a pair (xaxis,yaxis)</div></blockquote>
<p>new_fig will create a new window if set to True (default) (active only is figure==None)
mode3D  use malb 3D display instead of matplotlib contour for 2D display
zoom    is a tuple defining the zomm window (left,right) or   ((F1_limits),(F2_limits))
figure  if not None, will be used directly to display instead of using its own</p>
<p>can actually be called without harm, even if no graphic is available, it will just do nothing.</p>
</dd></dl>

<dl class="attribute">
<dt id="Orbitrap.OrbiData.highmass">
<tt class="descname">highmass</tt><a class="headerlink" href="#Orbitrap.OrbiData.highmass" title="Permalink to this definition">¶</a></dt>
<dd><p>copy highmass to all the axes</p>
</dd></dl>

<dl class="attribute">
<dt id="Orbitrap.OrbiData.ref_freq">
<tt class="descname">ref_freq</tt><a class="headerlink" href="#Orbitrap.OrbiData.ref_freq" title="Permalink to this definition">¶</a></dt>
<dd><p>copy ref_freq to all the axes</p>
</dd></dl>

<dl class="attribute">
<dt id="Orbitrap.OrbiData.ref_mass">
<tt class="descname">ref_mass</tt><a class="headerlink" href="#Orbitrap.OrbiData.ref_mass" title="Permalink to this definition">¶</a></dt>
<dd><p>copy ref_mass to all the axes</p>
</dd></dl>

<dl class="method">
<dt id="Orbitrap.OrbiData.save_msh5">
<tt class="descname">save_msh5</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#Orbitrap.OrbiData.save_msh5" title="Permalink to this definition">¶</a></dt>
<dd><p>save data to a HDF5 file</p>
<p>experimental !</p>
</dd></dl>

<dl class="attribute">
<dt id="Orbitrap.OrbiData.specwidth">
<tt class="descname">specwidth</tt><a class="headerlink" href="#Orbitrap.OrbiData.specwidth" title="Permalink to this definition">¶</a></dt>
<dd><p>copy specwidth to all the axes</p>
</dd></dl>

<dl class="method">
<dt id="Orbitrap.OrbiData.trimz">
<tt class="descname">trimz</tt><big>(</big><em>axis=0</em><big>)</big><a class="headerlink" href="#Orbitrap.OrbiData.trimz" title="Permalink to this definition">¶</a></dt>
<dd><p>extract the data so as to keep only lowmass-highmass range
axis determines which axis to trim, axis=0 (default) indicates all axes</p>
</dd></dl>

<dl class="attribute">
<dt id="Orbitrap.OrbiData.units">
<tt class="descname">units</tt><a class="headerlink" href="#Orbitrap.OrbiData.units" title="Permalink to this definition">¶</a></dt>
<dd><p>copy units to all the axes</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-visu2D">
<span id="visu2d"></span><h2>visu2D<a class="headerlink" href="#module-visu2D" title="Permalink to this headline">¶</a></h2>
<p>Created by Marc Andre Delsuc &amp; Lionel Chiron on 2011-05-19.
Copyright (c) 2011 IGBMC. All rights reserved.
###
Program for visualizing FTICR2D data.</p>
<dl class="function">
<dt id="visu2D.debugs_activate">
<tt class="descclassname">visu2D.</tt><tt class="descname">debugs_activate</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#visu2D.debugs_activate" title="Permalink to this definition">¶</a></dt>
<dd><p>Debugging class methods.
Classes debugged are
-interface
-display
-convert
-gtools
-zooming
-move window
-interact</p>
</dd></dl>

<dl class="function">
<dt id="visu2D.main">
<tt class="descclassname">visu2D.</tt><tt class="descname">main</tt><big>(</big><em>argv=None</em><big>)</big><a class="headerlink" href="#visu2D.main" title="Permalink to this definition">¶</a></dt>
<dd><p>creates and runs</p>
</dd></dl>

<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="visu2d.html">inside Visu2D</a><ul>
<li class="toctree-l2"><a class="reference internal" href="visu2d.html#initialize-and-handle">Initialize and handle</a></li>
<li class="toctree-l2"><a class="reference internal" href="visu2d.html#visualization">Visualization</a></li>
<li class="toctree-l2"><a class="reference internal" href="visu2d.html#miscellaneous">Miscellaneous</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div class="section" id="module-processing">
<span id="processing-2d"></span><h2>Processing 2D<a class="headerlink" href="#module-processing" title="Permalink to this headline">¶</a></h2>
<p>Processing.py</p>
<p>This program realises the processing of an FTICR data</p>
<p>Created by Marc-Andre on 2011-09-23.
Copyright (c) 2011 IGBMC. All rights reserved.</p>
<dl class="class">
<dt id="processing.Proc_Parameters">
<em class="property">class </em><tt class="descclassname">processing.</tt><tt class="descname">Proc_Parameters</tt><big>(</big><em>configfile=None</em><big>)</big><a class="headerlink" href="#processing.Proc_Parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>this class is a container for processing parameters</p>
<dl class="method">
<dt id="processing.Proc_Parameters.load">
<tt class="descname">load</tt><big>(</big><em>cp</em><big>)</big><a class="headerlink" href="#processing.Proc_Parameters.load" title="Permalink to this definition">¶</a></dt>
<dd><p>load from cp config file - should have been opened with ConfigParser() first</p>
</dd></dl>

<dl class="method">
<dt id="processing.Proc_Parameters.report">
<tt class="descname">report</tt><big>(</big><big>)</big><a class="headerlink" href="#processing.Proc_Parameters.report" title="Permalink to this definition">¶</a></dt>
<dd><p>print a formatted report</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="processing.Test">
<em class="property">class </em><tt class="descclassname">processing.</tt><tt class="descname">Test</tt><big>(</big><em>methodName='runTest'</em><big>)</big><a class="headerlink" href="#processing.Test" title="Permalink to this definition">¶</a></dt>
<dd><p>tests</p>
<dl class="method">
<dt id="processing.Test.test_intelli">
<tt class="descname">test_intelli</tt><big>(</big><big>)</big><a class="headerlink" href="#processing.Test.test_intelli" title="Permalink to this definition">¶</a></dt>
<dd><p>testing &#8216;intelligent&#8217; rounding</p>
</dd></dl>

<dl class="method">
<dt id="processing.Test.test_proc">
<tt class="descname">test_proc</tt><big>(</big><big>)</big><a class="headerlink" href="#processing.Test.test_proc" title="Permalink to this definition">¶</a></dt>
<dd><p>apply a complete processing test</p>
</dd></dl>

<dl class="method">
<dt id="processing.Test.test_zf">
<tt class="descname">test_zf</tt><big>(</big><big>)</big><a class="headerlink" href="#processing.Test.test_zf" title="Permalink to this definition">¶</a></dt>
<dd><p>testing zerofilling computation</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="processing.apod">
<tt class="descclassname">processing.</tt><tt class="descname">apod</tt><big>(</big><em>d</em>, <em>size</em>, <em>axis=0</em><big>)</big><a class="headerlink" href="#processing.apod" title="Permalink to this definition">¶</a></dt>
<dd><p>apply sin 0.5 apodisation and change size</p>
</dd></dl>

<dl class="function">
<dt id="processing.comp_sizes">
<tt class="descclassname">processing.</tt><tt class="descname">comp_sizes</tt><big>(</big><em>d0</em>, <em>zflist=None</em>, <em>szmlist=None</em>, <em>largest=8589934592</em>, <em>sizemin=1024</em>, <em>vignette=True</em><big>)</big><a class="headerlink" href="#processing.comp_sizes" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>return a list with data-sizes, computed either</dt>
<dd>zflist : from zerofilling index    eg : (1,0,-1)
szmlist : from multiplicant pairs  eg : (2,2)</dd>
</dl>
<p>largest determines the largest dataset allowed
sizemini determines the minimum size when downzerofilling
when vignette == True (default) a minimum size data (defined by sizemini) is appended to the list</p>
</dd></dl>

<dl class="function">
<dt id="processing.do_proc_F1">
<tt class="descclassname">processing.</tt><tt class="descname">do_proc_F1</tt><big>(</big><em>dinp</em>, <em>doutp</em><big>)</big><a class="headerlink" href="#processing.do_proc_F1" title="Permalink to this definition">¶</a></dt>
<dd><p>scan all cols of dinp, apply proc() and store into doutp</p>
</dd></dl>

<dl class="function">
<dt id="processing.do_proc_F1_flip_modu">
<tt class="descclassname">processing.</tt><tt class="descname">do_proc_F1_flip_modu</tt><big>(</big><em>dinp</em>, <em>doutp</em>, <em>parameter</em><big>)</big><a class="headerlink" href="#processing.do_proc_F1_flip_modu" title="Permalink to this definition">¶</a></dt>
<dd><p>as do_proc_F1, but applies flip and then complex modulus() at the end</p>
</dd></dl>

<dl class="function">
<dt id="processing.do_proc_F1_modu">
<tt class="descclassname">processing.</tt><tt class="descname">do_proc_F1_modu</tt><big>(</big><em>dinp</em>, <em>doutp</em><big>)</big><a class="headerlink" href="#processing.do_proc_F1_modu" title="Permalink to this definition">¶</a></dt>
<dd><p>as do_proc_F1, but applies hypercomplex modulus() at the end</p>
</dd></dl>

<dl class="function">
<dt id="processing.do_proc_F2">
<tt class="descclassname">processing.</tt><tt class="descname">do_proc_F2</tt><big>(</big><em>dinp</em>, <em>doutp</em><big>)</big><a class="headerlink" href="#processing.do_proc_F2" title="Permalink to this definition">¶</a></dt>
<dd><p>scan all rows of dinp, apply proc() and store into doutp</p>
</dd></dl>

<dl class="function">
<dt id="processing.do_process2D">
<tt class="descclassname">processing.</tt><tt class="descname">do_process2D</tt><big>(</big><em>dinp</em>, <em>datatemp</em>, <em>doutp</em>, <em>parameter</em><big>)</big><a class="headerlink" href="#processing.do_process2D" title="Permalink to this definition">¶</a></dt>
<dd><p>apply the processing to an input 2D data set : dinp
result is found in an output file : doutp</p>
<p>dinp and doutp should have been created before, size of doutp will determine the processing
will use a temporay file if needed</p>
</dd></dl>

<dl class="function">
<dt id="processing.downsample2D">
<tt class="descclassname">processing.</tt><tt class="descname">downsample2D</tt><big>(</big><em>data</em>, <em>outp</em>, <em>n1</em>, <em>n2</em><big>)</big><a class="headerlink" href="#processing.downsample2D" title="Permalink to this definition">¶</a></dt>
<dd><p>takes data (a 2D) and generate a smaller dataset downsampled by factor (n1,n2) on each axis
then returned data-set is n1*n2 times smaller
- simply takes the mean
** Not fully tested on non powers of 2 **</p>
</dd></dl>

<dl class="function">
<dt id="processing.intelliround">
<tt class="descclassname">processing.</tt><tt class="descname">intelliround</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#processing.intelliround" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a number rounded to the nearest &#8216;round&#8217; (easy to FT) integer</p>
</dd></dl>

<dl class="data">
<dt id="processing.interfproc">
<tt class="descclassname">processing.</tt><tt class="descname">interfproc</tt><em class="property"> = False</em><a class="headerlink" href="#processing.interfproc" title="Permalink to this definition">¶</a></dt>
<dd><p>Processing for performing urQRd  on 2D FTICR datasets.
previous version was named processing2-urqrd-superresol
under Linux or MacOsX : mpirun -n nbproc python processing.py (configfile.mscf)
under Windows : mpiexec -n nbproc python processing.py (configfile.mscf)</p>
</dd></dl>

<dl class="function">
<dt id="processing.iterarg">
<tt class="descclassname">processing.</tt><tt class="descname">iterarg</tt><big>(</big><em>dinp</em>, <em>rot</em>, <em>size</em>, <em>parameter</em><big>)</big><a class="headerlink" href="#processing.iterarg" title="Permalink to this definition">¶</a></dt>
<dd><p>an iterator used by the processing to allow  multiprocessing or MPI set-up</p>
</dd></dl>

<dl class="function">
<dt id="processing.load_input">
<tt class="descclassname">processing.</tt><tt class="descname">load_input</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#processing.load_input" title="Permalink to this definition">¶</a></dt>
<dd><p>load input file and returns it, in read-only mode</p>
</dd></dl>

<dl class="function">
<dt id="processing.main">
<tt class="descclassname">processing.</tt><tt class="descname">main</tt><big>(</big><em>argv=None</em><big>)</big><a class="headerlink" href="#processing.main" title="Permalink to this definition">¶</a></dt>
<dd><p>Does the whole on-file processing, 
syntax is
processing.py [ configuration_file.mscf ]
if no argument is given, the standard file : process.mscf is used.</p>
</dd></dl>

<dl class="function">
<dt id="processing.pred_sizes">
<tt class="descclassname">processing.</tt><tt class="descname">pred_sizes</tt><big>(</big><em>d0</em>, <em>szmult=(1</em>, <em>1)</em>, <em>sizemin=1024</em><big>)</big><a class="headerlink" href="#processing.pred_sizes" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>given an input data set, determines the optimum size s1,s2 to process it</dt>
<dd>with a size multiplicant of szmult</dd>
</dl>
<p>szmult (szm1, szm2)     where szm1 is multiplicant for s1 and szm2 for s2
szmx = 1 : no change  /  2 : size doubling  /  0.5 : size halving
any strictly positive value is possible, 0.2 0.33 1.1 2 2.2 5 etc...</p>
<p>however, axes can never get smaller than sizemin
returns (si1, si2, ...) as the dataset dimension</p>
</dd></dl>

<dl class="function">
<dt id="processing.pred_sizes_zf">
<tt class="descclassname">processing.</tt><tt class="descname">pred_sizes_zf</tt><big>(</big><em>d0</em>, <em>zf=0</em>, <em>sizemin=1024</em><big>)</big><a class="headerlink" href="#processing.pred_sizes_zf" title="Permalink to this definition">¶</a></dt>
<dd><p>given an input data set, determines the optimum size s1,s2 to process it with a zerofilling of zf
zf = +n is doubling n times along each axis
zf = -n is halving n times along each axis
zf = 0 is no zerofiling
however, axes can never get smaller than sizemin
returns (si1, si2, ...) as the dataset dimension</p>
</dd></dl>

<dl class="function">
<dt id="processing.print_time">
<tt class="descclassname">processing.</tt><tt class="descname">print_time</tt><big>(</big><em>t</em>, <em>st='Processing time'</em><big>)</big><a class="headerlink" href="#processing.print_time" title="Permalink to this definition">¶</a></dt>
<dd><p>prints processing time</p>
</dd></dl>

</div>
<div class="section" id="algorithms">
<h2>Algorithms<a class="headerlink" href="#algorithms" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-Algo.urQRd">
<span id="urqrd"></span><h3>urQRd<a class="headerlink" href="#module-Algo.urQRd" title="Permalink to this headline">¶</a></h3>
<div class="section" id="urqrd-py">
<h4>urQRd.py<a class="headerlink" href="#urqrd-py" title="Permalink to this headline">¶</a></h4>
<p>Algorithm for denoising time series, named urQRd (standing for &#8220;uncoiled random QR denoising&#8221;)</p>
<p>main function is 
urQRd(data, rank)
data : the series to be denoised
rank : the rank of the analysis</p>
<p>Copyright (c) 2013 IGBMC. All rights reserved.
Marc-Andr&#8217;e Delsuc &lt;<a class="reference external" href="mailto:madelsuc&#37;&#52;&#48;unistra&#46;fr">madelsuc<span>&#64;</span>unistra<span>&#46;</span>fr</a>&gt;
Lionel Chiron &lt;<a class="reference external" href="mailto:lionel&#46;chiron&#37;&#52;&#48;gmail&#46;com">lionel<span>&#46;</span>chiron<span>&#64;</span>gmail<span>&#46;</span>com</a>&gt;</p>
<p>This software is a computer program whose purpose is to compute urQRd denoising.</p>
<p>This software is governed by the CeCILL  license under French law and
abiding by the rules of distribution of free software.  You can  use, 
modify and/ or redistribute the software under the terms of the CeCILL
license as circulated by CEA, CNRS and INRIA at the following URL
&#8220;<a class="reference external" href="http://www.cecill.info">http://www.cecill.info</a>&#8221;.</p>
<p>As a counterpart to the access to the source code and  rights to copy,
modify and redistribute granted by the license, users are provided only
with a limited warranty  and the software&#8217;s author,  the holder of the
economic rights,  and the successive licensors  have only  limited
liability.</p>
<p>In this respect, the user&#8217;s attention is drawn to the risks associated
with loading,  using,  modifying and/or developing or reproducing the
software by the user in light of its specific status of free software,
that may mean  that it is complicated to manipulate,  and  that  also
therefore means  that it is reserved for developers  and  experienced
professionals having in-depth computer knowledge. Users are therefore
encouraged to load and test the software&#8217;s suitability as regards their
requirements in conditions enabling the security of their systems and/or 
data to be ensured and,  more generally, to use and operate it in the 
same conditions as regards security.</p>
<p>The fact that you are presently reading this means that you have had
knowledge of the CeCILL license and that you accept its terms.</p>
<p>Created by Lionel Chiron and Marc-Andr&#8217;e on 2013-10-13.</p>
<p>version 2.0 
28/oct/2013</p>
<dl class="function">
<dt id="Algo.urQRd.FastHankel_prod_mat_mat">
<tt class="descclassname">Algo.urQRd.</tt><tt class="descname">FastHankel_prod_mat_mat</tt><big>(</big><em>gene_vect</em>, <em>matrix</em><big>)</big><a class="headerlink" href="#Algo.urQRd.FastHankel_prod_mat_mat" title="Permalink to this definition">¶</a></dt>
<dd><p>Fast Hankel structured matrix matrix product based on FastHankel_prod_mat_vec</p>
</dd></dl>

<dl class="function">
<dt id="Algo.urQRd.FastHankel_prod_mat_vec">
<tt class="descclassname">Algo.urQRd.</tt><tt class="descname">FastHankel_prod_mat_vec</tt><big>(</big><em>gene_vect</em>, <em>prod_vect</em><big>)</big><a class="headerlink" href="#Algo.urQRd.FastHankel_prod_mat_vec" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute product of Hankel matrix (gene_vect)  by vector prod_vect.
H is not computed
M is the length of the result</p>
</dd></dl>

<dl class="function">
<dt id="Algo.urQRd.Fast_Hankel2dt">
<tt class="descclassname">Algo.urQRd.</tt><tt class="descname">Fast_Hankel2dt</tt><big>(</big><em>Q</em>, <em>QH</em><big>)</big><a class="headerlink" href="#Algo.urQRd.Fast_Hankel2dt" title="Permalink to this definition">¶</a></dt>
<dd><p>returning to data from Q and QstarH
Based on FastHankel_prod_mat_vec.</p>
</dd></dl>

<dl class="function">
<dt id="Algo.urQRd.urQRd">
<tt class="descclassname">Algo.urQRd.</tt><tt class="descname">urQRd</tt><big>(</big><em>data</em>, <em>k</em>, <em>orda=None</em>, <em>iterations=1</em>, <em>optk=False</em><big>)</big><a class="headerlink" href="#Algo.urQRd.urQRd" title="Permalink to this definition">¶</a></dt>
<dd><p>urQRd algorithm. Name stands for uncoiled random QR denoising.
From a data series return a denoised series denoised
data : the series to be denoised - a (normally complex) numpy buffer
k : the rank of the analysis
orda : is the order of the analysis</p>
<blockquote>
<div>internally, a Hankel matrix (M,N) is constructed, with M = orda and N = len(data)-orda+1
if None (default) orda = (len(data)+1)/2</div></blockquote>
<p>iterations : the number of time the operation should be repeated</p>
<p>values are such that
orda &lt;= (len(data)+1)/2
k &lt; orda
N = len(data)-orda+1
Omega is (N x k)
##########
BECAREFUL datasize must be different from a product of primes !!!!!!..
a processing with a datasize of 120022 for example will be 50 times longer than
a procesing of a datasize of 120000.
##########</p>
</dd></dl>

<dl class="function">
<dt id="Algo.urQRd.urQRdCore">
<tt class="descclassname">Algo.urQRd.</tt><tt class="descname">urQRdCore</tt><big>(</big><em>data</em>, <em>Omega</em><big>)</big><a class="headerlink" href="#Algo.urQRd.urQRdCore" title="Permalink to this definition">¶</a></dt>
<dd><p>Core of urQRd algorithm</p>
</dd></dl>

<dl class="function">
<dt id="Algo.urQRd.vec_mean">
<tt class="descclassname">Algo.urQRd.</tt><tt class="descname">vec_mean</tt><big>(</big><em>M</em>, <em>L</em><big>)</big><a class="headerlink" href="#Algo.urQRd.vec_mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Vector for calculating the mean from the sum on the antidiagonal.
data = vec_sum*vec_mean</p>
</dd></dl>

</div>
</div>
<div class="section" id="module-Algo.Linpredic">
<span id="linpredic"></span><h3>Linpredic<a class="headerlink" href="#module-Algo.Linpredic" title="Permalink to this headline">¶</a></h3>
<p>Adaptation of code from :</p>
<p>file              CollombBurg.py
author/translator Ernesto P. Adorio</p>
<blockquote>
<div>UPDEPP (UP Clark)
<a class="reference external" href="mailto:ernesto&#46;adorio&#37;&#52;&#48;gmail&#46;com">ernesto<span>&#46;</span>adorio<span>&#64;</span>gmail<span>&#46;</span>com</a></div></blockquote>
<p>Version           0.0.1 jun 11, 2010 # first release.
References        Burg&#8217;s Method, Algorithm and Recursion, pp. 9-11</p>
<p>Created by Lionel on 2011-09-18.
Removed the &#8220;for loops&#8221; so as to speed up using numpy capabilities.
Copyright (c) 2010 IGBMC. All rights reserved.</p>
<dl class="class">
<dt id="Algo.Linpredic.LinpredTests">
<em class="property">class </em><tt class="descclassname">Algo.Linpredic.</tt><tt class="descname">LinpredTests</tt><big>(</big><em>methodName='runTest'</em><big>)</big><a class="headerlink" href="#Algo.Linpredic.LinpredTests" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Testing linear prediction , Burg algorithm-</li>
</ul>
<dl class="method">
<dt id="Algo.Linpredic.LinpredTests.test_burg">
<tt class="descname">test_burg</tt><big>(</big><big>)</big><a class="headerlink" href="#Algo.Linpredic.LinpredTests.test_burg" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>testing burg algo -</li>
</ul>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="Algo.Linpredic.burg">
<tt class="descclassname">Algo.Linpredic.</tt><tt class="descname">burg</tt><big>(</big><em>m</em>, <em>x</em><big>)</big><a class="headerlink" href="#Algo.Linpredic.burg" title="Permalink to this definition">¶</a></dt>
<dd><p>Based on Collomb&#8217;s C++ code, pp. 10-11
Burgs Method, algorithm and recursion</p>
<blockquote>
<div>m - number of lags in autoregressive model.
x  - data vector to approximate.</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="Algo.Linpredic.denoise">
<tt class="descclassname">Algo.Linpredic.</tt><tt class="descname">denoise</tt><big>(</big><em>data</em>, <em>ar</em><big>)</big><a class="headerlink" href="#Algo.Linpredic.denoise" title="Permalink to this definition">¶</a></dt>
<dd><p>returned a denoised version of &#8220;data&#8221;, using &#8220;ar&#8221; polynomial
first len(ar) points are untouched.</p>
</dd></dl>

<dl class="function">
<dt id="Algo.Linpredic.predict">
<tt class="descclassname">Algo.Linpredic.</tt><tt class="descname">predict</tt><big>(</big><em>data</em>, <em>ar</em>, <em>length</em><big>)</big><a class="headerlink" href="#Algo.Linpredic.predict" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a vector with additional points, predicted at the end of &#8220;data&#8221; up to total size &#8220;length&#8221;, using &#8220;ar&#8221; polynomial</p>
</dd></dl>

</div>
</div>
</div>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2014, a.<br/>
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.2.<br/>
    </p>
  </div>
</footer>
  </body>
</html>